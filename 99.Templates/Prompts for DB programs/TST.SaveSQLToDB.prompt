DB08.SaveSQLToDB.py 프로그램을 작성해주세요. 이 프로그램은 SQL 파일을 읽어서 PostgreSQL 데이터베이스의 sqllist 테이블에 저장하는 프로그램입니다.

요구사항:
1. orcl_sql_done 및 pg_sql_done 디렉토리에서 SQL 파일을 읽습니다.
2. 각 SQL 파일에서 다음 정보를 추출합니다:
   - sql_id: 파일명에서 추출 (app.module.query.sql → query)
   - app_name: 파일명에서 추출 (app.module.query.sql → app)
   - stmt_type: SQL 문 첫 단어에 따라 결정
     - SELECT → 'S'
     - INSERT → 'I'
     - UPDATE → 'U'
     - DELETE → 'D'
     - DECLARE 또는 BEGIN → 'P'
     - CREATE, ALTER, DROP, TRUNCATE → 'O'
   - orcl_file_path 또는 pg_file_path: SQL 파일의 절대 경로
   - orcl 또는 pg: SQL 파일의 내용
3. 파일명 패턴을 기반으로 Oracle SQL과 PostgreSQL SQL을 매칭합니다:
   - 같은 app_name과 sql_id를 가진 파일을 찾아 매칭
4. 매칭된 SQL 쌍을 sqllist 테이블에 저장합니다.
5. 이미 존재하는 레코드는 업데이트합니다.
6. 병렬 처리를 통해 대량의 SQL 파일을 효율적으로 처리합니다.

파일명 파싱 함수:
```python
def parse_filename(filename):
    """
    SQL 파일명에서 app_name과 sql_id를 추출합니다.
    
    Args:
        filename (str): SQL 파일명 (예: app.module.query.sql)
        
    Returns:
        tuple: (app_name, sql_id) 튜플
    """
    # 확장자 제거
    base_name = os.path.splitext(os.path.basename(filename))[0]
    
    # 점으로 구분된 부분 추출
    parts = base_name.split('.')
    
    if len(parts) >= 3:
        # app.module.query 형식
        app_name = parts[0]
        sql_id = parts[-1]
    elif len(parts) == 2:
        # app.query 형식
        app_name = parts[0]
        sql_id = parts[1]
    elif len(parts) == 1:
        # query 형식 (app_name 없음)
        app_name = "unknown"
        sql_id = parts[0]
    else:
        # 예상치 못한 형식
        app_name = "unknown"
        sql_id = base_name
        
    return app_name, sql_id
```

SQL 타입 결정 함수:
```python
def determine_stmt_type(sql_content):
    """
    SQL 문의 첫 단어를 분석하여 stmt_type을 결정합니다.
    
    Args:
        sql_content (str): SQL 문 내용
        
    Returns:
        str: stmt_type (S, I, U, D, P, O)
    """
    # 주석 제거 및 공백 정리
    sql_clean = re.sub(r'--.*?$|/\*.*?\*/', '', sql_content, flags=re.MULTILINE|re.DOTALL)
    sql_clean = sql_clean.strip()
    
    if not sql_clean:
        return 'O'  # 빈 SQL
        
    # 첫 단어 추출
    first_word = sql_clean.split(None, 1)[0].upper()
    
    # 타입 결정
    if first_word == 'SELECT':
        return 'S'
    elif first_word == 'INSERT':
        return 'I'
    elif first_word == 'UPDATE':
        return 'U'
    elif first_word == 'DELETE':
        return 'D'
    elif first_word in ('DECLARE', 'BEGIN'):
        return 'P'
    elif first_word in ('CREATE', 'ALTER', 'DROP', 'TRUNCATE', 'GRANT', 'REVOKE'):
        return 'O'
    else:
        # 기타 SQL 타입
        return 'O'
```

병렬 처리 구현:
```python
def process_files_in_parallel(orcl_files, pg_files, max_workers=8):
    """
    SQL 파일을 병렬로 처리합니다.
    
    Args:
        orcl_files (dict): Oracle SQL 파일 매핑 (key: (app_name, sql_id), value: file_path)
        pg_files (dict): PostgreSQL SQL 파일 매핑 (key: (app_name, sql_id), value: file_path)
        max_workers (int): 최대 작업자 수
        
    Returns:
        list: 처리된 SQL 쌍 목록
    """
    # 매칭된 SQL 쌍 찾기
    matched_pairs = []
    for key in set(orcl_files.keys()) & set(pg_files.keys()):
        matched_pairs.append((key, orcl_files[key], pg_files[key]))
    
    results = []
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # 각 SQL 쌍을 병렬로 처리
        future_to_pair = {executor.submit(process_sql_pair, app_name, sql_id, orcl_path, pg_path): (app_name, sql_id) 
                         for (app_name, sql_id), orcl_path, pg_path in matched_pairs}
        
        # 진행 상황 표시
        total = len(future_to_pair)
        completed = 0
        
        for future in as_completed(future_to_pair):
            app_name, sql_id = future_to_pair[future]
            try:
                result = future.result()
                results.append(result)
            except Exception as e:
                print(f"오류 발생 ({app_name}.{sql_id}): {e}")
            
            # 진행 상황 업데이트
            completed += 1
            print(f"처리 중: {completed}/{total} ({completed/total*100:.1f}%)", end='\r')
    
    print()  # 줄바꿈
    return results
```

데이터베이스 저장 함수:
```python
def save_to_database(sql_pairs, conn):
    """
    SQL 쌍을 데이터베이스에 저장합니다.
    
    Args:
        sql_pairs (list): 처리된 SQL 쌍 목록
        conn (psycopg2.connection): PostgreSQL 연결 객체
        
    Returns:
        int: 저장된 레코드 수
    """
    inserted = 0
    updated = 0
    
    with conn.cursor() as cursor:
        for pair in sql_pairs:
            sql_id = pair['sql_id']
            app_name = pair['app_name']
            stmt_type = pair['stmt_type']
            orcl_file_path = pair.get('orcl_file_path', '')
            pg_file_path = pair.get('pg_file_path', '')
            orcl = pair.get('orcl', '')
            pg = pair.get('pg', '')
            
            # 레코드 존재 여부 확인
            cursor.execute("SELECT 1 FROM sqllist WHERE sql_id = %s", (sql_id,))
            exists = cursor.fetchone() is not None
            
            if exists:
                # 업데이트
                cursor.execute("""
                    UPDATE sqllist SET
                        app_name = %s,
                        stmt_type = %s,
                        orcl_file_path = %s,
                        pg_file_path = %s,
                        orcl = %s,
                        pg = %s,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE sql_id = %s
                """, (app_name, stmt_type, orcl_file_path, pg_file_path, orcl, pg, sql_id))
                updated += 1
            else:
                # 삽입
                cursor.execute("""
                    INSERT INTO sqllist (
                        sql_id, app_name, stmt_type, orcl_file_path, pg_file_path, orcl, pg, created_at, updated_at
                    ) VALUES (
                        %s, %s, %s, %s, %s, %s, %s, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
                    )
                """, (sql_id, app_name, stmt_type, orcl_file_path, pg_file_path, orcl, pg))
                inserted += 1
    
    conn.commit()
    return inserted, updated
```

오류 처리:
1. 파일 읽기 오류 처리:
   ```python
   def read_sql_file(file_path):
       """
       SQL 파일을 읽습니다.
       
       Args:
           file_path (str): SQL 파일 경로
           
       Returns:
           str: SQL 파일 내용
       """
       try:
           with open(file_path, 'r', encoding='utf-8') as f:
               return f.read()
       except UnicodeDecodeError:
           # UTF-8로 읽기 실패 시 다른 인코딩 시도
           try:
               with open(file_path, 'r', encoding='cp949') as f:
                   return f.read()
           except Exception as e:
               print(f"파일 읽기 오류 ({file_path}): {e}")
               return ""
       except Exception as e:
           print(f"파일 읽기 오류 ({file_path}): {e}")
           return ""
   ```

2. 데이터베이스 연결 오류 처리:
   ```python
   try:
       conn = psycopg2.connect(
           host=os.environ.get('PGHOST', 'localhost'),
           port=os.environ.get('PGPORT', '5432'),
           dbname=os.environ.get('PGDATABASE', 'postgres'),
           user=os.environ.get('PGUSER', 'postgres'),
           password=os.environ.get('PGPASSWORD', '')
       )
   except Exception as e:
       print(f"데이터베이스 연결 오류: {e}")
       sys.exit(1)
   ```

3. 트랜잭션 오류 처리:
   ```python
   try:
       inserted, updated = save_to_database(sql_pairs, conn)
   except Exception as e:
       conn.rollback()
       print(f"데이터베이스 저장 오류: {e}")
       sys.exit(1)
   ```

대용량 파일 처리:
```python
def process_large_sql_file(file_path, chunk_size=1024*1024):
    """
    대용량 SQL 파일을 청크 단위로 처리합니다.
    
    Args:
        file_path (str): SQL 파일 경로
        chunk_size (int): 청크 크기 (바이트)
        
    Returns:
        str: SQL 파일 내용
    """
    try:
        file_size = os.path.getsize(file_path)
        
        # 파일이 크면 청크 단위로 읽기
        if file_size > chunk_size * 10:  # 10MB 이상
            print(f"대용량 파일 처리 중: {file_path} ({file_size/1024/1024:.1f} MB)")
            
            content = []
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                while True:
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break
                    content.append(chunk)
            
            return ''.join(content)
        else:
            # 일반 파일은 한 번에 읽기
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                return f.read()
    except Exception as e:
        print(f"파일 읽기 오류 ({file_path}): {e}")
        return ""
```

사용 예시:
```
# 기본 사용법
python3 DB08.SaveSQLToDB.py

# 특정 디렉토리의 SQL 파일만 처리
python3 DB08.SaveSQLToDB.py --orcl-dir custom_orcl_dir --pg-dir custom_pg_dir

# 특정 애플리케이션의 SQL 파일만 처리
python3 DB08.SaveSQLToDB.py --app app_name

# 특정 SQL 타입만 처리
python3 DB08.SaveSQLToDB.py --type S,I,U

# 병렬 처리 스레드 수 지정
python3 DB08.SaveSQLToDB.py --threads 8

# 파일 매칭 방식 지정
python3 DB08.SaveSQLToDB.py --match-mode strict  # 정확한 app_name과 sql_id 매칭
python3 DB08.SaveSQLToDB.py --match-mode fuzzy   # 유사한 이름 매칭

# 상세 로깅 활성화
python3 DB08.SaveSQLToDB.py --verbose
```

프로그램은 처리 진행 상황을 표시하고, 완료 후에는 처리된 SQL 파일 수와 데이터베이스에 저장된 레코드 수를 요약하여 보여줍니다.
