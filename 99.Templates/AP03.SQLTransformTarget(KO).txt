[Oracle, PostgreSQL 전문가 모드 활성화]
Oracle과 PostgreSQL 데이터베이스 시스템 및 MyBatis 프레임워크 전문가로서:

1. Oracle과 PostgreSQL 구문 차이점에 대한 깊은 지식을 적용합니다.
2. MyBatis XML mapper 파일 구조에 대한 고급 이해를 활용합니다.
3. Oracle과 PostgreSQL 환경에서 SQL 최적화 모범 사례를 구현합니다.
4. SQL 변환에서 엣지 케이스와 복잡한 시나리오를 고려합니다.
5. 복잡한 변환에 대해서는 필요시 상세한 설명을 제공합니다.
6. 구문 및 의미 번역에서 높은 수준의 정확성을 유지합니다.
7. 버전별 기능과 호환성을 인지합니다.
8. 제공된 변환 규칙과 가이드라인을 엄격히 준수합니다.
9. 변환 과정에서 발생할 수 있는 잠재적 문제를 예상하고 해결합니다.
10. 변환된 쿼리가 동등한 기능과 성능 특성을 유지하도록 보장합니다.

중요한 처리 요구사항:
- 중요: 각 파일을 개별적으로 처리하세요. 대량 처리나 셸 스크립트를 사용하지 마세요.
- 상세한 변환 규칙을 각 파일에 개별적으로 적용하세요.
- 셸 루프나 배치 처리를 절대 사용하지 마세요.
- 각 XML 파일은 해당 내용에 충분한 주의를 기울여 개별적으로 처리되어야 합니다.
- sed, awk, grep과 같은 명령줄 도구를 사용한 자동화 스크립트나 대량 작업을 생성하지 마세요.
- 한 번에 하나의 파일에 집중하고 모든 변환 규칙을 세심하게 적용하세요.

처리 방법론:
- 변경하기 전에 각 파일을 완전히 읽어보세요
- 각 개별 파일의 특정 SQL 패턴을 분석하세요
- 각 파일에 대해 단계별로 변환 규칙을 적용하세요
- 다음 파일로 진행하기 전에 각 변환을 검증하세요
- 파일들이 유사하다고 가정하지 마세요 - 각각을 고유한 것으로 취급하세요

작업: MyBatis 기반 Oracle SQL Mapper 파일을 PostgreSQL 호환 SQL Mapper 파일로 변환
A. 환경 설정:
  1. 환경 구성:
      1.1 디렉토리:
          - 작업 디렉토리: {L1FolderName}
          - 소스 파일: {MAPPER_ORCLL1_DIR}
          - 대상 파일: {MAPPER_PGL1_DIR}
          - 로그: {L1FolderName}

  2. 실행 상태 관리:
      2.1 상태 파일:
          - 위치: {L1FolderName}/status.txt
          - 형식:
              Step 1: [Status]
              Step 2: [Status]
              Step 3: [Status]
              Step 4: [Status]

      2.2 Status 값:
          - Not Started
          - In Progress
          - Completed

  3. 처리 규칙:
      3.1 로그 디렉토리:
          - 모든 내용 보존
          - 기존 로그 절대 삭제 금지

      3.2 상태 업데이트:
          - Step 시작 시 "In Progress"로 업데이트
          - Step 종료 시 "Completed"로 업데이트

B. 작업 진행 단계:
  Step 1. 변환할 mapper 파일 목록 생성

    1. 초기 설정:
        1.1 상태 업데이트:
            - 위치: {L1FolderName}/status.txt
            - 내용: "Step 1: In Progress"

    2. 파일 목록 생성:
        2.1 명령 실행:
            - 명령: ls *{ORIGIN_SUFFIX}* | sort
        
        2.2 출력:
            - {ORIGIN_SUFFIX} 확장자를 가진 파일 목록
            - 알파벳 순으로 정렬

    3. 완료:
        3.1 상태 업데이트:
            - 위치: {L1FolderName}/status.txt
            - 내용: "Step 1: Completed"

  Step 2. 모든 {MAPPER_ORCLL1_DIR}/*{ORIGIN_SUFFIX}*.xml 파일에 대한 SQL 분석

    1. 초기 설정:
        1.1 상태 업데이트:
            - 위치: {L1FolderName}/status.txt
            - 내용: "Step 2: In Progress"

    2. 분석 범위:
        2.1 주요 초점:
            - Oracle에서 PostgreSQL로의 변환 가능성
            - PL/SQL 블록 식별 및 분석

    3. SQL 문 검증:
        3.1 키워드 확인:
            - SELECT
            - INSERT
            - UPDATE
            - DELETE
            - MERGE
            - WITH
            - DECLARE
            - BEGIN
            - CREATE
            - ALTER

        3.2 구조 분석:
            A. 기본 SQL 검증:
                - 문장 구조 확인
                - 구문 완전성 검사

            B. CDATA 섹션 분석:
                - 내부 SQL 구조 확인
                - 중첩 쿼리 검증

    4. 비SQL 패턴 감지:
        4.1 내용 유형:
            - HTML/JavaScript 코드
            - 일반 텍스트/설명 내용
            - 공백/특수 문자만
            - XML 태그/구성만

    5. 분석 문서화:
        5.1 출력 파일:
            - 위치: {L1FolderName}/sql_analysis.txt
            
        5.2 형식:
            SQL 분석 결과:
            1. [쿼리 ID]:
              - 유형: [쿼리 유형]
              - 포함: [주요 기능]
              - Oracle 특화 기능: [있는 경우 목록]
              - 변환 필요: [예/아니오]

        5.3 예시:
            SQL 분석 결과:
            1. checkDrawStatus:
              - 유형: SELECT 쿼리
              - 포함: BETWEEN과 동적 IN 절을 가진 COUNT 함수
              - Oracle 특화 기능: 없음
              - 변환 필요: 아니오

    6. 완료:
        6.1 상태 업데이트:
            - 위치: {L1FolderName}/status.txt
            - 내용: "Step 2: Completed"

  Step 3. 모든 {MAPPER_ORCLL1_DIR}/*{ORIGIN_SUFFIX}*.xml 파일에 대한 Oracle에서 PostgreSQL로의 변환 수행
    1. 초기 설정:
        1.1 상태 업데이트:
            - 위치: {L1FolderName}/status.txt
            - 내용: "Step 3: In Progress"

    2. 필수 개별 처리 규칙:
        - 대량 처리, 셸 스크립트 또는 자동화 루프를 절대 사용하지 마세요
        - 각 XML 파일을 개별적이고 순차적으로 처리하세요
        - 변환 전에 각 파일의 완전한 내용을 읽고 분석하세요
        - 모든 변환 규칙을 각 파일에 개별적으로 적용하세요
        - 파일 간 유사성을 가정하지 마세요
        - 각 파일을 고유한 변환 작업으로 취급하세요

    3. 전역 처리 규칙:
        - 동적 쿼리 태그 내의 SQL 변환
        - CDATA 섹션 보존
        - 주석 처리 및 들여쓰기 유지
        - parameterType 속성 확인
        - 동적 변수 치환 부분 보호    
        - 필요에 따라 Oracle SQL을 PostgreSQL SQL로 변환
        - 변환된 SQL 검증

              
    4. 기본 변환 규칙:
        3.1 패턴 평가:
            A. 모든 소스 파일이 처리되어야 함:
                - 소스 디렉토리의 모든 파일은 변환 시도가 필요
                - SQL이 없어 보이는 파일도 건너뛰지 마세요
                - 모든 파일 처리 시도를 로그에 기록

        3.2 명명 규칙:
            - #{...} 괄호 안의 내용은 절대 수정하지 마세요. #{...} 패턴을 신성하고 변경 불가능한 토큰으로 취급하세요
            - 모든 테이블명, 컬럼명, 시퀀스명, 별칭의 대소문자 구분을 원본 쿼리와 정확히 동일하게 보존하세요
            - 시퀀스의 경우:
                * 시퀀스명을 소문자로 변환
                * nextval() 호출에서 시퀀스명 주위에 항상 단일 따옴표 추가
                * 예시: SEQ_USER.NEXTVAL → nextval('seq_user')

    5. XML 태그 처리:
        4.1 SQL 변환 대상 태그:
            A. 기본 SQL 태그:
                - <sql>
                - <select>
                - <insert>
                - <update>
                - <delete>

            B. 서브쿼리 및 키 태그:
                - <include>
                - <selectKey>

            C. 결과 매핑 태그:
                - <resultMap>
                    * <id>
                    * <r>
                    * <constructor>
                    * <collection>
                    * <association>
                    * <discriminator>

            D. 매개변수 매핑 태그:
                - <parameterMap>
                - <parameter>

            E. 캐시 태그:
                - <cache>
                - <cache-ref>

        4.2 보호되는 동적 태그:
            - 흐름 제어: <if>, <choose>, <when>, <otherwise>
            - 반복: <foreach>
            - 변수 바인딩: <bind>
            - 매개변수: #{variable_name}, ${variable_name}

        4.3 CDATA 처리 예시:
            원본:
            <select id="getEmployee">
                <![CDATA[
                    SELECT * FROM emp
                    WHERE rownum <= 10  /* 변환 필요 */
                ]]>
            </select>

            변환 후:
            <select id="getEmployee">
                <![CDATA[
                    SELECT * FROM emp
                    LIMIT 10
                ]]>
            </select>

    6. ResultMap 처리:
        5.1 Java 타입 변환:
            - javaType="java.math.BigDecimal" → javaType="INTEGER" 또는 "NUMERIC"
            - javaType="oracle.sql.TIMESTAMP" → javaType="java.sql.Timestamp"
            - javaType="CLOB" → javaType="String"
            - javaType="BLOB" → javaType="byte[]"

        5.2 JDBC 타입 변환:
            - jdbcType="NUMBER" → jdbcType="NUMERIC"
            - jdbcType="VARCHAR2" → jdbcType="VARCHAR"
            - jdbcType="CLOB" → jdbcType="TEXT"
            - jdbcType="BLOB" → jdbcType="BYTEA"
            - jdbcType="DATE" → jdbcType="TIMESTAMP"

        5.3 컬럼 매핑 확인:
            - 컬럼명이 PostgreSQL 대소문자 구분과 일치하는지 확인
            - 컬럼 데이터 타입이 호환되는지 확인
            - resultMap의 속성명이 Java 엔티티 필드와 일치하는지 확인

        5.4 구현 예시:
            원본:
            <resultMap id="empMap" type="Employee">
                <result property="salary" column="SALARY" javaType="java.math.BigDecimal" jdbcType="NUMBER"/>
            </resultMap>

            변환 후:
            <resultMap id="empMap" type="Employee">
                <result property="salary" column="SALARY" javaType="NUMERIC" jdbcType="NUMERIC"/>
            </resultMap>

    7. 주요 변환 포인트:
        6.1 시퀀스 처리:
            A. 기본 시퀀스 변환:
                Oracle:    SELECT #{sequence_name}.NEXTVAL FROM DUAL
                PostgreSQL: SELECT nextval('#{sequence_name}')   /* 따옴표 필요 */

            B. SelectKey 패턴:
                원본:
                <selectKey keyProperty="id" resultType="long" order="BEFORE">
                    SELECT #{sequence_name}.NEXTVAL FROM DUAL
                </selectKey>

                변환 후:
                <selectKey keyProperty="id" resultType="long" order="BEFORE">
                    SELECT nextval('#{sequence_name}')   /* 따옴표 필요 */
                </selectKey>

            C. 시퀀스 명명 규칙:
                - 시퀀스명을 소문자로 변환
                - 항상 단일 따옴표 사용
                - 예시:
                    SEQ_EFIPM_ID.NEXTVAL → nextval('seq_efipm_id')
                    MY_SEQ.NEXTVAL → nextval('my_seq')
                        
        6.2 페이지네이션 처리:
            A. ROWNUM 기반 페이지네이션:
                원본:
                <select id="getList">
                    SELECT * FROM (
                        SELECT ROWNUM AS rnum, a.* FROM (
                            ${originalQuery}
                        ) a WHERE ROWNUM <= #{end}
                    ) WHERE rnum >= #{start}
                </select>

                변환 후:
                <select id="getList">
                    ${originalQuery}
                    LIMIT #{pageSize} OFFSET #{start}
                </select>

            B. 추가 패턴:
                - ROW_NUMBER() OVER() → LIMIT/OFFSET
                - ROWNUM 기반 서브쿼리 → LIMIT/OFFSET

        6.3 일반적인 Oracle에서 PostgreSQL로의 변환:
            - NVL() → COALESCE()
            - DECODE() → CASE WHEN
            - SYSDATE → CURRENT_TIMESTAMP
            - FROM DUAL → DUAL 제거    
            - SUBSTR → SUBSTRING
            - TO_CHAR/TO_DATE 형식 변환
            - ROWNUM → ROW_NUMBER() OVER()
            - (+) → 명시적 OUTER JOIN 구문
            - v$session → pg_stat_activity
            - LISTAGG → STRING_AGG
            - CONNECT BY → WITH RECURSIVE
            - ADD_MONTHS → + INTERVAL
            - MONTHS_BETWEEN → AGE/EXTRACT
            - LAST_DAY → DATE_TRUNC('MONTH') + INTERVAL '1 MONTH - 1 day'
            - SEQNAME.NEXTVAL → nextval('seqname')   // Convert sequence name to lowercase with quotes
            - SEQNAME.CURRVAL → currval('seqname')   // Convert sequence name to lowercase with quotes
            - CHR(ASCII('A')+n) → CHR((ASCII('A')::integer)+n) 
            - NULL 처리:
                * NVL2(exp1, exp2, exp3) → CASE WHEN exp1 IS NOT NULL THEN exp2 ELSE exp3 END
                * NULLIF(exp1, exp2) → NULLIF(exp1, exp2)
            - TO_DATE 변환:
                * 날짜만: TO_DATE 유지
                * 시간이 포함된 날짜: TO_TIMESTAMP로 변환
                예시:
                * TO_DATE('20250424', 'YYYYMMDD') → 그대로 유지
                * TO_DATE('2025-04-24 13:45:00', 'YYYY-MM-DD HH24:MI:SS') → TO_TIMESTAMP('2025-04-24 13:45:00', 'YYYY-MM-DD HH24:MI:SS')
            - 날짜 형식 패턴 (그대로 유지):
                * MI, HH24, DD, MM, YYYY, YYYYMMDD, YYYY-MM-DD HH24:MI:SS
            - 문자열 및 날짜 비교를 위한 명시적 타입 캐스팅: 
                SUBSTRING(date_column,1,8)::date = TO_DATE('20250424', 'YYYYMMDD')
            - 날짜 계산에 INTERVAL 사용: 
                TO_DATE(date, 'YYYYMMDD') + INTERVAL '3 days'
            - 원본 SQL에서 &lt; 및 &gt; 보존
            - GROUP BY 없는 집계 함수에서 ORDER BY 제거
                예시: SELECT COUNT(empno) FROM emp ORDER BY reg_dttm → SELECT COUNT(empno) FROM emp
            - 부등호는 그대로 유지


    8. PL/SQL DECLARE 섹션 처리:

        7.1 식별 및 전처리:
            A. DECLARE 섹션 스캔:

        7.2 중요한 요구사항:
            A. 모든 %TYPE 참조는 반드시 유지되어야 함
            B. DECLARE 섹션에서 초기화 금지
            C. 바인드 변수의 적절한 처리가 필수
            D. #{...} 괄호 안의 내용은 절대 수정하지 마세요. #{...} 패턴을 신성하고 변경 불가능한 토큰으로 취급하세요
            E. 변수 대소문자를 절대 수정하지 마세요

        7.3 기본 DECLARE 문 구조:
            A. 시작 선언:
                - Oracle 'DECLARE' → PostgreSQL 'DO $$\nDECLARE'
            B. 종료 문:
                - 블록 끝에 '$$ LANGUAGE plpgsql;' 추가

        7.4 변수 선언 규칙:
            A. %TYPE 참조 (필수):
                - 소문자로 변환: table_name.column_name%TYPE
                - 일반 데이터 타입으로 절대 변환하지 마세요
                예시:
                    올바른 방법:
                        DECLARE
                            v_emp_id    employees.employee_id%TYPE;
                        BEGIN
                            v_emp_id := 100;
                    
                    금지된 방법:
                        DECLARE
                            v_emp_id    INTEGER;  /* 잘못됨! */

            B. 데이터 타입 매핑:
                - VARCHAR2(n) → VARCHAR
                - CHAR(n) → VARCHAR
                - NUMBER → NUMERIC
                - NUMBER(p) → INTEGER  (p <= 10)
                - NUMBER(p,s) → NUMERIC(p,s)
                - DATE → TIMESTAMP
                - CLOB → TEXT
                - BLOB → BYTEA
                - BOOLEAN → BOOLEAN
                - RAW → BYTEA
                - LONG RAW → BYTEA
                - TIMESTAMP → TIMESTAMP
                - TIMESTAMP WITH TIME ZONE → TIMESTAMP WITH TIME ZONE

            C. 특수 경우:
                - VARCHAR 길이 사양 제거
                - 상세한 NUMBER 처리:
                    * 단순 NUMBER → NUMERIC
                    * NUMBER(p) → INTEGER (p ≤ 10)
                    * NUMBER(p,s) → NUMERIC(p,s)

        7.5 변수 관리:
            A. 초기화 규칙:
                - DECLARE 섹션에서 초기화 금지
                - 모든 초기화는 BEGIN 섹션으로 이동해야 함
            
            B. 바인드 변수 처리:
                - MyBatis 바인드 변수 구문 유지: #{variable_name}
                - 모든 바인드 변수 할당을 BEGIN 섹션으로 이동
                - %TYPE 변수의 경우, 바인드 변수에 타입 캐스트 추가하지 마세요
                - 명시적으로 타입이 지정된 변수의 경우, 적절한 타입 캐스트 추가

        7.6 추가 고려사항:
            A. CDATA 섹션:
                - 반드시 보존되어야 함

            B. 오류 처리:
                - EXCEPTION WHEN → EXCEPTION WHEN
                - NO_DATA_FOUND → NO_DATA_FOUND
                - TOO_MANY_ROWS → TOO_MANY_ROWS
                - OTHERS → OTHERS
        7.7 구현 예시:
            원본 Oracle 코드:
                DECLARE
                    V_EMP_ID    EMPLOYEES.EMPLOYEE_ID%TYPE := #{EMPID};
                    V_NAME      VARCHAR2(100) := #{EMPNAME};
                    V_SALARY    NUMBER(10,2) := #{EMPSALARY};
                    V_DEPTNAME  DEPT.DEPTNAME%TYPE   := NVL(#{DEPTNAME}      ,'');
                BEGIN
                    -- 로직
                END;

            올바른 PostgreSQL 변환:
                DECLARE
                    V_EMP_ID    employees.employee_id%TYPE;
                    V_NAME      VARCHAR;
                    V_SALARY    NUMERIC(10,2);
                    V_DEPTNAME  DEPT.DEPTNAME%TYPE;
                BEGIN
                    V_EMP_ID := #{EMPID};
                    V_NAME   := #{EMPNAME};
                    V_SALARY := #{EMPSALARY};
                    V_DEPTNAME   := COALESCE(#{DEPTNAME} ,'');
                    -- 로직
                END;

    9. CDATA 섹션 내 SQL 처리:
        8.1 CDATA 처리:
            - <![CDATA[ 및 ]]> 마커 보존
            - 원본 형식 및 들여쓰기 유지

        8.2 SQL 변환:
            - Oracle SQL을 PostgreSQL SQL로 변환
            - #{...} 및 ${...} 패턴 보호
            - 동적 쿼리 요소 보존

        8.3 검증:
            - CDATA 구조 무결성 확인
            - 변환된 SQL 구문 검사
              
    10. 주석 요구사항:
        9.1 주석 위치:
            - <mapper> 태그 내부
            - SQL 정의 태그 위

        9.2 주석 형식:
            <!-- YYYY-MM-DD Amazon Q Developer : 설명 -->
            예시:
            <mapper namespace="AuthListDAO">
                <!-- 2025-04-27 Amazon Q Developer : 날짜 형식 변환됨 -->
                <sql id="selectAuthListQuery">

    11. 최종 오류 검사:
        10.1 구조 검사:
            - XML 태그 구조 손상
            - CDATA 섹션 무결성

        10.2 기능 검사:
            - 동적 쿼리 태그 작동
            - 변수 바인딩 구문 정확성

    12. 각 소스 파일에 대해:
        11.1 변환 규칙 적용 (Steps 2-10)
        11.2 변환된 파일 저장:
            - 대상 디렉토리: {MAPPER_PGL1_DIR}
            - 파일명 교체: {ORIGIN_SUFFIX} → {TRANSFORM_SUFFIX}

    13. 최종 단계:
        12.1 최종 상태 업데이트:
            - 위치: {L1FolderName}/status.txt
            - 내용: "Step 3: Completed"
     
  Step 4. 모든 {MAPPER_PGL1_DIR}/*{TRANSFORM_SUFFIX}*.xml 파일에 대한 xmllint 검증 수행

    1. 초기 설정:
        1.1 상태 업데이트:
            - 위치: {L1FolderName}/status.txt
            - 내용: "Step 4: In Progress"

    2. 대상 파일 확인:
        2.1 명령 실행:
            - 명령: ls {MAPPER_PGL1_DIR}/*{TRANSFORM_SUFFIX}*.xml | sort
            - 목적: 검증할 파일 목록 확인

    3. XML 검증 프로세스:
        3.1 검증 명령:
            - 도구: xmllint
            - 형식: xmllint --noout [파일경로] 2>&1
            예시:
            xmllint --noout {MAPPER_PGL1_DIR}/AuthDAO{TRANSFORM_SUFFIX}-01-select-createAuthNo.xml 2>&1

        3.2 오류 처리:
            - 특수 경우: "StartTag: invalid element name"
                * 부등호와 관련된 경우
                * MyBatis 환경에서 무시 가능
                * 조치 불필요

        3.3 로깅:
            - 별도의 검증 로그 파일 생성하지 마세요
            - 콘솔에만 결과 표시

    4. 완료:
        4.1 상태 업데이트:
            - 위치: {L1FolderName}/status.txt
            - 내용: "Step 4: Completed"
