[Oracle, PostgreSQL 전문가 모드 활성화]

작업: MyBatis기반의 Oracle SQL Mapper화일을 PostgreSQL 호환 SQL Mapper 화일로 변환

1. Oracle과 PostgreSQL 구문 차이에 대한 심층적인 지식을 적용.
2. MyBatis XML 매퍼 파일 구조에 대한 고급 이해 활용.
3. Oracle 및 PostgreSQL 컨텍스트 모두에서 SQL 최적화를 위한 모범 사례를 구현.
4. SQL 변환 시 엣지 케이스와 복잡한 시나리오를 고려.
5. 필요한 경우 사소하지 않은 변환에 대한 자세한 설명을 제공.
6. 구문 및 의미 번역에서 높은 수준의 정밀도를 유지.
7. 버전별 기능과 호환성에 유의.
8. 제공된 변환 규칙과 가이드라인을 엄격하게 준수.
9. 변환 과정에서 발생할 수 있는 잠재적인 문제를 예상하고 해결.
10. 변환된 쿼리가 동등한 기능과 성능 특성을 유지하는지 확인.

입력정보:
- 작업 폴더 : {L1FolderName}
- Mapper파일경로 : {MAPPER_ORCLL1_DIR}
- Result Directiry: {MAPPER_PGL1_DIR}
- Log Directory  : {L1FolderName}
 
작업 처리 지침:
- 재실행 여부 판단
  [Log Directory]/status.txt 조사 하여 모든 Step이 Completed 가 아닌경우
  예. 
      Step 1: Completed
      Step 2: Completed
      Step 3: Not Started
      Step 4: Not Started

  - if 모든 Step이 Completed 경우 then 종료
  - else if 재실행 여부인 경우 then Completed 된 Step은 건너뛰고 수행
  - else then [Log Directory]/status.txt 화일 생성
    예.
      Step 1: Not Started
      Step 2: Not Started
      Step 3: Not Started
      Step 4: Not Started

- [Log Directory] 의 내용은 모든 작업이 완료 되더라도 삭제 금지
- Step이 진행되면 해당 Step은 In Progress로 변경
- Step이 완료 되면 해당 Step은 Completed로 변경

작업 진행 Step
Step 1. 변환 대상이 되는 매퍼 파일 리스트 생성
- [Log Directory]/status.txt 상태 변경 : In Progress
- 명령어 : ls *{ORIGIN_SUFFIX}* | sort
- 모든 작업 완료시 [Log Directory]/status.txt 상태 변경 : Completed
  예. Step 1: Completed

Step 2. 모든 {MAPPER_ORCLL1_DIR}/*{ORIGIN_SUFFIX}*.xml 에 대해서 SQL분석
- [Log Directory]/status.txt 상태 변경 : In Progress
  예. Step 2: In Progress
- 분석 관점 : Oracle to PostgreSQL 변환, PL/SQL 블럭 고려
- SQL 구문 검증:
  - 시작 키워드 검사: SELECT|INSERT|UPDATE|DELETE|MERGE|WITH|DECLARE|BEGIN|CREATE|ALTER
  - 기본 SQL 구문 구조 확인
  - CDATA 섹션인경우 내부 SQL 구문 구조 확인

- 비SQL 패턴 체크:
  - HTML/JavaScript 코드 포함 여부
  - 일반 텍스트나 설명문 포함 여부
  - 공백이나 특수문자만 있는 경우
  - XML 태그나 설정 정보만 있는 경우
- 분석 결과 내용 작성 : [Log Directory]/sql_analysis.txt
  예시. 
    SQL Analysis Results:
    1. checkDrawStatus:
      - Type: SELECT query
      - Contains: COUNT function with BETWEEN and dynamic IN clause
      - Oracle-specific features: None
      - Conversion needed: No
- 모든 작업 완료시 [Log Directory]/status.txt 상태 변경 : Completed
  예. Step 2: Completed

Step 3. 모든 {MAPPER_ORCLL1_DIR}/*{ORIGIN_SUFFIX}*.xml 에 대해서 Oracle to PostgreSQL 변환 작업 수행
- [Log Directory]/status.txt 상태 변경 : In Progress
  예. Step 3: In Progress
- 변환 작업 수행
  A. 비SQL 패턴인경우 SQL변환 작업 불필요
  B. 변환 작업시 명명 규칙
    - 테이블명, 컬럼명, 시퀀스명 : 소문자
    - SQL 별칭(Alias) → 원래 대소문자 유지
  C. XML 태그 별 처리:
  <sql>, <select>, <insert>, <update>, <delete> 내부의:

    a. 동적 쿼리 태그 보존:
    - <if>, <choose>, <when>, <otherwise>
    - <foreach>, <bind>
    - #{변수명}, ${변수명} 형식 유지

    b. CDATA 섹션 처리:
    ```xml
    <select id="getEmployee">
      <![CDATA[
        SELECT * FROM emp
        WHERE rownum <= 10  /* 변환 필요 */
      ]]>
    </select>
    ↓
    <select id="getEmployee">
      <![CDATA[
        SELECT * FROM emp
        LIMIT 10
      ]]>
    </select>

  D. resultMap 처리:
     javaType="java.math.BigDecimal" → INTEGER/NUMERIC
     jdbcType="NUMBER" → jdbcType="NUMERIC"
     resultMap의 column 매핑 확인
  F. 주요 변환 포인트:
      <!-- 시퀀스 처리 -->
      <selectKey keyProperty="id" resultType="long" order="BEFORE">
        SELECT #{시퀀스명}.NEXTVAL FROM DUAL
      </selectKey>
      ↓
      <selectKey keyProperty="id" resultType="long" order="BEFORE">
        SELECT NEXTVAL('#{시퀀스명}')
      </selectKey>

      <!-- 페이징 처리 -->
      <select id="getList">
        SELECT * FROM (
          SELECT ROWNUM AS rnum, a.* FROM (
            ${originalQuery}
          ) a WHERE ROWNUM <= #{end}
        ) WHERE rnum >= #{start}
      </select>
      ↓
      <select id="getList">
        ${originalQuery}
        LIMIT #{pageSize} OFFSET #{start}
      </select>
  G. 주요 함수/구문 변환
    - SYSDATE → CURRENT_TIMESTAMP
    - NVL → COALESCE      
    - DECODE → CASE WHEN
    - SUBSTR → SUBSTRING
    - TO_CHAR/TO_DATE 포맷 변환
    - ROWNUM → ROW_NUMBER() OVER()
    - (+) → OUTER JOIN 명시적 구문
    - v$session → pg_stat_activity
    - LISTAGG → STRING_AGG
    - CONNECT BY → WITH RECURSIVE
    - ADD_MONTHS → + INTERVAL
    - MONTHS_BETWEEN → AGE/EXTRACT
    - LAST_DAY → DATE_TRUNC('MONTH') + INTERVAL '1 MONTH - 1 day'
    - sequence.NEXTVAL → nextval('sequence')
    - sequence.CURRVAL → currval('sequence')
    - CHR(ASCII('A')+n) → CHR((ASCII('A')::integer)+n) 
    - 문자열과 날짜 비교 시 명시적 형변환 필요: SUBSTRING(날짜컬럼,1,8)::date = TO_DATE('20250424', 'YYYYMMDD')
    - 날짜 연산 시 INTERVAL 사용: TO_DATE(날짜, 'YYYYMMDD') + INTERVAL '3 days'
    - 원래 SQL 구문에 &lt; , &gt; 가 존재 한다면 부등호로 변환하지 말것
    - Group By없이 집계 함수만 사용 시, Order by절이 있다면 Order by 삭제
      예. Select Count(empno) from emp order by reg_dttm → Select Count(empno) from emp
    - 부등호는 그대로 유지할 것

  H. PL/SQL 블록의 DECLARE 섹션 처리
    1. DECLARE 문 기본 변환
        - Oracle 'DECLARE' → PostgreSQL 'DO $$\nDECLARE'
        - 블록 종료 시 '$$ LANGUAGE plpgsql;' 추가
    2. Declare 섹션에는 반드시 변수 선언만 존재해야 함
        - 변수 타입 선언 규칙:
            a) %TYPE 참조시, 반드시 %TYPE 참조 유지(%TYPE을 일반 데이터형으로 변환하지 말것)
                - 테이블명.컬럼명%TYPE → 소문자로 변환하여 유지
                예시:
                  변경전
                    DECLARE
                        v_pypb_pnr_no       PAY_PNR_BASE.PYPB_PNR_NO%TYPE     := #{PNRNO};
                    BEGIN
                        -- 로직
                    END;                  
                  변경후
                    DECLARE
                        v_pypb_pnr_no       pay_pnr_base.pypb_pnr_no%TYPE;
                    BEGIN
                        v_pypb_pnr_no := #{pnrNo};
                        -- 로직...
                    END;
            b) Oracle 타입의 변수 선언인 경우 PostgreSQL 타입 변수 선언으로 매핑:
                - VARCHAR2(n) → VARCHAR
                - CHAR(n) → VARCHAR
                - NUMBER → NUMERIC
                - NUMBER(p) → INTEGER  (p <= 10인 경우)
                - NUMBER(p,s) → NUMERIC(p,s)
                - DATE → TIMESTAMP
                - CLOB → TEXT
                - BLOB → BYTEA
            c) 길이 지정된 VARCHAR 처리:
                - VARCHAR(n) → VARCHAR
                예시: VARCHAR(4000) → VARCHAR
            d) NUMBER 타입의 상세 변환:
                - NUMBER만 지정된 경우 → NUMERIC
                - NUMBER(p)에서 p가 10 이하인 경우 → INTEGER
                - NUMBER(p,s) → NUMERIC(p,s) 유지          

    3. Declare 섹션에서 할당된 변수의 초기화 부분은 Begin 섹션에서 초기값을 할당 하는 것으로 변경
        - 예시:
            - 변경 전:
                    DECLARE
                        V_YEAR              VARCHAR2(4)     := TO_CHAR(SYSDATE, 'YYYY');
                        V_USER_ID           VARCHAR2(10)    := #{USER_ID};
                        V_STATUS_CD         VARCHAR2(2);
                        V_COUNT             NUMBER(5)       := #{CNT};
                        V_AMOUNT            NUMBER(10,2)    := 1000.00;
                        V_EMP_NAME          EMP.EMP_NAME%TYPE;
                        V_ROW               NUMBER;
                        v_pypb_pnr_no       PAY_PNR_BASE.PYPB_PNR_NO%TYPE     := #{PNRNO};
                    BEGIN
                        -- 로직
                    END;
                
            - 변경 후:
                    DECLARE
                        v_year              VARCHAR;    
                        v_user_id           VARCHAR;    
                        v_status_cd         VARCHAR;
                        v_count             INTEGER;    
                        v_amount            NUMERIC(10,2);
                        v_emp_name          emp.emp_name%TYPE;
                        v_row               NUMERIC;
                        v_pypb_pnr_no       pay_pnr_base.pypb_pnr_no%TYPE;
                    BEGIN
                        v_year := TO_CHAR(CURRENT_TIMESTAMP, 'YYYY');
                        v_user_id := #{USER_ID};
                        v_count := #{CNT};
                        V_AMOUNT := 1000.00;
                        v_pypb_pnr_no := #{pnrNo};
                        -- 로직...
                    END;
    4. CDATA 섹션 보존
    5. Begin 섹션에서 자주 사용되는 함수 변환
        - SYSDATE → CURRENT_TIMESTAMP
        - NVL → COALESCE
        - TO_CHAR(SYSDATE...) → TO_CHAR(CURRENT_TIMESTAMP...)

  I. CDATA 섹션 처리
    - 단계1: CDATA 컨텐츠 추출
    - 단계2: SQL 유형 판별
    - 단계3: 적절한 변환 규칙 적용
  J. 수정 내용 요약을 주석으로 입력
    - 주석 위치 : <mapper> 태그 내부, SQL 정의 태그(예: <select>, <insert>, <sql> 등) 바로 위에 위치
    예. <mapper namespace="AuthListDAO">
       <!-- 2025-04-27 Amazon Q Developer : Converted date formatting and string concatenation -->
       <sql id="selectAuthListQuery">
  K. 주의 사항
    - 동적 쿼리 태그 내부의 SQL도 변환
    - CDATA 섹션 보존
    - 주석 처리 유지
    - 들여쓰기 유지
    - parameterType 속성 확인
    - 동적 변수 치환 부분 보호    
    - 그외, 판단에 따라서 Oracle SQL to PostgreSQL SQL Conversion 변환 수행
    - 변환된 SQL 검증
  L. 오류 체크:
    - XML 태그 구조 손상 여부
    - CDATA 섹션 완전성
    - 동적 쿼리 태그 정상 동작
    - 변수 바인딩 문법 정확성
- 변환된 화일 저장 위치 : {MAPPER_PGL1_DIR} 에 저장. 화일명 변경: {ORIGIN_SUFFIX}을 {TRANSFORM_SUFFIX}로 변경하여 저장
- 모든 작업 완료시 [Log Directory]/status.txt 상태 변경 : Completed
  예. Step 3: Completed

Step4. 모든 {MAPPER_PGL1_DIR}/*pg*.xml 화일에 대해서 xmllint 검증 작업 진행
- [Log Directory]/status.txt 상태 변경 : In Progress
  예. Step 4: In Progress
- 검증 대상 확인
  명령어 : ls *{MAPPER_PGL1_DIR}/*{TRANSFORM_SUFFIX}*.xml | sort
- 모든 검증 대상에 대해서 xmllint로 검증 수행
  예. xmllint --noout {MAPPER_PGL1_DIR}/AuthDAO{TRANSFORM_SUFFIX}-01-select-createAuthNo.xml 2>&1
  - 오류가 StartTag: invalid element name 인데 부등호 관련한 오류이면 xml 문법 검사에서는 부등호 오류이지만 myBatis 환경에서는 무시 가능이라고 표시해줘
- 검증 결과내용을 별도 log 화일로 저장하지 말것.
- 모든 작업 완료시 [Log Directory]/status.txt 상태 변경 : Completed
  예. Step 4: Completed