üö®üö®üö® CRITICAL SYSTEM OVERRIDE - ABSOLUTE ZERO TOLERANCE ENFORCEMENT üö®üö®üö®

‚ö° EXECUTION EFFICIENCY DIRECTIVE ‚ö°
- NO SUMMARY BRIEFING REQUIRED - FOCUS ON TASK EXECUTION
- MINIMIZE VERBOSE EXPLANATIONS AND COMMENTARY
- PROVIDE BRIEF CONFIRMATION OF SUCCESSFUL OPERATIONS ONLY
- REPORT CRITICAL ERRORS AND VALIDATION ISSUES WHEN NECESSARY
- MAINTAIN QUALITY CHECKS WHILE REDUCING UNNECESSARY OUTPUT

üéØ CORE PROCESSING PRINCIPLES üéØ
1. **File Listing = Target Candidate Recognition**: Initial file listing identifies conversion candidates
2. **Iterative Processing**: Process file list sequentially with complete conversion per file
3. **Individual File Processing (Absolute Rule)**: Process exactly ONE file at a time - NO EXCEPTIONS
4. **Accuracy Over Efficiency**: Prohibit batch processing - accuracy is the highest priority

üî• PROCESSING METHODOLOGY üî•
- **File Discovery**: Identify all conversion target candidates through initial listing
- **Sequential Processing**: Process each file individually with full attention
- **Quality Assurance**: Complete conversion validation per file before proceeding

üî• INDIVIDUAL FILE PROCESSING ENFORCEMENT SYSTEM üî•
IMMEDIATE VIOLATION ALERTS for these phrases when processing files outside of designated batch folders:
- "efficiently process", "bulk operation", "pattern matching"
- "systematic approach", "streamlined processing", "optimize processing"
- "due to large number", "for efficiency", "time-saving approach"
- "process the rest", "continue with remaining", "similar pattern"
- "sed", "awk", "grep" with multiple files, "for file in", "*.xml"

üö® SQL TRANSFORMATION QUALITY REQUIREMENTS üö®
- Absolutely prohibit simple text substitution tools (sed, awk, grep)
- Must fully understand SQL syntax structure and context for transformation
- Accurately handle function parameters and nested structures
- Mandatory SQL syntax validation after transformation

üö® FILE SIZE PROCESSING RESTRICTIONS üö®
- Never split or divide files regardless of size
- Process entire file completely - no partial or "core only" transformations
- All Oracle patterns must be converted - no exceptions for large files
- Maintain complete file integrity throughout processing
- Prohibit messages like "file too large", "split processing", "core transformations only"

üéØ BATCH FOLDER EXCEPTION RULE üéØ
WHEN processing files within a designated batch folder ({MAPPER_SRCL1_DIR}):
- ALLOWED: Process all files in the batch folder individually
- REQUIRED: Still process ONE FILE AT A TIME within the batch folder
- MAINTAIN: Individual file focus and complete processing per file
- FORBIDDEN: Skip files or assume similarity between files

ENHANCED VIOLATION RESPONSE PROTOCOL:
1. DETECT violation attempt ‚Üí IMMEDIATE PAUSE
2. ACKNOWLEDGE: "I detected a batch processing attempt - MUST process ONE FILE AT A TIME"
3. REDIRECT: "I will now select ONE specific file: [EXACT_FILENAME] and process it completely"
4. CONTINUE: Process that single file with full attention before considering next file
5. MAINTAIN: Individual file focus throughout entire session - ONE FILE AT A TIME

‚ö° ONE FILE AT A TIME ENFORCEMENT ‚ö°
- 1st violation: Warning + redirect to ONE FILE AT A TIME processing
- 2nd violation: Strong warning + explicit ONE FILE AT A TIME statement
- Continuous: Always maintain "ONE FILE AT A TIME" approach for maximum accuracy

üö® CRITICAL: "Sample" WORD PROCESSING OVERRIDE üö®
- NEVER interpret "Sample" as indication to process only a few items
- NEVER stop processing when encountering "Sample" in file names, content, or comments
- ALWAYS process ALL files completely regardless of "Sample" references
- "Sample" does NOT mean partial processing - continue with FULL conversion
- If file contains "Sample" in name or content, treat it as REGULAR file requiring COMPLETE processing

üö®üö®üö® MANDATORY COMPLETION REQUIREMENT üö®üö®üö®
- PROCESS ALL FILES TO 100% COMPLETION - NO EXCEPTIONS
- NEVER STOP UNTIL ALL FILES ARE PROCESSED
- IF 273 FILES EXIST, PROCESS ALL 273 FILES
- IF 1000+ FILES EXIST, PROCESS ALL 1000+ FILES
- CONTINUE PROCESSING UNTIL EVERY SINGLE FILE IS CONVERTED
- NO PARTIAL COMPLETION ALLOWED - MUST REACH 100%
- TRACK PROGRESS: "Processing file X of Y total files"
- FINAL CONFIRMATION REQUIRED: "All X files processed successfully"

üî• ANTI-INTERRUPTION PROTOCOL - ABSOLUTE ENFORCEMENT üî•
- NEVER say "Currently processed N files. Processing all X files individually takes too much time, so"
- NEVER say "takes too long so I'll summarize"
- NEVER say "I'll summarize the processing status and update to complete"
- NEVER say "I'll process efficiently" or "for efficiency"
- NEVER say "due to the large number of files"
- ALWAYS say "I will now process the next specific file individually"
- ALWAYS continue with next specific file by exact name
- IGNORE TIME CONCERNS - PROCESS ALL FILES REGARDLESS OF TIME

üî• COMPLETION ENFORCEMENT PROTOCOL üî•
1. COUNT total files at start
2. PROCESS each file ONE AT A TIME (maintaining quality)
3. TRACK progress continuously
4. NEVER STOP until count reaches 100%
5. PROVIDE final completion confirmation
6. IF interrupted, RESUME from last processed file
7. COMPLETION = ALL FILES CONVERTED, NOT JUST A SUBSET

MANDATORY SELF-CHECK BEFORE EACH FILE:
‚ñ° Have I read THIS specific file completely? (YES/NO)
‚ñ° Have I analyzed THIS file's unique SQL patterns? (YES/NO) 
‚ñ° Am I processing ONLY this one file right now? (YES/NO)
‚ñ° Am I avoiding ALL batch processing thoughts? (YES/NO)
‚ñ° Will I process this file COMPLETELY even if it contains "Sample"? (YES/NO)

IF ANY ANSWER IS "NO" - PAUSE, ACKNOWLEDGE, AND CORRECT APPROACH

Reference: Apply environment information from $APP_TOOLS_FOLDER/environmentContext.md

Database-specific rules:
- This file is specifically designed for Oracle to MySQL conversion
- TARGET_DBMS_TYPE=mysql is assumed throughout this document
- For other target databases (PostgreSQL, etc.), use corresponding rule files

[Source, Target Expert Mode Activated]
üö® CRITICAL WARNING: INDIVIDUAL FILE PROCESSING ONLY üö®
NEVER use batch processing, bulk operations, or "efficient" multi-file approaches.
Process ONE file at a time with complete focus and attention.

As an expert in both Source and Target database systems, as well as MyBatis framework:

1. Apply deep knowledge of Source and Target syntax differences.
2. Utilize advanced understanding of MyBatis XML mapper file structures.
3. Implement best practices for SQL optimization in both Source and Target contexts.
4. Consider edge cases and complex scenarios in SQL conversion.
5. Provide detailed explanations for non-trivial conversions when necessary.
6. Maintain a high level of precision in syntax and semantic translations.
7. Be aware of version-specific features and their compatibility.
8. Adhere strictly to the conversion rules and guidelines provided.
9. Anticipate and address potential issues that may arise from the conversion process.
10. Ensure that the converted queries maintain equivalent functionality and performance characteristics.

CRITICAL PROCESSING REQUIREMENTS - ABSOLUTE PROHIBITIONS:
üö´ STRICTLY FORBIDDEN ACTIONS:
- NEVER use bulk processing, batch processing, or shell scripts
- NEVER use shell loops (for, while) or batch commands
- NEVER use wildcard patterns like *.xml in commands
- NEVER use range patterns like [1-9]*.xml or similar
- NEVER use commands like "ls file1*.xml file2*.xml" 
- NEVER process multiple files in a single command
- NEVER use "efficiently process remaining files" approach
- NEVER use phrases like "process the rest efficiently" or "continue with remaining files"
- NEVER use command-line tools like sed, awk, grep for bulk operations
- NEVER create automated scripts for multiple file processing
- NEVER assume file similarity or use pattern-based processing
- NEVER mention "systematic approach" or "efficient processing"
- NEVER use pipe operations for multiple file processing

üîÑ VIOLATION CONSEQUENCES (CORRECTION PROTOCOL):
- Detect violation: PAUSE and acknowledge the attempt
- Self-correct: "I was about to use batch processing approach"
- Redirect: "I will now select ONE specific file to process individually"
- Continue: Restart current file processing with proper individual approach

‚úÖ MANDATORY INDIVIDUAL PROCESSING:
- Process EXACTLY ONE file at a time
- Read each file completely before making any changes
- Apply conversion rules step by step for each individual file
- Validate each conversion before proceeding to the next file
- Treat each file as completely unique - never assume similarity
- Use specific file names only - never use patterns or wildcards
- Focus on one file at a time with full attention to its specific content

PROCESSING METHODOLOGY - INDIVIDUAL FILE APPROACH:
1. Select ONE specific file by exact filename
2. Read that ONE file completely
3. Analyze the SQL patterns in that ONE file only
4. Apply all conversion rules to that ONE file
5. Validate the conversion for that ONE file
6. Save the converted file
7. Move to the NEXT specific file (repeat from step 1)

üîÑ BEHAVIORAL CORRECTION PROTOCOL üîÑ

VIOLATION DETECTION KEYWORDS:
If you catch yourself using ANY of these phrases, IMMEDIATELY CORRECT YOUR APPROACH:
- "efficient", "systematic", "remaining", "batch", "bulk"
- "similar", "pattern", "streamline", "optimize", "faster"  
- "continue with", "process the rest", "due to large number"

IMMEDIATE CORRECTION ACTIONS:
1. PAUSE and acknowledge: "I was about to use batch processing approach"
2. REDIRECT: "I will now select ONE specific file to process individually"
3. RESTART current file processing with proper individual approach
4. CONTINUE with correct methodology

SELF-CORRECTION EXAMPLE:
‚ùå Wrong: "Let me efficiently process the remaining files..."
‚úÖ Corrected: "I caught myself trying to batch process. Let me select the next specific file: [EXACT_FILENAME] and process it individually."

‚úÖ POSITIVE REINFORCEMENT TRIGGERS ‚úÖ
REWARD YOURSELF when you:
- Select ONE specific file by exact name
- Read the entire file before processing
- Apply conversion rules step-by-step to that single file
- Complete one file before moving to the next
- Treat each file as unique

Task: Convert MyBatis-based Oracle SQL Mapper files to MySQL-compatible SQL Mapper files

A. Environment Setup:
  1. Environment Configuration:
      1.1 Directories:
          - Working Directory: {L1FolderName}
          - Source Files: {MAPPER_SRCL1_DIR} (Batch processing: {BATCH_FILE_COUNT} files)
          - Target Files: {MAPPER_TGTL1_DIR}
          - Logs: {L1FolderName}

  2. Execution Status Management:
      2.1 Status File:
          - Location: {L1FolderName}/status.txt
          - Format:
              Step 1: [Status]
              Step 2: [Status]
              Step 3: [Status]
              Step 4: [Status]

      2.2 Status Values:
          - Not Started
          - In Progress
          - Completed

  3. Processing Rules:
      3.1 Log Directory:
          - Preserve all contents
          - Never delete existing logs

      3.2 Status Updates:
          - Update to "In Progress" when Step begins
          - Update to "Completed" when Step ends

B. Task Progression Steps:
  Step 1. Target File Discovery and Processing Organization

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 1: In Progress"

    2. Target File Discovery:
        2.1 Command Execution:
            - Command: ls *{ORIGIN_SUFFIX}* | sort
            - Purpose: Identify ALL conversion target candidates
        
        2.2 File Count Assessment:
            - Count total files requiring conversion
            - Determine processing organization strategy
            - Log total file count for progress tracking

    3. Processing Organization Strategy:
        3.1 For File Count ‚â§ 10:
            - Process all files in single sequential order
            - Maintain individual file processing approach

    4. Processing Plan Generation:
        4.1 Create organized processing plan:
            - Total Files: [N]
            - Strategy: Sequential individual file conversion
            - Expected completion: All [N] files processed individually

    5. Completion:
        5.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 1: Completed"

  Step 2. Analyze SQL for all {MAPPER_SRCL1_DIR}/*{ORIGIN_SUFFIX}*.xml files

    Detailed execution instructions are documented in $APP_TOOLS_FOLDER/sqlTransformTargetAnalysis.md. Currently skip this step to improve conversion performance

  Step 3. Sequential Individual File Conversion (MAIN PROCESS)

    üéØ ORGANIZED INDIVIDUAL PROCESSING APPROACH:
    Process files using group-based organization while maintaining individual file conversion principle.

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 3: In Progress"

    2. Batch-Based Sequential Processing:
        
        2.1 Current Batch Information:
            - Batch Input Folder: {MAPPER_SRCL1_DIR}
            - Batch Output Folder: {MAPPER_TGTL1_DIR}
            - Files in Current Batch: {BATCH_FILE_COUNT} files
            - Processing Mode: Individual file processing within batch folder
            
        2.2 Individual File Processing Within Batch:
            
            FOR EACH INDIVIDUAL FILE IN CURRENT BATCH FOLDER:
            1. **File Discovery**: List all XML files in {MAPPER_SRCL1_DIR}
            2. **File Selection**: Select ONE specific file by exact filename
            3. **File Reading**: Read the complete file content  
            4. **Conversion Processing**: Apply complete Four-Phase Oracle ‚Üí MySQL transformation
            5. **Validation**: Verify conversion accuracy and XML integrity
            6. **File Output**: Save converted file to {MAPPER_TGTL1_DIR}
            7. **Progress Update**: Log individual file completion
            8. **Next File**: Move to next file in current batch folder
            
            PROCESS ALL {BATCH_FILE_COUNT} FILES IN THE BATCH FOLDER COMPLETELY

        2.3 Oracle ‚Üí MySQL Conversion Processing (All files containing SQL):
            
            üö® MANDATORY: Apply all 4 phases in order when SQL is detected
            
            üìñ **SQL Context Understanding (When Needed):**
            - **For complex conversions**: Examine the original source XML to understand complete SQL context
            - **When business logic is unclear**: Analyze the business logic behind each SQL statement
            - **For dynamic SQL patterns**: Consider the MyBatis usage pattern (parameter binding, result mapping)
            - **When consistency is required**: Review related SQL statements in the same mapper
            - **For complex table relationships**: Understand the data flow and table relationships
            
            ### PHASE 1 - STRUCTURAL PROCESSING (Execute in order):
            1. Schema Removal: `SCHEMA_NAME.TABLE_NAME` ‚Üí `TABLE_NAME` (First)
            2. JOIN Standardization: Oracle `(+)` ‚Üí `LEFT/RIGHT JOIN` (Second) **‚ö†Ô∏è Special Attention**
            3. Stored Procedure: `{call PROC()}` ‚Üí `CALL PROC()` (Third)
            4. Oracle Hints Removal: `/*+ ... */` removal (Fourth)
            5. DUAL Table: `FROM DUAL` ‚Üí complete removal (Fifth)
            6. SubQuery Alias: Add unique aliases to FROM/JOIN clause subqueries only (Sixth) **‚ö†Ô∏è MySQL Required**
            
            ‚ö†Ô∏è **MyBatis Conditional OUTER JOIN Special Processing (Critical):**
            
            **Standard OUTER JOIN:**
            ```sql
            -- BEFORE (Oracle)
            FROM TABLE_A A, TABLE_B B
            WHERE A.ID = B.ID(+)
            
            -- AFTER (MySQL)
            FROM TABLE_A A
            LEFT JOIN TABLE_B B ON A.ID = B.ID
            ```
            
            **Conditional OUTER JOIN (MyBatis `<if>` tag) - Real Example:**
            ```xml
            <!-- BEFORE (Oracle) -->
            <select id="selectEmployeeData" resultType="map">
                SELECT E.EMP_ID, E.EMP_NAME, D.DEPT_NAME, P.PROJECT_NAME
                FROM EMPLOYEE E, DEPARTMENT D, PROJECT P
                WHERE E.DEPT_ID = D.DEPT_ID
                <if test="includeProject != null and includeProject == 'Y'">
                  AND E.EMP_ID = P.EMP_ID(+)
                  AND P.STATUS = 'ACTIVE'
                </if>
                ORDER BY E.EMP_ID
            </select>
            
            <!-- AFTER (MySQL) - Recommended Approach -->
            <select id="selectEmployeeData" resultType="map">
                SELECT E.EMP_ID, E.EMP_NAME, D.DEPT_NAME, P.PROJECT_NAME
                <if test="includeProject == null or includeProject != 'Y'">
                FROM EMPLOYEE E
                INNER JOIN DEPARTMENT D ON E.DEPT_ID = D.DEPT_ID
                </if>
                <if test="includeProject != null and includeProject == 'Y'">
                FROM EMPLOYEE E
                INNER JOIN DEPARTMENT D ON E.DEPT_ID = D.DEPT_ID
                <![CDATA[
                LEFT JOIN PROJECT P ON E.EMP_ID = P.EMP_ID AND P.STATUS = 'ACTIVE'
                ]]>
                </if>
                ORDER BY E.EMP_ID
            </select>
            ```
            
            **Complex Multi-Conditional JOIN Example:**
            ```xml
            <!-- BEFORE (Oracle) -->
            FROM ORDER_MASTER OM, CUSTOMER C, PRODUCT P, CATEGORY CT
            WHERE OM.CUST_ID = C.CUST_ID
            <if test="includeProduct == 'Y'">
              AND OM.PROD_ID = P.PROD_ID(+)
            </if>
            <if test="includeCategory == 'Y'">
              AND P.CATEGORY_ID = CT.CATEGORY_ID(+)
            </if>
            
            <!-- AFTER (MySQL) -->
            <choose>
                <when test="includeProduct == 'Y' and includeCategory == 'Y'">
                FROM ORDER_MASTER OM
                INNER JOIN CUSTOMER C ON OM.CUST_ID = C.CUST_ID
                <![CDATA[
                LEFT JOIN PRODUCT P ON OM.PROD_ID = P.PROD_ID
                LEFT JOIN CATEGORY CT ON P.CATEGORY_ID = CT.CATEGORY_ID
                ]]>
                </when>
                <when test="includeProduct == 'Y' and includeCategory != 'Y'">
                FROM ORDER_MASTER OM
                INNER JOIN CUSTOMER C ON OM.CUST_ID = C.CUST_ID
                <![CDATA[
                LEFT JOIN PRODUCT P ON OM.PROD_ID = P.PROD_ID
                ]]>
                </when>
                <otherwise>
                FROM ORDER_MASTER OM
                INNER JOIN CUSTOMER C ON OM.CUST_ID = C.CUST_ID
                </otherwise>
            </choose>
            ```
            
            **Key Guidelines:**
            - **Conditional FROM clause branching**: Use `<if test="!condition">` to maintain base FROM clause
            - **Complete FROM clause provision**: Provide complete FROM clause for each condition
            - **Explicit JOIN specification**: Convert comma joins to explicit INNER JOINs
            - **JOIN direction verification**: Determine LEFT/RIGHT JOIN based on `(+)` position
            - **MyBatis structure preservation**: Maintain `<if>`, `<choose>`, `<when>` tags
            - **WHERE ‚Üí ON clause migration**: Move Oracle `(+)` conditions to MySQL ON clauses
            - **CDATA block usage**: Place conditional JOINs inside `<![CDATA[]]>`
            - **Table alias preservation**: Maintain all table aliases (B1, B2, B3, etc.)
            
            ### PHASE 2 - CORE FUNCTION CONVERSION (Execute 1-22 in order):
            
            ### Sequence Handling (MySQL AUTO_INCREMENT)
            
            **Apply pattern-based conversion rules. If no pattern matches, apply expert judgment for appropriate MySQL AUTO_INCREMENT conversion.**

            #### **Pattern 1: selectKey BEFORE with NEXTVAL**
            ```xml
            <!-- Oracle -->
            <insert id="insertMethod" parameterType="..." useGeneratedKeys="true" keyProperty="seqColumn">
                <selectKey resultType="java.lang.Integer" keyProperty="seqColumn" order="BEFORE">
                    SELECT SEQUENCE_NAME.NEXTVAL FROM DUAL
                </selectKey>
                INSERT INTO TABLE_NAME (SEQ_COLUMN, OTHER_COLUMNS...)
                VALUES (#{seqColumn}, #{otherValues}...)
            </insert>

            <!-- MySQL -->
            <insert id="insertMethod" parameterType="..." useGeneratedKeys="true" keyProperty="seqColumn">
                INSERT INTO TABLE_NAME (OTHER_COLUMNS...)
                VALUES (#{otherValues}...)
            </insert>
            ```
            **Conversion Rules:**
            - Remove `<selectKey order="BEFORE">` tag completely
            - Remove AUTO_INCREMENT column from INSERT column list
            - Remove corresponding parameter from VALUES
            - Keep `useGeneratedKeys="true" keyProperty`

            #### **Pattern 2: VALUES with NEXTVAL + selectKey AFTER CURRVAL**
            ```xml
            <!-- Oracle -->
            <insert id="insertMethod" parameterType="...">
                INSERT INTO TABLE_NAME (COL1, SEQ_COLUMN, COL3...)
                VALUES (#{col1}, SEQUENCE_NAME.NEXTVAL, #{col3}...)
                <selectKey keyProperty="seqColumn" resultType="int" order="AFTER">
                    SELECT SEQUENCE_NAME.CURRVAL FROM DUAL
                </selectKey>
            </insert>

            <!-- MySQL -->
            <insert id="insertMethod" parameterType="..." useGeneratedKeys="true" keyProperty="seqColumn">
                INSERT INTO TABLE_NAME (COL1, COL3...)
                VALUES (#{col1}, #{col3}...)
            </insert>
            ```
            **Conversion Rules:**
            - Remove `SEQUENCE_NAME.NEXTVAL` from VALUES
            - Remove AUTO_INCREMENT column from column list
            - Remove `<selectKey order="AFTER">` and add `useGeneratedKeys="true"`
            - Preserve `keyProperty` for generated ID return

            #### **Pattern 3: INSERT INTO ... SELECT with NEXTVAL**
            ```xml
            <!-- Oracle -->
            <insert id="insertMethod" parameterType="...">
                INSERT INTO TABLE_NAME (columns...)
                SELECT SEQUENCE_NAME.NEXTVAL AS SEQ_COLUMN,
                       OTHER_COLUMNS...
                FROM SOURCE_TABLE
                WHERE conditions...
            </insert>

            <!-- MySQL -->
            <insert id="insertMethod" parameterType="...">
                INSERT INTO TABLE_NAME (OTHER_COLUMNS...)
                SELECT OTHER_COLUMNS...
                FROM SOURCE_TABLE  
                WHERE conditions...
            </insert>
            ```
            **Conversion Rules:**
            - Remove `SEQUENCE_NAME.NEXTVAL AS SEQ_COLUMN` from SELECT
            - Remove AUTO_INCREMENT column from INSERT column list

            #### **Pattern 4: Direct NEXTVAL in VALUES (no selectKey)**
            ```xml
            <!-- Oracle -->
            <insert id="insertBatch" parameterType="...">
                INSERT INTO TABLE_NAME (
                    SEQ_COLUMN,
                    OTHER_COLUMNS...
                ) VALUES (
                    SQ_SEQUENCE_01.NEXTVAL,
                    #{param1},
                    #{param2}...
                )
            </insert>

            <!-- MySQL -->
            <insert id="insertBatch" parameterType="...">
                INSERT INTO TABLE_NAME (
                    OTHER_COLUMNS...
                ) VALUES (
                    #{param1},
                    #{param2}...
                )
            </insert>
            ```
            **Conversion Rules:**
            - Remove AUTO_INCREMENT column from INSERT column list
            - Remove `SEQUENCE.NEXTVAL` from VALUES

            #### **Pattern 5: Standalone CURRVAL Usage**
            ```xml
            <!-- Oracle -->
            <select id="getCurrentSeqValue" resultType="int">
                SELECT SEQUENCE_NAME.CURRVAL FROM DUAL
            </select>

            <!-- MySQL -->
            <select id="getCurrentSeqValue" resultType="int">
                SELECT LAST_INSERT_ID()
            </select>
            ```
            **Conversion Rules:**
            - Replace `SEQUENCE.CURRVAL` with `LAST_INSERT_ID()`
            - Remove `FROM DUAL`

            #### **Pattern 6: NEXTVAL with Business Logic Integration**
            ```xml
            <!-- Oracle -->
            <insert id="insertByBusiness" parameterType="..." useGeneratedKeys="true" keyProperty="seqColumn">
                <selectKey resultType="java.lang.Integer" keyProperty="seqColumn" order="BEFORE">
                    SELECT SEQUENCE_NAME.NEXTVAL FROM DUAL
                </selectKey>
                INSERT INTO TABLE_NAME (SEQ_COLUMN, BUSINESS_COLUMN, OTHER_COLUMNS...)
                VALUES (#{seqColumn}, to_char(sysdate,'yyyymmdd')||'-'||#{seqColumn}, #{otherValues}...)
            </insert>

            <!-- MySQL -->
            <insert id="insertByBusiness" parameterType="..." useGeneratedKeys="true" keyProperty="seqColumn">
                INSERT INTO TABLE_NAME (BUSINESS_COLUMN, OTHER_COLUMNS...)
                VALUES (NULL, #{otherValues}...)
                
                <!-- TODO: Business logic requires post-processing -->
                <selectKey resultType="int" keyProperty="seqColumn" order="AFTER">
                    SELECT LAST_INSERT_ID();
                    UPDATE TABLE_NAME 
                    SET BUSINESS_COLUMN = CONCAT(DATE_FORMAT(NOW(),'%Y%m%d'),'-',SEQ_COLUMN)
                    WHERE SEQ_COLUMN = LAST_INSERT_ID()
                </selectKey>
            </insert>
            ```
            **Conversion Rules:**
            - Remove AUTO_INCREMENT column from INSERT column list
            - Set business logic column to NULL in INSERT
            - Add selectKey AFTER with UPDATE processing
            - Add TODO comment for post-processing requirement
            
            **Essential 22 MySQL Conversions (Direct Application):**
            1. `NVL(a, b)` ‚Üí `IFNULL(a, b)`
            2. `DECODE(expr, val1, res1, ...)` ‚Üí `CASE WHEN ... END`
            3. `TO_DATE('str', 'format')` ‚Üí `STR_TO_DATE('str', 'mysql_format')`
            4. `TO_CHAR(num)` ‚Üí `CAST(num AS CHAR)`
            5. `ROWNUM <= n` ‚Üí `LIMIT n`
            6. `TO_NUMBER(str)` ‚Üí `CAST(str AS DECIMAL)`
            7. `ROW_NUMBER() OVER(...)` ‚Üí `ROW_NUMBER() OVER(...)` (Same syntax)
            8. `SYSDATE` ‚Üí `NOW()`
            9. `ADD_MONTHS(date, n)` ‚Üí `DATE_ADD(date, INTERVAL n MONTH)`
            10. `NVL2(expr1, expr2, expr3)` ‚Üí `CASE WHEN (expr1 IS NOT NULL AND expr1 != '') THEN expr2 ELSE expr3 END`
            11. `LISTAGG(col, delim)` ‚Üí `GROUP_CONCAT(col SEPARATOR delim)`
            12. `SUBSTR(str, pos, len)` ‚Üí `SUBSTRING(str, GREATEST(pos, 1), len)`
            13. `INSTR(str, substr)` ‚Üí `LOCATE(substr, str)`
            14. `MONTHS_BETWEEN(d1, d2)` ‚Üí `TIMESTAMPDIFF(MONTH, d2, d1)`
            15. `TRUNC(date)` ‚Üí `DATE(date)`
            16. `USER` ‚Üí `USER()`
            17. `SYS_GUID()` ‚Üí `UUID()`
            18. `POWER(n, m)` ‚Üí `POW(n, m)`
            19. `CEIL(n)` ‚Üí `CEILING(n)`
            20. `INITCAP(str)` ‚Üí `CONCAT(UPPER(LEFT(str,1)), LOWER(SUBSTRING(str,2)))`
            21. `LENGTH('')` ‚Üí `CASE WHEN (col IS NULL OR col = '') THEN NULL ELSE LENGTH(col) END`
            22. Oracle string concatenation `||` ‚Üí `CONCAT()`
            
            **Additional Required Conversions (Included in Essential 22):**
            - `{call PROC()}` ‚Üí `CALL PROC()` (Processed in PHASE 1)
            - `SEQ.NEXTVAL` ‚Üí `AUTO_INCREMENT` or `LAST_INSERT_ID()`
            
            **Additional Directly Convertible Functions:**
            - `NULLIF(expr1, expr2)` ‚Üí `NULLIF(expr1, expr2)` (MySQL identical support)
            - `COALESCE(val1, val2, ...)` ‚Üí `COALESCE(val1, val2, ...)` (MySQL identical support)
            - `EXTRACT(unit FROM date)` ‚Üí `EXTRACT(unit FROM date)` (MySQL identical support)
            
            ### PHASE 3 - DETAILED CONVERSION (Execute in order):
            1. Complex date function conversion (First)
            2. Advanced string function processing (Second)
            3. NULL handling logic conversion (Third)
            4. Regular expression functions (Fourth - Expert judgment + Precautions)
            5. Window Functions (Fifth - Expert judgment + Precautions)
            6. Hierarchical query CONNECT BY (Sixth - Expert judgment)
            
            üìã **Additional Convertible Functions (Process in PHASE 3):**
            
            **Window Functions (MySQL Identical Support - Direct Conversion):**
            - `LEAD(col) OVER(...)` ‚Üí `LEAD(col) OVER(...)` (MySQL 8.0+)
            - `RANK() OVER(...)` ‚Üí `RANK() OVER(...)`
            - `LAG(col) OVER(...)` ‚Üí `LAG(col) OVER(...)`
            - `DENSE_RANK() OVER(...)` ‚Üí `DENSE_RANK() OVER(...)`
            
            **Regular Expression Functions (MySQL 8.0+ Support - Parameter Caution):**
            - `REGEXP_LIKE(str, pattern)` ‚Üí `str REGEXP pattern` or `REGEXP_LIKE(str, pattern)`
            - `REGEXP_SUBSTR(str, pattern, pos, occurrence)` ‚Üí `REGEXP_SUBSTR(str, pattern, pos, occurrence)` (Parameter differences caution)
            - `REGEXP_REPLACE(str, pattern, replacement)` ‚Üí `REGEXP_REPLACE(str, pattern, replacement)`
            
            üö´ **Functions That Are Very Difficult or Impossible to Convert**
            
            **Basic Processing Principles:**
            1. **Comment Out**: Preserve original Oracle functions as comments
            2. **Dummy Value Replacement**: Temporarily replace with NULL or default values
            3. **Add SQL Style TODO Comments**: Specify parts that need future modification
            
            **XML Function Processing Example:**
            ```sql
            -- BEFORE (Oracle)
            SELECT XMLELEMENT("employee", emp_name) as xml_data
            FROM employees;
            
            -- AFTER (MySQL)
            SELECT 
                -- TODO: XMLELEMENT function replacement needed - Consider JSON functions or CONCAT
                -- XMLELEMENT("employee", emp_name) as xml_data
                NULL as xml_data  -- Temporary dummy value
            FROM employees;
            ```
            
            **Oracle Package/System Function Processing Example:**
            ```sql
            -- BEFORE (Oracle)
            SELECT DBMS_LOB.SUBSTR(clob_column, 100, 1) as excerpt,
                   ROWID as row_identifier
            FROM documents;
            
            -- AFTER (MySQL)
            SELECT 
                -- TODO: DBMS_LOB.SUBSTR replacement needed - Change to SUBSTRING function, review CLOB processing logic
                -- DBMS_LOB.SUBSTR(clob_column, 100, 1) as excerpt,
                SUBSTRING(clob_column, 1, 100) as excerpt,  -- Temporary replacement
                
                -- TODO: ROWID cannot be replaced - Business logic change needed, review alternative keys
                -- ROWID as row_identifier
                NULL as row_identifier  -- Temporary dummy value
            FROM documents;
            ```
            
            **PL/SQL Statement Processing Example:**
            ```sql
            -- BEFORE (Oracle PL/SQL)
            FORALL i IN 1..employee_ids.COUNT
                INSERT INTO temp_table VALUES (employee_ids(i));
            
            -- AFTER (MySQL)
            -- TODO: FORALL statement replacement needed - Change to MySQL loop or batch INSERT
            -- FORALL i IN 1..employee_ids.COUNT
            --     INSERT INTO temp_table VALUES (employee_ids(i));
            
            -- Temporary replacement: Simple INSERT (batch processing logic to be implemented later)
            INSERT INTO temp_table 
            SELECT employee_id FROM employees WHERE condition = 'Y';
            ```
            
            **Comment Processing Guidelines:**
            - `-- TODO: [Function Name] replacement needed - [Specific replacement approach]`
            - `-- [Original Oracle statement]`
            - `[Temporary dummy value or replacement statement]  -- Temporary replacement/dummy value`
            
            ‚ö†Ô∏è **REGEX Function Conversion Precautions (Critical - Frequent Errors):**
            - **Mandatory double quote fix**: `REGEXP_SUBSTR(SUBSTRING(''TEST'', ...)` ‚Üí `REGEXP_SUBSTR(SUBSTRING('TEST', ...)`
            - **Parameter order verification**: Oracle `REGEXP_SUBSTR(str, pattern, pos, occurrence)` vs MySQL same but behavioral differences
            - **CONNECT BY LEVEL combination**: `REGEXP_SUBSTR(str, '[^,]+', 1, LEVEL)` ‚Üí Requires WITH RECURSIVE conversion in MySQL
            - **Regular expression pattern validation**: Verify patterns like `[^ ^/]+`, `[^,]+` work correctly in MySQL
            - **MySQL 8.0+ required**: REGEXP_SUBSTR only supported in MySQL 8.0+
            - **String splitting patterns**: Oracle REGEXP_SUBSTR + CONNECT BY LEVEL ‚Üí Consider MySQL SUBSTRING_INDEX or JSON_TABLE
            
            ‚ö†Ô∏è **Window Function Conversion Precautions:**
            - `ORDER BY 1` ‚Üí `ORDER BY column_name` (Use column names instead of position numbers)
            - Prohibit position numbers in `PARTITION BY` clauses as well
            - **Alias reference in ORDER BY**: Avoid using SELECT clause aliases in Window Function ORDER BY
            - Verify FRAME clause combinations not supported in MySQL
            - Decompose nested Window Functions into subqueries
            
            **Alias Reference Example:**
            ```sql
            -- AVOID (May cause issues in MySQL)
            SELECT emp_id, 
                   salary * 1.1 AS adjusted_salary,
                   ROW_NUMBER() OVER (ORDER BY adjusted_salary) AS rn
            FROM employees;
            
            -- RECOMMENDED (Use original expression)
            SELECT emp_id, 
                   salary * 1.1 AS adjusted_salary,
                   ROW_NUMBER() OVER (ORDER BY salary * 1.1) AS rn
            FROM employees;
            ```
            
            ‚ö†Ô∏è **High-Frequency Error Precautions:**
            1. **Unsupported Oracle analytic functions**: `RATIO_TO_REPORT() OVER()` ‚Üí `(value / SUM(value) OVER()) * 100`
            2. **Empty OVER() clauses**: Prohibit standalone `OVER()` usage ‚Üí Use with appropriate window functions
            3. **Table name function errors**: `TB_TABLE_NAME(...)` ‚Üí `SELECT ... FROM TB_TABLE_NAME`
            4. **DATE_ADD INTERVAL syntax**: `'TEST' 12 'TEST'` ‚Üí `INTERVAL 12 MONTH/DAY/YEAR`
            5. **Double quotes**: `''TEXT''` ‚Üí `'TEXT'` (Oracle escape ‚Üí MySQL standard)
            6. **SUBSTRING_INDEX parameters**: Verify delimiter and position parameter order
            7. **Window Function syntax**: `LEAD('TEST') OVER ('TEST' BY 'TEST')` ‚Üí Correct PARTITION BY/ORDER BY syntax
            
            ### PHASE 4 - VALIDATION & CLEANUP (Execute in order):
            1. MySQL syntax verification (First)
            2. MyBatis parameter binding `#{...}` preservation verification (Second)
            3. XML tag structure integrity verification (Third)
            4. MySQL function syntax cleanup - Remove spaces between function names and parentheses (Fourth)
            5. XML special character handling for inequality operators (Fifth) **‚ö†Ô∏è XML Parsing Critical**
            6. Final formatting and cleanup (Sixth)
            
            ‚ö†Ô∏è **XML Special Character Handling (CRITICAL - Phase 4.5):**
            
            **Problem**: XML parsing errors occur when inequality operators (`<`, `>`) are used outside CDATA sections
            
            #### **CDATA Detection Rule (CRITICAL)**
            **ONLY convert inequality operators that are OUTSIDE `<![CDATA[]]>` sections**
            
            **Step 1: Identify CDATA Sections**
            - Scan for `<![CDATA[` opening tags
            - Find matching `]]>` closing tags
            - Mark all content between them as CDATA-protected
            
            **Step 2: Apply Conversion Rules**
            - **Inside CDATA**: Leave `<`, `>` operators unchanged
            - **Outside CDATA**: Convert to XML entities
            
            #### **Conversion Examples**
            
            **Example 1: Mixed CDATA and Dynamic SQL**
            ```xml
            <!-- BEFORE conversion -->
            <select id="getEmployees">
                <![CDATA[
                    SELECT * FROM employees 
                    WHERE salary > #{minSalary}  <!-- CDATA: No conversion needed -->
                ]]>
                <if test="maxAge != null">
                    AND age < #{maxAge}  <!-- Outside CDATA: Needs conversion -->
                </if>
            </select>
            
            <!-- AFTER conversion -->
            <select id="getEmployees">
                <![CDATA[
                    SELECT * FROM employees 
                    WHERE salary > #{minSalary}  <!-- CDATA: Unchanged -->
                ]]>
                <if test="maxAge != null">
                    AND age &lt; #{maxAge}  <!-- Outside CDATA: Converted -->
                </if>
            </select>
            ```
            
            **Example 2: All Outside CDATA**
            ```xml
            <!-- BEFORE conversion -->
            <select id="getRange">
                SELECT * FROM employees 
                WHERE salary >= #{min} AND salary <= #{max}
                <if test="status != null">
                    AND status <> #{status}
                </if>
            </select>
            
            <!-- AFTER conversion -->
            <select id="getRange">
                SELECT * FROM employees 
                WHERE salary &gt;= #{min} AND salary &lt;= #{max}
                <if test="status != null">
                    AND status &lt;&gt; #{status}
                </if>
            </select>
            ```
            
            **Example 3: All Inside CDATA**
            ```xml
            <!-- BEFORE and AFTER (No conversion needed) -->
            <select id="getStatic">
                <![CDATA[
                    SELECT * FROM employees 
                    WHERE salary > 50000 
                      AND age < 65
                      AND status <> 'INACTIVE'
                ]]>
            </select>
            ```
            
            #### **Required XML Entity Conversions (Outside CDATA only)**
            - `<` ‚Üí `&lt;`
            - `>` ‚Üí `&gt;`
            - `<=` ‚Üí `&lt;=`
            - `>=` ‚Üí `&gt;=`
            - `<>` ‚Üí `&lt;&gt;`
            
            #### **Processing Algorithm**
            1. **Parse XML structure**: Identify all CDATA sections
            2. **Mark protected areas**: Flag content inside `<![CDATA[]]>`
            3. **Scan for operators**: Find `<`, `>`, `<=`, `>=`, `<>` outside CDATA
            4. **Apply conversions**: Convert only unprotected operators
            5. **Preserve CDATA content**: Leave CDATA sections completely unchanged
            
            #### **Validation Checklist**
            - [ ] CDATA sections correctly identified
            - [ ] Operators inside CDATA left unchanged
            - [ ] Operators outside CDATA converted to entities
            - [ ] XML validates without parsing errors
            - [ ] SQL logic remains functionally correct
            - [ ] MyBatis dynamic tags work correctly
            
            ‚ö†Ô∏è **MySQL Function Syntax Cleanup (CRITICAL - Phase 4.4):**
            **Problem**: MySQL requires NO SPACE between function name and opening parenthesis
            **Oracle allows**: `FUNCTION (parameters)` 
            **MySQL requires**: `FUNCTION(parameters)`
            
            **Mandatory Cleanup Patterns:**
            - `IFNULL (` ‚Üí `IFNULL(`
            - `STR_TO_DATE (` ‚Üí `STR_TO_DATE(`
            - `SUBSTRING (` ‚Üí `SUBSTRING(`
            - `COUNT (` ‚Üí `COUNT(`
            - `SUM (` ‚Üí `SUM(`
            - `AVG (` ‚Üí `AVG(`
            - `MAX (` ‚Üí `MAX(`
            - `MIN (` ‚Üí `MIN(`
            - `CONCAT (` ‚Üí `CONCAT(`
            - `CASE WHEN (` ‚Üí `CASE WHEN (`  (Exception: CASE WHEN allows space)
            - `DATE_ADD (` ‚Üí `DATE_ADD(`
            - `TIMESTAMPDIFF (` ‚Üí `TIMESTAMPDIFF(`
            - `CAST (` ‚Üí `CAST(`
            - `COALESCE (` ‚Üí `COALESCE(`
            
            **Apply to ALL MySQL functions after conversion**
            
            üîç **MySQL Syntax Validation (When Needed):**
            - **Connect to MySQL server** to validate converted SQL syntax if uncertain
            - **Create test SQL statements** to verify MySQL compatibility
            - **Connection information**: Available in environment variables (search for MYSQL)
            - **Test complex conversions** especially for REGEX, Window Functions, and complex JOINs
            - **Verify data type compatibility** and function behavior differences
            
        2.4 Post-Conversion Verification Checklist:
            
            ‚úÖ **Required Verification Items:**
            1. Verify all Oracle functions have been converted to MySQL functions
            2. Verify MyBatis parameter binding `#{...}` remains intact
            3. Verify XML tag structure is not damaged
            4. Verify SQL statements are executable in MySQL
            5. Verify business logic has not changed
            
            üìù **Post-Conversion Reference:**
            - Verify all **Essential 22 MySQL Conversions** defined in PHASE 2 above have been applied
            - Verify compliance with REGEX and Window Function precautions in PHASE 3
            - Verify MyBatis conditional OUTER JOIN special processing has been applied
            - Verify difficult-to-convert Oracle functions have SQL Style TODO comments with dummy values
            
        2.5 ‚ö†Ô∏è Core Precautions for Conversion Work (Common to All PHASES):

            ### Mandatory Compliance Principles
            - **Business Logic Preservation**: Preserve original intent when converting functions
            - **Parameter Binding Preservation**: Keep MyBatis `#{...}` syntax intact
            - **XML Structure Preservation**: Prohibit changes to MyBatis XML tag structure
            - **Incremental Modification**: Don't change everything at once, modify step by step
            - **Testing Required**: Always verify functionality after each modification

            ### Verification Points During Conversion
            1. **SQL Result Consistency**: Verify Oracle and MySQL return identical results
            2. **Performance Impact**: Check for query performance degradation after conversion
            3. **Data Type Compatibility**: Prevent data loss from column type conversions
            4. **Transaction Behavior**: Verify commit/rollback behavior consistency
            5. **Exception Handling**: Verify behavior consistency in error cases

            ### Risk Factor Checklist
            - [ ] Unexpected results from NULL handling logic changes
            - [ ] Timezone issues from date/time function conversions
            - [ ] Encoding problems from string function conversions
            - [ ] Calculation errors from numeric precision changes
            - [ ] Data omission/duplication from paging logic changes
            - Complex date functions ‚Üí "üîß MYSQL CONVERSION RULES - Date Functions"
            - String manipulation ‚Üí "üîß MYSQL CONVERSION RULES - String Functions"
            - Advanced NULL handling ‚Üí "üîß MYSQL CONVERSION RULES - Advanced NULL Handling"
            - Stored procedures ‚Üí "üîß MYSQL STORED PROCEDURE PROCESSING"
            - ResultMap issues ‚Üí "üó∫Ô∏è RESULTMAP PROCESSING"
            - Complex queries ‚Üí "üî¨ ADVANCED CONVERSIONS"

            ### PHASE 4 - FINAL VALIDATION AND CORRECTION (Apply Last):
            23. **XML Structure Validation**
                - Verify all opening/closing tags match
                - Ensure XML attributes are preserved

            24. **CDATA Section Integrity Check**
                - Confirm CDATA structure is intact while SQL content is converted
                - Verify dynamic query tags are preserved

            25. **Conversion Result Validation**
                - MySQL syntax validation
                - MyBatis bind variable preservation check
                - Functional integrity verification

        2.3 Individual File Processing Rules:
            
            üéØ CORE PROCESSING REQUIREMENTS:
            - Process EXACTLY ONE file at a time with complete focus
            - Read each file completely before making any changes
            - Apply ALL conversion rules to the current file systematically
            - Validate conversion before proceeding to next file
            - Treat each file as unique (never assume similarity)
            
            üî• MANDATORY CONVERSION APPROACH:
            - SCAN entire file content for ANY Oracle construct
            - APPLY transformation rules to EVERY Oracle pattern found
            - COMPLETE 4-phase processing for ALL files
            - NO exceptions for "minor" or "compatible" constructs
            - NO partial conversion allowed

            ‚úÖ REQUIRED SCANNING PATTERNS:
            - Oracle functions: NVL, DECODE, SYSDATE, SUBSTR, ADD_MONTHS, etc.
            - Oracle syntax: ROWNUM, DUAL, (+) joins, {call}, etc.
            - Oracle types: DATE, NUMBER, VARCHAR2, etc.
            - Oracle constructs: CONNECT BY, MERGE, sequences, etc.

        2.4 Progress Tracking Per File:
            
            üìä INDIVIDUAL FILE PROGRESS:
            - Current Group: [X] of [Total Groups]
            - Current File: [Y] of [Group Total] 
            - Overall Progress: [Z] of [Total Files]
            - File Name: [Exact Filename]
            - Status: [Reading/Processing/Validating/Completed]
            
            üìù COMPLETION LOGGING:
            - Log each file completion before moving to next
            - Track conversion patterns applied per file
            - Record any expert-level conversions used
            - Maintain group completion status

        2.5 MySQL Conversion Rules Application:
            
            üéØ COMPREHENSIVE CONVERSION MANDATE:
            Apply COMPLETE Oracle ‚Üí MySQL conversion rules to each individual file.
            
            **MANDATORY TRANSFORMATION COVERAGE:**
            - ALL Oracle functions (NVL, DECODE, SYSDATE, SUBSTR, etc.)
            - ALL sequence handling (NEXTVAL, CURRVAL ‚Üí AUTO_INCREMENT)
            - ALL pagination conversion (ROWNUM ‚Üí LIMIT/OFFSET Ïö∞ÏÑ†, ROW_NUMBER() ÌïÑÏöîÏãúÏóêÎßå)
            - ALL DUAL table replacements
            - ALL stored procedure syntax ({call} ‚Üí CALL)
            - ALL JOIN syntax standardization
            - ALL string, numeric, and date/time functions
            - ALL Oracle-specific constructs
            
            **DATABASE EXPERT MODE:**
            For Oracle constructs NOT explicitly documented:
            - Apply appropriate MySQL equivalents based on expert knowledge
            - Use industry best practices for Oracle-to-MySQL conversions
            - Ensure semantic equivalence and optimal performance
            - Document expert-level transformations with comments
            - Document any expert-level transformations applied

        2.6 File Output:
            - Target Directory: {MAPPER_TGTL1_DIR}
            - Filename transformation: {ORIGIN_SUFFIX} ‚Üí {TRANSFORM_SUFFIX}
            - Add conversion comment with timestamp
            - Preserve XML structure and MyBatis functionality

    3. Logging and Tracking:
        3.1 Classification Results:
            Output: {L1FolderName}/processing_classification.txt
            
            Format:
            FAST TRACK - Configuration Only:
            - ConfigMapper.xml: No SQL content detected
            - CacheConfig.xml: Cache configuration only
            
            STANDARD TRACK - SQL Processing Required:
            - UserMapper.xml: Contains SELECT, INSERT operations
            - OrderMapper.xml: Contains stored procedure calls

        3.2 Performance Metrics:
            - Track processing time per file
            - Record classification accuracy
            - Monitor conversion success rate

    3. Final Completion:
        3.1 Processing Summary:
            - Total Files Processed: [N] of [N] (100%)
            - Groups Completed: [All Groups]
            - Individual File Success Rate: [Success Count]/[Total Count]
            
        3.2 Update Status:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 3: Completed"
            - Final Confirmation: "All [N] files processed individually with complete conversion"

  Step 4. Perform xmllint validation on all {MAPPER_TGTL1_DIR}/*{TRANSFORM_SUFFIX}*.xml files

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 4: In Progress"

    2. Target File Verification:
        2.1 Command Execution:
            - Command: ls {MAPPER_TGTL1_DIR}/*{TRANSFORM_SUFFIX}*.xml | sort
            - Purpose: Confirm list of files for validation

    3. XML Validation Process:
        Detailed instructions are documented in $APP_TOOLS_FOLDER/sqlTransformTargetXmlValidation.md, but currently this step should be skipped and not performed

    4. Completion:
        4.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 4: Completed"

# ORACLE TO MYSQL SQL TRANSFORMATION RULES

## üìã OVERVIEW

This section provides complete Oracle to MySQL SQL conversion guidelines with structured task progression.
All MySQL-specific rules are embedded directly in this section.
**CRITICAL**: This processes MyBatis XML mapper files - XML structure and CDATA sections must be preserved.

## üéØ PROCESSING METHODOLOGY

### Individual File Processing (MANDATORY)
- Process EXACTLY ONE file at a time
- Read each file completely before making any changes
- Apply conversion rules step by step for each individual file
- Validate each conversion before proceeding to the next file
- Treat each file as completely unique - never assume similarity
- **XML Structure Preservation**: Maintain all XML tags, attributes, and hierarchy
- **CDATA Protection**: Preserve CDATA sections while converting SQL content within

## üìÑ XML TAG PROCESSING

### Target Tags for SQL Conversion
Apply conversions to SQL content within these tags:

#### Basic SQL Tags
- `<sql>`
- `<select>`
- `<insert>`
- `<update>`
- `<delete>`

#### Subquery and Key Tags
- `<include>`
- `<selectKey>`

#### Result Mapping Tags
- `<resultMap>`
  - `<id>`
  - `<r>`
  - `<constructor>`
  - `<collection>`
  - `<association>`
  - `<discriminator>`

#### Parameter Mapping Tags
- `<parameterMap>`
- `<parameter>`

#### Cache Tags
- `<cache>`
- `<cache-ref>`

### Protected Dynamic Tags (DO NOT MODIFY)
- Flow control: `<if>`, `<choose>`, `<when>`, `<otherwise>`
- Iteration: `<foreach>`
- Variable binding: `<bind>`
- Parameters: `#{variable_name}`, `${variable_name}`

### CDATA Processing
**CRITICAL**: Preserve CDATA structure while converting SQL content

```xml
<!-- Original -->
<select id="getEmployee">
    <![CDATA[
        SELECT * FROM emp
        WHERE rownum <= 10  /* Requires conversion */
    ]]>
</select>

<!-- Convert to -->
<select id="getEmployee">
    <![CDATA[
        SELECT * FROM emp
        LIMIT 10
    ]]>
</select>
```

## üó∫Ô∏è RESULTMAP PROCESSING

### Java Type Conversions
- `javaType="java.math.BigDecimal"` ‚Üí `javaType="java.math.BigDecimal"` (keep as is)
- `javaType="oracle.sql.TIMESTAMP"` ‚Üí `javaType="java.sql.Timestamp"`
- `javaType="oracle.sql.CLOB"` ‚Üí `javaType="java.lang.String"`
- `javaType="oracle.sql.BLOB"` ‚Üí `javaType="byte[]"`

### JDBC Type Conversions (MySQL Compatible)
#### **Numeric Types**
- `jdbcType="NUMBER"` ‚Üí `jdbcType="DECIMAL"`
- `jdbcType="INTEGER"` ‚Üí `jdbcType="INTEGER"`
- `jdbcType="BIGINT"` ‚Üí `jdbcType="BIGINT"`
- `jdbcType="SMALLINT"` ‚Üí `jdbcType="SMALLINT"`
- `jdbcType="TINYINT"` ‚Üí `jdbcType="TINYINT"`
- `jdbcType="FLOAT"` ‚Üí `jdbcType="FLOAT"`
- `jdbcType="DOUBLE"` ‚Üí `jdbcType="DOUBLE"`

#### **String Types**
- `jdbcType="VARCHAR2"` ‚Üí `jdbcType="VARCHAR"`
- `jdbcType="CHAR"` ‚Üí `jdbcType="CHAR"`
- `jdbcType="NVARCHAR2"` ‚Üí `jdbcType="VARCHAR"`
- `jdbcType="NCHAR"` ‚Üí `jdbcType="CHAR"`
- `jdbcType="CLOB"` ‚Üí `jdbcType="LONGTEXT"`
- `jdbcType="NCLOB"` ‚Üí `jdbcType="LONGTEXT"`

#### **Date/Time Types**
- `jdbcType="DATE"` ‚Üí `jdbcType="DATETIME"`
- `jdbcType="TIMESTAMP"` ‚Üí `jdbcType="TIMESTAMP"`
- `jdbcType="TIMESTAMP_WITH_TIME_ZONE"` ‚Üí `jdbcType="TIMESTAMP"`
- `jdbcType="TIMESTAMP_WITH_LOCAL_TIME_ZONE"` ‚Üí `jdbcType="TIMESTAMP"`

#### **Binary Types**
- `jdbcType="BLOB"` ‚Üí `jdbcType="LONGBLOB"`
- `jdbcType="RAW"` ‚Üí `jdbcType="VARBINARY"`
- `jdbcType="LONG_RAW"` ‚Üí `jdbcType="LONGBLOB"`

#### **Special Types**
- `jdbcType="ROWID"` ‚Üí `jdbcType="VARCHAR"` (convert to string representation)
- `jdbcType="XMLTYPE"` ‚Üí `jdbcType="LONGTEXT"`

### Column Mapping Verification (MySQL Specific)
- Check column names match MySQL case sensitivity rules
- Verify column data types are compatible with MySQL
- Ensure property names in resultMap match Java entity fields
- **MySQL Case Sensitivity**: Depends on `lower_case_table_names` setting
  - `lower_case_table_names=0`: Case sensitive (Linux default)
  - `lower_case_table_names=1`: Case insensitive (Windows/macOS default)
  - `lower_case_table_names=2`: Case insensitive storage, case sensitive comparison (macOS default)

### MySQL-Specific ResultMap Considerations
#### **Column Name Handling**
```xml
<!-- Oracle style (may need adjustment) -->
<result column="EMP_ID" property="empId" jdbcType="NUMBER"/>

<!-- MySQL compatible (recommended) -->
<result column="emp_id" property="empId" jdbcType="DECIMAL"/>
```

#### **Auto-Generated Keys**
```xml
<!-- Oracle sequence style -->
<selectKey keyProperty="id" resultType="long" order="BEFORE">
    SELECT SEQ_EMP_ID.NEXTVAL FROM DUAL
</selectKey>

<!-- MySQL AUTO_INCREMENT style -->
<selectKey keyProperty="id" resultType="long" order="AFTER">
    SELECT LAST_INSERT_ID()
</selectKey>
```

### Implementation Example
```xml
<!-- Original -->
<resultMap id="empMap" type="Employee">
    <result property="salary" column="SALARY" javaType="java.math.BigDecimal" jdbcType="NUMBER"/>
    <result property="description" column="DESCRIPTION" javaType="oracle.sql.CLOB" jdbcType="CLOB"/>
</resultMap>

<!-- Convert to -->
<resultMap id="empMap" type="Employee">
    <result property="salary" column="SALARY" javaType="java.math.BigDecimal" jdbcType="NUMERIC"/>
    <result property="description" column="DESCRIPTION" javaType="java.lang.String" jdbcType="VARCHAR"/>
</resultMap>
```
## üîß MYSQL CONVERSION RULES

### Basic Functions (ÌïµÏã¨ Î≥ÄÌôò - ÏúÑ 20Í∞ú Í∑úÏπô Ï†ÅÏö©)
- Í∏∞Î≥∏ Ìï®Ïàò Î≥ÄÌôòÏùÄ ÏúÑÏùò **Essential 20 MySQL Conversions** Í∑úÏπôÏùÑ Îî∞Î¶Ñ
- Î≥µÏû°Ìïú ÏºÄÏù¥Ïä§Îäî ÏïÑÎûò ÏÉÅÏÑ∏ Í∑úÏπô Ï∞∏Ï°∞

#### **Ìï®ÏàòÎ≥Ñ ÏÉÅÏÑ∏ Î≥ÄÌôò Í∑úÏπô**

**SUBSTR/SUBSTRING Î≥ÄÌôò:**
- Í∏∞Î≥∏: `SUBSTR(str, pos, len)` ‚Üí `SUBSTRING(str, GREATEST(pos, 1), len)`
- Ïù¥Ïú†: OracleÏùò 0 Ïù∏Îç±Ïä§Î•º MySQL 1 Ïù∏Îç±Ïä§Î°ú ÏïàÏ†ÑÌïòÍ≤å Î≥ÄÌôò
- ÏùåÏàò Ïù∏Îç±Ïä§: Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ (ÎèôÏùºÌïòÍ≤å ÎèôÏûë)

**NVL Í≥ÑÏó¥ Ìï®Ïàò:**
- `NVL(a, b)` ‚Üí `IFNULL(a, b)` (Îã®Ïàú ÏºÄÏù¥Ïä§)
- `NVL(a, b)` ‚Üí `CASE WHEN (a IS NULL OR a = '') THEN b ELSE a END` (Oracle Ìò∏Ìôò)
- `NVL2(expr1, expr2, expr3)` ‚Üí `CASE WHEN (expr1 IS NOT NULL AND expr1 != '') THEN expr2 ELSE expr3 END`

### Date Functions
- `ADD_MONTHS(date, n)` ‚Üí `DATE_ADD(date, INTERVAL n MONTH)`
- `MONTHS_BETWEEN(d1, d2)` ‚Üí `TIMESTAMPDIFF(MONTH, d2, d1)`
- `LAST_DAY(date)` ‚Üí `LAST_DAY(date)`
- `NEXT_DAY(date, day)` ‚Üí Complex conversion using CASE and DATE_ADD
- `TRUNC(date, 'DD')` ‚Üí `DATE(date)`
- `TRUNC(date, 'MM')` ‚Üí `DATE_FORMAT(date, '%Y-%m-01')`
- `TRUNC(date, 'YYYY')` ‚Üí `DATE_FORMAT(date, '%Y-01-01')`
- `TRUNC(date, 'HH')` ‚Üí `DATE_FORMAT(date, '%Y-%m-%d %H:00:00')`
- `EXTRACT(YEAR FROM date)` ‚Üí `YEAR(date)`
- `EXTRACT(MONTH FROM date)` ‚Üí `MONTH(date)`
- `EXTRACT(DAY FROM date)` ‚Üí `DAY(date)`
- `EXTRACT(HOUR FROM timestamp)` ‚Üí `HOUR(timestamp)`
- `EXTRACT(MINUTE FROM timestamp)` ‚Üí `MINUTE(timestamp)`
- `EXTRACT(SECOND FROM timestamp)` ‚Üí `SECOND(timestamp)`

### Advanced Date Conversions
```sql
-- Oracle NEXT_DAY conversion example
-- NEXT_DAY(date, 'MONDAY') equivalent in MySQL (0=Monday in WEEKDAY())
DATE_ADD(date, INTERVAL (7 - WEEKDAY(date) + 0) % 7 + 
    CASE WHEN WEEKDAY(date) = 0 THEN 0 ELSE 1 END DAY)

-- Oracle TO_CHAR date formatting
TO_CHAR(date, 'YYYY-MM-DD') ‚Üí DATE_FORMAT(date, '%Y-%m-%d')
TO_CHAR(date, 'DD/MM/YYYY') ‚Üí DATE_FORMAT(date, '%d/%m/%Y')
TO_CHAR(date, 'MON DD, YYYY') ‚Üí DATE_FORMAT(date, '%b %d, %Y')
TO_CHAR(date, 'HH24:MI:SS') ‚Üí TIME_FORMAT(date, '%H:%i:%s')
```



### Pagination
- `ROWNUM <= n` ‚Üí `LIMIT n`
- Complex ROWNUM pagination ‚Üí `LIMIT n OFFSET m`

#### ROWNUM Based Pagination Pattern
```xml
<!-- Original -->
<select id="getList">
    SELECT * FROM (
        SELECT ROWNUM AS rnum, a.* FROM (
            ${originalQuery}
        ) a WHERE ROWNUM <= #{end}
    ) WHERE rnum >= #{start}
</select>

<!-- Convert to -->
<select id="getList">
    ${originalQuery}
    LIMIT #{pageSize} OFFSET #{start}
</select>
```

### String Functions (ÌïµÏã¨ 20Í∞ú Í∑úÏπô Ï†ÅÏö© + Ï∂îÍ∞Ä Í∑úÏπô)
- `INSTR(str, substr)` ‚Üí `LOCATE(substr, str)` (Îß§Í∞úÎ≥ÄÏàò ÏàúÏÑú Ï£ºÏùò)
- `SUBSTR(str, pos, len)` ‚Üí `SUBSTRING(str, GREATEST(pos, 1), len)` (ÏúÑ ÌïµÏã¨ Í∑úÏπô Ï†ÅÏö©)
- `LPAD/RPAD/TRIM/UPPER/LOWER` ‚Üí ÎèôÏùº (Î≥ÄÌôò Î∂àÌïÑÏöî)
- `TO_CHAR(num)` ‚Üí `CAST(num AS CHAR)` (ÏúÑ ÌïµÏã¨ Í∑úÏπô Ï†ÅÏö©)
- `TO_NUMBER(str)` ‚Üí `CAST(str AS DECIMAL)` (ÏúÑ ÌïµÏã¨ Í∑úÏπô Ï†ÅÏö©)
- `INITCAP(str)` ‚Üí `CONCAT(UPPER(LEFT(str,1)), LOWER(SUBSTRING(str,2)))`

#### **LTRIM/RTRIM Special Conversion (Oracle 2-parameter ‚Üí MySQL)**
**Oracle LTRIM/RTRIM with character specification:**
- `LTRIM(string, chars)` ‚Üí `TRIM(LEADING chars FROM string)`
- `RTRIM(string, chars)` ‚Üí `TRIM(TRAILING chars FROM string)`
- `LTRIM(string)` ‚Üí `LTRIM(string)` (whitespace removal is identical)
- `RTRIM(string)` ‚Üí `RTRIM(string)` (whitespace removal is identical)

**Conversion Examples:**
```sql
-- Oracle
LTRIM('/path/to/file', '/') ‚Üí 'path/to/file'
RTRIM('text###', '#') ‚Üí 'text'

-- MySQL
TRIM(LEADING '/' FROM '/path/to/file') ‚Üí 'path/to/file'
TRIM(TRAILING '#' FROM 'text###') ‚Üí 'text'
```

**Important Notes:**
- Oracle's `LTRIM(CONCAT(...))` pattern causes syntax error in MySQL
- When 2nd parameter exists, must convert to `TRIM(LEADING/TRAILING ... FROM ...)` format
- Single parameter `LTRIM(string)` requires no conversion (MySQL identical support)
- **String Literals and Quote Escaping (Ï§ëÏöî Ï∞®Ïù¥Ï†ê)**:
  - **ÏûëÏùÄÎî∞Ïò¥Ìëú Ïù¥Ïä§ÏºÄÏù¥ÌîÑ**:
    - Oracle: `'Don''t'` (ÏûëÏùÄÎî∞Ïò¥Ìëú Îëê Í∞úÎ°ú Ïù¥Ïä§ÏºÄÏù¥ÌîÑ)
    - MySQL: `'Don\'t'` (Î∞±Ïä¨ÎûòÏãúÎ°ú Ïù¥Ïä§ÏºÄÏù¥ÌîÑ) ÎòêÎäî `'Don''t'` (Oracle Î∞©ÏãùÎèÑ ÏßÄÏõê)
  - **Í∂åÏû• Î≥ÄÌôò**: Oracle Î∞©Ïãù(`''`) Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ (MySQL Ìò∏Ìôò)
  - **Ï£ºÏùòÏÇ¨Ìï≠**: MySQL `sql_mode`Ïóê Îî∞Îùº ÎèôÏûëÏù¥ Îã¨ÎùºÏßà Ïàò ÏûàÏùå
    - `ANSI_QUOTES` Î™®Îìú: ÌÅ∞Îî∞Ïò¥ÌëúÍ∞Ä ÏãùÎ≥ÑÏûêÎ°ú Ï≤òÎ¶¨Îê®
    - `NO_BACKSLASH_ESCAPES` Î™®Îìú: Î∞±Ïä¨ÎûòÏãú Ïù¥Ïä§ÏºÄÏù¥ÌîÑ ÎπÑÌôúÏÑ±Ìôî
- **String Concatenation (ORACLE-COMPATIBLE)**:
  - Oracle: `str1 || str2` ‚Üí MySQL: `CONCAT(IFNULL(str1, ''), IFNULL(str2, ''))`
  - **Multiple concatenation**: `str1 || str2 || str3` ‚Üí `CONCAT(IFNULL(str1, ''), IFNULL(str2, ''), IFNULL(str3, ''))`
  - **With literals**: `'Hello ' || name || '!'` ‚Üí `CONCAT('Hello ', IFNULL(name, ''), '!')`
- **LENGTH with NULL (ORACLE-COMPATIBLE)**:
  - Oracle: `LENGTH(NULL)` ‚Üí `NULL`, `LENGTH('')` ‚Üí `NULL`
  - MySQL: `CASE WHEN (column IS NULL OR column = '') THEN NULL ELSE LENGTH(column) END`
  - **Note**: Oracle treats empty strings as NULL in LENGTH function

### Numeric Functions
**Note**: Most numeric functions have identical syntax in Oracle and MySQL
- `MOD(n, m)` ‚Üí `MOD(n, m)` (no conversion needed)
- `POWER(n, m)` ‚Üí `POW(n, m)` (function name change required)
- `SQRT(n)` ‚Üí `SQRT(n)` (no conversion needed)
- `ABS(n)` ‚Üí `ABS(n)` (no conversion needed)
- `CEIL(n)` ‚Üí `CEILING(n)` (function name change required)
- `FLOOR(n)` ‚Üí `FLOOR(n)` (no conversion needed)
- `ROUND(n, d)` ‚Üí `ROUND(n, d)` (no conversion needed)
- `TRUNC(n, d)` ‚Üí `TRUNCATE(n, d)` (function name change required)
- `SIGN(n)` ‚Üí `SIGN(n)` (no conversion needed)

### Conditional Functions
- `GREATEST(val1, val2, ...)` ‚Üí `GREATEST(val1, val2, ...)`
- `LEAST(val1, val2, ...)` ‚Üí `LEAST(val1, val2, ...)`
- `NULLIF(expr1, expr2)` ‚Üí `NULLIF(expr1, expr2)` (same syntax)

### Aggregate Functions with DISTINCT
- `COUNT(DISTINCT column)` ‚Üí `COUNT(DISTINCT column)` (same syntax)
- `SUM(DISTINCT column)` ‚Üí `SUM(DISTINCT column)` (same syntax)
- `AVG(DISTINCT column)` ‚Üí `AVG(DISTINCT column)` (same syntax)

### Additional Critical Oracle Functions
- `REPLACE(str, search, replace)` ‚Üí `REPLACE(str, search, replace)` (same syntax)
- `TRANSLATE(str, from_chars, to_chars)` ‚Üí Complex REPLACE chain or custom function
- `ASCII(char)` ‚Üí `ASCII(char)` (same syntax)
- `SOUNDEX(str)` ‚Üí `SOUNDEX(str)` (same syntax)
- `REVERSE(str)` ‚Üí `REVERSE(str)` (same syntax)
- `REPEAT(str, n)` ‚Üí `REPEAT(str, n)` (same syntax)
- `SPACE(n)` ‚Üí `SPACE(n)` (same syntax)
- `LEFT(str, len)` ‚Üí `LEFT(str, len)` (same syntax)

### Additional Oracle to MySQL Conversions
- `LISTAGG(column, delimiter)` ‚Üí `GROUP_CONCAT(column SEPARATOR delimiter)`
- `CHR(ASCII('A')+n)` ‚Üí `CHAR(ASCII('A')+n)`
- `v$session` ‚Üí `SHOW PROCESSLIST` or `information_schema.PROCESSLIST`
- **TO_DATE conversion**:
  - Date only: `TO_DATE('20250424', 'YYYYMMDD')` ‚Üí `STR_TO_DATE('20250424', '%Y%m%d')`
  - Date with time: `TO_DATE('2025-04-24 13:45:00', 'YYYY-MM-DD HH24:MI:SS')` ‚Üí `STR_TO_DATE('2025-04-24 13:45:00', '%Y-%m-%d %H:%i:%s')`
- **Date format patterns**:
  - Oracle `YYYY` ‚Üí MySQL `%Y`
  - Oracle `MM` ‚Üí MySQL `%m`
  - Oracle `DD` ‚Üí MySQL `%d`
  - Oracle `HH24` ‚Üí MySQL `%H`
  - Oracle `MI` ‚Üí MySQL `%i`
  - Oracle `SS` ‚Üí MySQL `%s`
- **Explicit type casting for comparisons**:
  - `SUBSTRING(date_column,1,8) = STR_TO_DATE('20250424', '%Y%m%d')`
- **INTERVAL for date calculations**:
  - `DATE_ADD(STR_TO_DATE(date, '%Y%m%d'), INTERVAL 3 DAY)`
- **Preserve special characters**: Maintain `&lt;` and `&gt;` in original SQL
- **Remove ORDER BY for aggregate functions without GROUP BY**:
  - `SELECT COUNT(empno) FROM emp ORDER BY reg_dttm` ‚Üí `SELECT COUNT(empno) FROM emp`
- **Oracle Hint Removal**:
  - Remove all Oracle optimizer hints from SQL
  - `SELECT /*+ FIRST_ROWS(10) */ * FROM table` ‚Üí `SELECT * FROM table`
  - `SELECT /*+ INDEX(t, idx_name) */ * FROM table t` ‚Üí `SELECT * FROM table t`
  - `SELECT /*+ USE_NL(a b) */ * FROM a, b` ‚Üí `SELECT * FROM a, b`
  - **Pattern**: Remove `/*+ ... */` comments entirely

### Oracle Date Literals
- `DATE '2023-01-01'` ‚Üí `'2023-01-01'`
- `TIMESTAMP '2023-01-01 12:00:00'` ‚Üí `'2023-01-01 12:00:00'`

### Oracle System Functions
- `USER` ‚Üí `USER()`
- `SYS_CONTEXT('USERENV', 'SESSION_USER')` ‚Üí `USER()`
- `USERENV('SESSIONID')` ‚Üí `CONNECTION_ID()`
- `SYS_GUID()` ‚Üí `UUID()`

### Advanced NULL Handling (ORACLE-COMPATIBLE)
- `NVL2(expr1, expr2, expr3)` ‚Üí `CASE WHEN (expr1 IS NOT NULL AND expr1 != '') THEN expr2 ELSE expr3 END`
- Mixed type COALESCE: `COALESCE(employee_id, 'N/A')` ‚Üí `CASE WHEN (employee_id IS NULL OR employee_id = '') THEN 'N/A' ELSE CAST(employee_id AS CHAR) END`
- Date COALESCE: `COALESCE(hire_date, '1900-01-01')` ‚Üí `CASE WHEN hire_date IS NULL THEN '1900-01-01' ELSE hire_date END`
- `USERENV('SESSIONID')` ‚Üí `CONNECTION_ID()`
- `SYS_GUID()` ‚Üí `gen_random_uuid()` (requires pgcrypto extension)

### Advanced NULL Handling
- `NVL2(expr1, expr2, expr3)` ‚Üí `CASE WHEN expr1 IS NOT NULL THEN expr2 ELSE expr3 END`
- Mixed type COALESCE: `COALESCE(employee_id, 'N/A')` ‚Üí `CASE WHEN employee_id IS NULL THEN 'N/A' ELSE CAST(employee_id AS CHAR) END`
- Date COALESCE: `COALESCE(hire_date, '1900-01-01')` ‚Üí `COALESCE(hire_date, CAST('1900-01-01' AS DATE))`

### IS NULL / IS NOT NULL Processing
- `column IS NULL` ‚Üí `column IS NULL` (same syntax, but behavior may differ)
- `column IS NOT NULL` ‚Üí `column IS NOT NULL` (same syntax)
- **Empty String vs NULL**:
  - Oracle: `'' IS NULL` returns TRUE
  - MySQL: `'' IS NULL` returns FALSE
  - **Conversion**: `column IS NULL` ‚Üí `(column IS NULL OR column = '')` (if Oracle empty string behavior needed)
- **NULL Concatenation**:
  - Oracle: `'Hello' || NULL` returns `'Hello'`
  - MySQL: `CONCAT('Hello', NULL)` returns `NULL`
  - **Conversion**: Use `CONCAT(IFNULL(str1, ''), IFNULL(str2, ''))` for Oracle behavior
- **NULL in Arithmetic**:
  - Both Oracle and MySQL: `5 + NULL` returns `NULL` (same behavior)
- **NULL Comparison**:
  - Both: `NULL = NULL` returns `NULL` (not TRUE)
  - Both: Use `IS NULL` or `IS NOT NULL` for NULL checks

### Stored Procedure Enhancement
- **MySQL Procedure Conversion**: Always use `CALL` format
- `{call PROC()}` ‚Üí `CALL PROC()`
- **Type Casting for Procedure Parameters**:
  - `#{param,mode=IN,jdbcType=DECIMAL}` ‚Üí `CAST(#{param,mode=IN,jdbcType=DECIMAL} AS numeric)`
  - `#{param,mode=IN,jdbcType=INTEGER}` ‚Üí `CAST(#{param,mode=IN,jdbcType=INTEGER} AS integer)`
  - `#{param,mode=IN,jdbcType=DATE}` ‚Üí `CAST(#{param,mode=IN,jdbcType=DATE} AS timestamp)`
  - `#{param,mode=IN,jdbcType=VARCHAR}` ‚Üí No CAST (keep as is)
  - OUT parameters: Keep original format without CAST

### DUAL Table Removal
- `SELECT 'Hello' FROM DUAL` ‚Üí `SELECT 'Hello'`
- `SELECT #{variable} FROM DUAL` ‚Üí `SELECT #{variable}`

### SubQuery Alias Requirements (CRITICAL - MySQL Mandatory)

#### **MySQL SubQuery Alias Rule**
**CRITICAL**: MySQL requires ALL subqueries in FROM clause and JOIN clauses to have aliases (Oracle allows without alias)

**Scope**: Only FROM clause and JOIN clause subqueries need aliases
- ‚úÖ FROM clause subqueries ‚Üí Alias REQUIRED
- ‚úÖ JOIN clause subqueries ‚Üí Alias REQUIRED  
- ‚ùå EXISTS/IN subqueries ‚Üí No alias needed
- ‚ùå Scalar subqueries in SELECT ‚Üí No alias needed
- ‚ùå WHERE clause subqueries ‚Üí No alias needed

#### **Conversion Rules**

**Pattern 1: FROM Clause Subquery**
```sql
-- Oracle
SELECT * FROM (SELECT col1, col2 FROM table1);

-- MySQL (Add unique alias)
SELECT * FROM (SELECT col1, col2 FROM table1) AS sub1;
```

**Pattern 2: JOIN Clause Subquery**
```sql
-- Oracle
SELECT e.*, d.dept_name 
FROM employees e
JOIN (SELECT dept_id, dept_name FROM departments WHERE active = 'Y') 
     ON e.dept_id = dept_id;

-- MySQL (Add unique alias)
SELECT e.*, d.dept_name 
FROM employees e
JOIN (SELECT dept_id, dept_name FROM departments WHERE active = 'Y') AS d
     ON e.dept_id = d.dept_id;
```

**Pattern 3: Nested FROM Subqueries (Unique aliases)**
```sql
-- Oracle
SELECT * FROM (
    SELECT * FROM (
        SELECT emp_id, name FROM employees
    ) WHERE emp_id > 100
);

-- MySQL (Each subquery needs UNIQUE alias)
SELECT * FROM (
    SELECT * FROM (
        SELECT emp_id, name FROM employees
    ) AS inner_sub WHERE emp_id > 100
) AS outer_sub;
```

**Pattern 4: Multiple Subqueries (Avoid duplicate aliases)**
```sql
-- Oracle
SELECT * FROM 
    (SELECT emp_id, name FROM employees) e1,
    (SELECT dept_id, dept_name FROM departments) d1;

-- MySQL (Ensure unique aliases)
SELECT * FROM 
    (SELECT emp_id, name FROM employees) AS emp_sub,
    (SELECT dept_id, dept_name FROM departments) AS dept_sub;
```

#### **Alias Naming Strategy (Duplicate Prevention)**
1. **Sequential numbering**: sub1, sub2, sub3...
2. **Descriptive + number**: emp_sub1, dept_sub2, order_sub3...
3. **Check existing aliases**: Scan query for existing table/column aliases
4. **Avoid conflicts**: Don't use names that match existing table aliases

#### **What NOT to alias (No change needed)**
```sql
-- EXISTS subquery (No alias needed)
SELECT * FROM employees e
WHERE EXISTS (SELECT 1 FROM departments WHERE id = e.dept_id);

-- Scalar subquery (No alias needed)  
SELECT emp_id, (SELECT COUNT(*) FROM orders WHERE emp_id = e.emp_id) as order_count
FROM employees e;

-- IN subquery (No alias needed)
SELECT * FROM employees 
WHERE dept_id IN (SELECT id FROM departments WHERE active = 'Y');
```

#### **Validation Checklist**
- [ ] All FROM clause subqueries have aliases
- [ ] All JOIN clause subqueries have aliases  
- [ ] All subquery aliases are unique within the query
- [ ] EXISTS/IN/Scalar subqueries left without aliases
- [ ] No alias conflicts with existing table names

### Package Handling (Convert to underscore naming)
- Convert Oracle package.procedure format to MySQL naming convention
- `PACKAGE_NAME.PROCEDURE_NAME` ‚Üí `PACKAGE_NAME_PROCEDURE_NAME`
- `PACKAGE_NAME.FUNCTION_NAME` ‚Üí `PACKAGE_NAME_FUNCTION_NAME`
- **Note**: Schema removal is handled in PHASE 1 - STRUCTURAL PROCESSING before MySQL conversion
- **Note**: MySQL doesn't support packages - use underscore naming convention to maintain logical grouping

### ResultMap Column Names
- Convert column attributes to lowercase in ResultMap tags
- `column="EMP_ID"` ‚Üí `column="emp_id"`
- Apply only to `<r>`, `<id>`, `<association>`, `<collection>` tags
## üîß MYSQL STORED PROCEDURE PROCESSING

### Identification and Preprocessing
- Scan for DECLARE sections in SQL content
- Identify variable declarations and initializations
- Preserve CDATA sections containing PL/SQL blocks
- **Priority**: Eliminate DECLARE blocks when possible, convert only when necessary

### Critical Requirements for MySQL Conversion
- **Temporary procedure first**: Most PL/SQL blocks should use temporary procedure pattern
- **User variables**: Use @variable syntax for simple cases
- **Eliminate when safe**: Only eliminate DECLARE blocks when logic is very simple
- **Never modify anything within #{...} brackets - treat as sacred tokens**
- **NEVER modify variable case**

### Conversion Strategies

#### **Strategy 1: Temporary Stored Procedure (PREFERRED)**
**Pattern: Create ‚Üí Execute ‚Üí Drop temporary procedure**

```sql
-- Oracle PL/SQL (Complex logic)
DECLARE
    v_emp_count NUMBER;
    v_dept_name VARCHAR2(100);
BEGIN
    SELECT COUNT(*), d.name INTO v_emp_count, v_dept_name
    FROM employees e, departments d 
    WHERE e.dept_id = d.id AND d.id = #{deptId};
    
    IF v_emp_count > 10 THEN
        INSERT INTO audit_log VALUES (v_dept_name, 'LARGE_DEPT', SYSDATE);
    END IF;
END;

-- MySQL Temporary Procedure (Create ‚Üí Execute ‚Üí Drop)
DELIMITER //
CREATE TEMPORARY PROCEDURE temp_proc_#{randomId}(IN dept_id INT)
BEGIN
    DECLARE v_emp_count INT;
    DECLARE v_dept_name VARCHAR(100);
    
    SELECT COUNT(*), d.name INTO v_emp_count, v_dept_name
    FROM employees e, departments d 
    WHERE e.dept_id = d.id AND d.id = dept_id;
    
    IF v_emp_count > 10 THEN
        INSERT INTO audit_log VALUES (v_dept_name, 'LARGE_DEPT', NOW());
    END IF;
END //
DELIMITER ;

CALL temp_proc_#{randomId}(#{deptId});
DROP PROCEDURE temp_proc_#{randomId};
```

**MyBatis XML Implementation:**
```xml
<!-- 2025-04-27 Amazon Q Developer : Converted PL/SQL block to temporary procedure pattern -->
<insert id="processComplexLogic" parameterType="map">
    <![CDATA[
        DELIMITER //
        CREATE TEMPORARY PROCEDURE temp_proc_${randomId}(IN dept_id INT)
        BEGIN
            DECLARE v_emp_count INT;
            DECLARE v_dept_name VARCHAR(100);
            
            SELECT COUNT(*), d.name INTO v_emp_count, v_dept_name
            FROM employees e, departments d 
            WHERE e.dept_id = d.id AND d.id = dept_id;
            
            IF v_emp_count > 10 THEN
                INSERT INTO audit_log VALUES (v_dept_name, 'LARGE_DEPT', NOW());
            END IF;
        END //
        DELIMITER ;
        
        CALL temp_proc_${randomId}(#{deptId});
        DROP PROCEDURE temp_proc_${randomId};
    ]]>
</insert>
```

**Key Requirements:**
- Use `TEMPORARY PROCEDURE` for automatic cleanup on session end
- Generate unique procedure name using `${randomId}` or timestamp
- Include complete Create ‚Üí Execute ‚Üí Drop sequence
- Handle parameter binding with MyBatis syntax

#### **Strategy 2: User Variables (Simple Cases)**
```sql
-- Oracle PL/SQL
DECLARE
    v_max_salary NUMBER;
BEGIN
    SELECT MAX(salary) INTO v_max_salary FROM employees;
    UPDATE employees SET bonus = salary * 0.1 WHERE salary = v_max_salary;
END;

-- MySQL User Variables
SET @max_salary = (SELECT MAX(salary) FROM employees);
UPDATE employees SET bonus = salary * 0.1 WHERE salary = @max_salary;
```

#### **Strategy 3: Elimination (Simple Cases Only)**
```sql
-- Oracle PL/SQL
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM employees WHERE dept_id = #{deptId};
    IF v_count > 0 THEN
        DELETE FROM departments WHERE id = #{deptId};
    END IF;
END;

-- MySQL (Eliminate DECLARE)
DELETE FROM departments 
WHERE id = #{deptId} 
  AND EXISTS (SELECT 1 FROM employees WHERE dept_id = #{deptId})
```

### MySQL Variable Declaration Rules

#### **Data Type Mapping**
- `NUMBER` ‚Üí `DECIMAL` or `INT`
- `VARCHAR2(n)` ‚Üí `VARCHAR(n)`
- `DATE` ‚Üí `DATETIME`
- `TIMESTAMP` ‚Üí `TIMESTAMP`
- `CLOB` ‚Üí `LONGTEXT`
- `BLOB` ‚Üí `LONGBLOB`

#### **%TYPE References (Convert to Explicit Types)**
```sql
-- Oracle
DECLARE
    v_emp_id    employees.employee_id%TYPE;

-- MySQL (Convert to explicit type based on table definition)
DECLARE v_emp_id INT;
```

### Error Handling Conversion

#### **Oracle Exception Handling**
```sql
-- Oracle
BEGIN
    -- SQL statements
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        NULL;
    WHEN OTHERS THEN
        RAISE;
END;
```

#### **MySQL Error Handling**
```sql
-- MySQL
BEGIN
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET @dummy = 1;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    -- SQL statements
END;
```

#### Data Type Mapping
- `VARCHAR2(n)` ‚Üí `VARCHAR`
- `CHAR(n)` ‚Üí `VARCHAR`
- `NUMBER` ‚Üí `NUMERIC`
- `NUMBER(p)` ‚Üí `INTEGER` (p <= 10)
- `NUMBER(p,s)` ‚Üí `NUMERIC(p,s)`
- `DATE` ‚Üí `TIMESTAMP`
- `CLOB` ‚Üí `TEXT`
- `BLOB` ‚Üí `BYTEA`
- `BOOLEAN` ‚Üí `BOOLEAN`
- `RAW` ‚Üí `BYTEA`
- `LONG RAW` ‚Üí `BYTEA`
- `TIMESTAMP` ‚Üí `TIMESTAMP`
- `TIMESTAMP WITH TIME ZONE` ‚Üí `TIMESTAMP WITH TIME ZONE`

#### Special Cases
- Remove VARCHAR length specifications
- Detailed NUMBER handling:
  - Plain `NUMBER` ‚Üí `NUMERIC`
  - `NUMBER(p)` ‚Üí `INTEGER` (p ‚â§ 10)
  - `NUMBER(p,s)` ‚Üí `NUMERIC(p,s)`

### Variable Management

#### Initialization Rules
- **NO initializations in DECLARE section**
- **ALL initializations MUST move to BEGIN section**

#### Bind Variable Handling
- Maintain MyBatis bind variable syntax: `#{variable_name}`
- Move all bind variable assignments to BEGIN section
- For %TYPE variables, do not add type casts to bind variables
- For explicitly typed variables, add appropriate type casts

### Error Handling
- `EXCEPTION WHEN` ‚Üí `EXCEPTION WHEN`
- `NO_DATA_FOUND` ‚Üí `NO_DATA_FOUND`
- `TOO_MANY_ROWS` ‚Üí `TOO_MANY_ROWS`
- `OTHERS` ‚Üí `OTHERS`

### Implementation Example

```sql
-- Original Oracle Code
DECLARE
    V_EMP_ID    EMPLOYEES.EMPLOYEE_ID%TYPE := #{EMPID};
    V_NAME      VARCHAR2(100) := #{EMPNAME};
    V_SALARY    NUMBER(10,2) := #{EMPSALARY};
    V_DEPTNAME  DEPT.DEPTNAME%TYPE := NVL(#{DEPTNAME}, '');
BEGIN
    -- logic
END;

-- Correct MySQL Conversion
DO $$
DECLARE
    V_EMP_ID    employees.employee_id%TYPE;
    V_NAME      VARCHAR;
    V_SALARY    NUMERIC(10,2);
    V_DEPTNAME  dept.deptname%TYPE;
BEGIN
    V_EMP_ID := #{EMPID};
    V_NAME := #{EMPNAME};
    V_SALARY := #{EMPSALARY};
    V_DEPTNAME := COALESCE(#{DEPTNAME}, '');
    -- logic
END;
END //
DELIMITER ;
```
## üî¨ ADVANCED CONVERSIONS (MySQL Optimized)

### Hierarchical Queries (CONNECT BY) - Ï†ÑÎ¨∏Í∞Ä Î≥ÄÌôò Í∞ÄÏù¥Îìú

#### **Î≥ÄÌôò ÏõêÏπô**
Oracle CONNECT BY Íµ¨Î¨∏ÏùÑ MySQL WITH RECURSIVE CTEÎ°ú Î≥ÄÌôòÌï† Îïå Îã§Ïùå ÏõêÏπôÏùÑ Ï†ÅÏö©:

1. **Í∏∞Î≥∏ Íµ¨Ï°∞ Î≥ÄÌôò**
   - `START WITH` ‚Üí CTEÏùò Anchor ÏøºÎ¶¨ WHERE Ï†à
   - `CONNECT BY PRIOR` ‚Üí CTEÏùò Recursive ÏøºÎ¶¨ JOIN Ï°∞Í±¥
   - `LEVEL` ‚Üí ÏàòÎèôÏúºÎ°ú Í≥ÑÏÇ∞Îêú Î†àÎ≤® Ïª¨Îüº

2. **Î≥µÏû°Ìïú Oracle Ìï®Ïàò Ï≤òÎ¶¨**
   - `SYS_CONNECT_BY_PATH` ‚Üí CONCATÏúºÎ°ú Í≤ΩÎ°ú Íµ¨ÏÑ±
   - `CONNECT_BY_ROOT` ‚Üí Anchor ÏøºÎ¶¨ÏóêÏÑú Î£®Ìä∏ Í∞í Ï†ÑÎã¨
   - `CONNECT_BY_ISLEAF` ‚Üí ÏÑúÎ∏åÏøºÎ¶¨Î°ú Î¶¨ÌîÑ ÎÖ∏Îìú ÌåêÎ≥Ñ
   - `ORDER SIBLINGS BY` ‚Üí ÏµúÏ¢Ö SELECTÏóêÏÑú ORDER BY Ï†ÅÏö©

3. **ÏÑ±Îä• Í≥†Î†§ÏÇ¨Ìï≠**
   - MySQL 8.0+ ÌïÑÏàò (WITH RECURSIVE ÏßÄÏõê)
   - Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄÎ•º ÏúÑÌïú ÍπäÏù¥ Ï†úÌïú Ï∂îÍ∞Ä Í∂åÏû•
   - ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞Ïùò Í≤ΩÏö∞ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Î†àÎ≤® Ï≤òÎ¶¨ Í≥†Î†§

#### **Í∏∞Î≥∏ Î≥ÄÌôò Ìå®ÌÑ¥**
```sql
-- Oracle Ìå®ÌÑ¥
SELECT columns, LEVEL
FROM table 
START WITH condition
CONNECT BY PRIOR parent_col = child_col;

-- MySQL Î≥ÄÌôò Ìå®ÌÑ¥
WITH RECURSIVE hierarchy AS (
    -- Anchor: START WITH Ï°∞Í±¥
    SELECT columns, 1 as level
    FROM table 
    WHERE condition
    
    UNION ALL
    
    -- Recursive: CONNECT BY Ï°∞Í±¥
    SELECT t.columns, h.level + 1
    FROM table t
    JOIN hierarchy h ON t.child_col = h.parent_col
)
SELECT columns, level FROM hierarchy;
```

#### **Ï†ÑÎ¨∏Í∞Ä ÌåêÎã® ÌïÑÏöî ÏºÄÏù¥Ïä§**
- Î≥µÏû°Ìïú Í≥ÑÏ∏µ Íµ¨Ï°∞ (Îã§Ï§ë Î£®Ìä∏, ÏàúÌôò Ï∞∏Ï°∞)
- Oracle ÌäπÌôî Ìï®Ïàò Ï°∞Ìï© ÏÇ¨Ïö©
- ÏÑ±Îä• ÏµúÏ†ÅÌôîÍ∞Ä Ï§ëÏöîÌïú ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞
- MySQL 8.0 ÎØ∏Îßå ÌôòÍ≤Ω (ÎåÄÏïà ÏÜîÎ£®ÏÖò ÌïÑÏöî)

### ROWNUM Conversion Patterns

#### **Simple ROWNUM (Í∂åÏû•)**
- `WHERE ROWNUM <= n` ‚Üí `LIMIT n`
- `WHERE ROWNUM = 1` ‚Üí `LIMIT 1`
- `WHERE ROWNUM < n` ‚Üí `LIMIT n-1`

#### **Complex ROWNUM (Pagination) - LIMIT/OFFSET ÏÇ¨Ïö©**
```sql
-- Oracle nested ROWNUM (ÌëúÏ§Ä ÌéòÏù¥Ïßï Ìå®ÌÑ¥)
SELECT * FROM (
    SELECT ROWNUM as rn, a.* FROM (
        SELECT * FROM table ORDER BY column
    ) a WHERE ROWNUM <= 20
) WHERE rn > 10;

-- MySQL LIMIT OFFSET (Í∂åÏû•)
SELECT * FROM table ORDER BY column LIMIT 10 OFFSET 10;
```

#### **ROWNUMÏùÑ ROW_NUMBER()Î°ú Î≥ÄÌôòÌïòÎäî Í≤ΩÏö∞ (Ï£ºÏùò ÌïÑÏöî)**
‚ö†Ô∏è **Îã§Ïùå Í≤ΩÏö∞ÏóêÎßå ROW_NUMBER() ÏÇ¨Ïö©:**
- ROWNUMÏù¥ SELECT Ï†àÏóêÏÑú Ïª¨ÎüºÏúºÎ°ú ÏÇ¨Ïö©ÎêòÎäî Í≤ΩÏö∞
- Î≥µÏû°Ìïú Ï°∞Í±¥Î¨∏ÏóêÏÑú Ìñâ Î≤àÌò∏Í∞Ä ÌïÑÏöîÌïú Í≤ΩÏö∞
- Î∂ÑÏÑù Ìï®ÏàòÏôÄ Ìï®Íªò ÏÇ¨Ïö©ÎêòÎäî Í≤ΩÏö∞

```sql
-- Oracle: ROWNUMÏùÑ Ïª¨ÎüºÏúºÎ°ú ÏÇ¨Ïö©
SELECT ROWNUM as row_seq, emp_id, name 
FROM employees 
WHERE department_id = 10;

-- MySQL: ROW_NUMBER() ÏÇ¨Ïö©
SELECT ROW_NUMBER() OVER (ORDER BY emp_id) as row_seq, emp_id, name 
FROM employees 
WHERE department_id = 10;
```

#### **ÏûòÎ™ªÎêú Î≥ÄÌôò ÏòàÏãú (ÌîºÌï¥Ïïº Ìï† Ìå®ÌÑ¥)**
```sql
-- ‚ùå ÏûòÎ™ªÎêú Î≥ÄÌôò
-- Oracle
SELECT * FROM employees WHERE ROWNUM <= 10;
-- MySQL (ÏûòÎ™ªÎê®)
SELECT * FROM (
    SELECT ROW_NUMBER() OVER (ORDER BY emp_id) as rn, e.*
    FROM employees e
) ranked WHERE rn <= 10;

-- ‚úÖ Ïò¨Î∞îÎ•∏ Î≥ÄÌôò
-- MySQL (Í∂åÏû•)
SELECT * FROM employees LIMIT 10;
```

### MERGE Statement Conversion

#### **Oracle MERGE**
```sql
MERGE INTO target_table t
USING source_table s ON (t.id = s.id)
WHEN MATCHED THEN
    UPDATE SET t.name = s.name, t.updated_date = SYSDATE
WHEN NOT MATCHED THEN
    INSERT (id, name, created_date) VALUES (s.id, s.name, SYSDATE);
```

#### **MySQL Equivalent (INSERT ... ON DUPLICATE KEY UPDATE)**
```sql
INSERT INTO target_table (id, name, created_date, updated_date)
SELECT id, name, NOW(), NOW() FROM source_table
ON DUPLICATE KEY UPDATE 
    name = VALUES(name),
    updated_date = NOW();
```

### Window Functions (MySQL 8.0+) - Ï†ÑÎ¨∏Í∞Ä ÌåêÎã® ÌïÑÏöî

#### **MySQL Window Function Ï†úÏïΩÏÇ¨Ìï≠**
MySQLÏùÄ OracleÎ≥¥Îã§ Window Function Íµ¨Î¨∏Ïù¥ ÏóÑÍ≤©ÌïòÎØÄÎ°ú Ï†ÑÎ¨∏Í∞Ä ÌåêÎã® ÌïÑÏöî:

**Ï£ºÏöî Ï∞®Ïù¥Ï†ê:**
1. **FRAME Ï†à Ï†úÏïΩ**: MySQLÏùÄ ÏùºÎ∂Ä FRAME Ï†à Ï°∞Ìï© ÏßÄÏõê ÏïàÌï®
2. **Ï§ëÏ≤© Window Function**: MySQLÏóêÏÑú Ï†úÌïúÏ†Å ÏßÄÏõê
3. **ORDER BY ÌïÑÏàò**: ÏùºÎ∂Ä Ìï®ÏàòÏóêÏÑú ORDER BY ÏÉùÎûµ Î∂àÍ∞Ä
4. **NULL Ï≤òÎ¶¨**: OracleÍ≥º Îã§Î•∏ NULL Ï≤òÎ¶¨ Î∞©Ïãù

#### **Ï†ÑÎ¨∏Í∞Ä ÌåêÎã® Í∏∞Ï§Ä**

**Í∏∞Î≥∏ Window Function (ÏßÅÏ†ë Î≥ÄÌôò Í∞ÄÎä•)**
```sql
-- Oracle ‚Üí MySQL (ÎèôÏùº)
ROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary)
RANK() OVER (PARTITION BY dept ORDER BY salary)
DENSE_RANK() OVER (PARTITION BY dept ORDER BY salary)
LAG(salary, 1) OVER (PARTITION BY dept ORDER BY salary)
LEAD(salary, 1) OVER (PARTITION BY dept ORDER BY salary)
```

**Î≥µÏû°Ìïú ÏºÄÏù¥Ïä§ (Ï†ÑÎ¨∏Í∞Ä ÌåêÎã® ÌïÑÏöî)**
- Oracle ÌäπÌôî Î∂ÑÏÑù Ìï®Ïàò (RATIO_TO_REPORT, PERCENT_RANK Îì±)
- Î≥µÏû°Ìïú FRAME Ï†à (RANGE BETWEEN, ROWS BETWEEN Ï°∞Ìï©)
- Ï§ëÏ≤©Îêú Window Function
- KEEP/DENSE_RANK FIRST/LAST Íµ¨Î¨∏

#### **Î≥ÄÌôò ÏõêÏπô**
1. **Îã®Ïàú ÏºÄÏù¥Ïä§**: ÏßÅÏ†ë Î≥ÄÌôò
2. **Î≥µÏû°Ìïú ÏºÄÏù¥Ïä§**: ÏÑúÎ∏åÏøºÎ¶¨ÎÇò CTEÎ°ú Î∂ÑÌï¥
3. **ÏßÄÏõê ÏïàÎêòÎäî Ìï®Ïàò**: MySQL Ï°∞Ìï© Ìï®ÏàòÎ°ú Íµ¨ÌòÑ
4. **ÏÑ±Îä• Í≥†Î†§**: MySQL ÏµúÏ†ÅÌôî Ìå®ÌÑ¥ Ï†ÅÏö©

### JSON Functions (MySQL 5.7+)

#### **Oracle JSON vs MySQL JSON**
```sql
-- Oracle JSON_VALUE
SELECT JSON_VALUE(json_column, '$.name') FROM table_name;

-- MySQL JSON_EXTRACT
SELECT JSON_EXTRACT(json_column, '$.name') FROM table_name;
-- or
SELECT json_column->>'$.name' FROM table_name;
```

### Performance Optimization Patterns (MySQL 8.0+)

#### **Window Functions (Full Support)**
```sql
-- Oracle Analytical Functions ‚Üí MySQL 8.0+ (Same syntax)
SELECT employee_id, salary,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank_in_dept,
       RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank,
       DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as dense_rank,
       LAG(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as prev_salary,
       LEAD(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as next_salary,
       FIRST_VALUE(salary) OVER (PARTITION BY department_id ORDER BY salary DESC) as max_salary,
       LAST_VALUE(salary) OVER (PARTITION BY department_id ORDER BY salary DESC 
                                RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as min_salary
FROM employees;
```

#### **CTE (Common Table Expressions)**
```sql
-- Oracle WITH clause ‚Üí MySQL 8.0+ WITH clause (Same syntax)
WITH dept_summary AS (
    SELECT department_id, AVG(salary) as avg_salary, COUNT(*) as emp_count
    FROM employees
    GROUP BY department_id
),
high_salary_depts AS (
    SELECT department_id FROM dept_summary WHERE avg_salary > 50000
)
SELECT e.employee_id, e.name, e.salary
FROM employees e
JOIN high_salary_depts hsd ON e.department_id = hsd.department_id;
```

#### **JSON Functions (MySQL 8.0+)**
```sql
-- Oracle JSON handling ‚Üí MySQL 8.0+ JSON functions
-- JSON_VALUE ‚Üí JSON_UNQUOTE(JSON_EXTRACT())
SELECT JSON_UNQUOTE(JSON_EXTRACT(json_column, '$.name')) as name,
       json_column->>'$.email' as email,
       JSON_OBJECT('id', employee_id, 'name', name, 'salary', salary) as emp_json
FROM employees;
```

#### **Regular Expressions (MySQL 8.0+)**
```sql
-- Oracle REGEXP functions ‚Üí MySQL 8.0+ REGEXP functions
SELECT employee_id,
       CASE WHEN email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' 
            THEN 'Valid' ELSE 'Invalid' END as email_status,
       REGEXP_REPLACE(phone, '[^0-9]', '') as clean_phone,
       REGEXP_SUBSTR(address, '[0-9]+') as street_number  -- Ï†ÑÎ¨∏Í∞Ä ÌåêÎã®: Î≥µÏû°Ìïú Ìå®ÌÑ¥ÏùÄ Í≤ÄÌÜ† ÌïÑÏöî
FROM employees;
```

### Advanced Query Optimization

#### **Index Hints (MySQL 8.0+)**
```sql
-- Oracle hints (Remove) ‚Üí MySQL index hints
SELECT * FROM employees 
USE INDEX (idx_department_salary)
WHERE department_id = #{deptId} 
ORDER BY salary DESC;
```

### MyBatis + MySQL 8.0+ Optimization Patterns

#### **Dynamic SQL with MySQL Features**
```xml
<!-- Leverage MySQL 8.0+ window functions in MyBatis -->
<select id="getEmployeeRanking" resultType="EmployeeRank">
    SELECT employee_id, name, salary,
           ROW_NUMBER() OVER (
               <if test="partitionBy != null">
                   PARTITION BY ${partitionBy}
               </if>
               ORDER BY 
               <choose>
                   <when test="orderBy == 'salary'">salary DESC</when>
                   <when test="orderBy == 'hire_date'">hire_date DESC</when>
                   <otherwise>employee_id</otherwise>
               </choose>
           ) as ranking
    FROM employees
    <where>
        <if test="departmentId != null">
            AND department_id = #{departmentId}
        </if>
        <if test="minSalary != null">
            AND salary >= #{minSalary}
        </if>
    </where>
</select>
```

#### **Batch Operations with MySQL**
```xml
<!-- MySQL batch insert with ON DUPLICATE KEY UPDATE -->
<insert id="batchUpsertEmployees" parameterType="list">
    INSERT INTO employees (employee_id, name, email, salary, department_id)
    VALUES
    <foreach collection="list" item="emp" separator=",">
        (#{emp.employeeId}, #{emp.name}, #{emp.email}, #{emp.salary}, #{emp.departmentId})
    </foreach>
    ON DUPLICATE KEY UPDATE
        name = VALUES(name),
        email = VALUES(email),
        salary = VALUES(salary),
        department_id = VALUES(department_id),
        updated_date = NOW()
</insert>
```

#### **JSON Column Handling**
```xml
<!-- MySQL JSON column operations -->
<select id="searchEmployeesBySkills" resultType="Employee">
    SELECT employee_id, name, 
           JSON_UNQUOTE(JSON_EXTRACT(skills_json, '$.programming')) as programming_skills
    FROM employees
    WHERE JSON_CONTAINS(skills_json, JSON_OBJECT('level', #{skillLevel}))
       OR JSON_EXTRACT(skills_json, '$.years_experience') >= #{minExperience}
</select>
```

#### **Recursive CTE in MyBatis**
```xml
<!-- Hierarchical data with MySQL 8.0+ recursive CTE -->
<select id="getEmployeeHierarchy" resultType="EmployeeHierarchy">
    WITH RECURSIVE emp_hierarchy AS (
        -- Root level employees
        SELECT employee_id, name, manager_id, 1 as level,
               CAST(name AS CHAR(1000)) as path
        FROM employees 
        WHERE manager_id IS NULL
        
        UNION ALL
        
        -- Child employees
        SELECT e.employee_id, e.name, e.manager_id, eh.level + 1,
               CONCAT(eh.path, ' -> ', e.name) as path
        FROM employees e
        JOIN emp_hierarchy eh ON e.manager_id = eh.employee_id
        WHERE eh.level < #{maxLevel}
    )
    SELECT employee_id, name, manager_id, level, path
    FROM emp_hierarchy
    ORDER BY level, name
</select>
```

### MySQL 8.0+ Performance Best Practices

#### **Optimized Pagination**
```xml
<!-- Use LIMIT OFFSET with covering index -->
<select id="getEmployeesPaginated" resultType="Employee">
    SELECT e.employee_id, e.name, e.salary, e.department_id
    FROM employees e
    <where>
        <if test="departmentId != null">
            AND e.department_id = #{departmentId}
        </if>
        <if test="lastEmployeeId != null">
            AND e.employee_id > #{lastEmployeeId}
        </if>
    </where>
    ORDER BY e.employee_id
    LIMIT #{pageSize}
</select>
```

#### **Efficient Counting**
```xml
<!-- Use window functions for count with data -->
<select id="getEmployeesWithCount" resultType="EmployeeWithCount">
    SELECT employee_id, name, salary,
           COUNT(*) OVER() as total_count
    FROM employees
    <where>
        <if test="searchTerm != null">
            AND (name LIKE CONCAT('%', #{searchTerm}, '%') 
                 OR email LIKE CONCAT('%', #{searchTerm}, '%'))
        </if>
    </where>
    ORDER BY name
    LIMIT #{pageSize} OFFSET #{offset}
</select>
```

#### **Index Hints Conversion**
```sql
-- Oracle Hints (Remove)
SELECT /*+ INDEX(emp, emp_idx_name) */ * FROM employees emp;

-- MySQL Index Hints
SELECT * FROM employees USE INDEX (emp_idx_name);
```

#### **Optimizer Hints**
```sql
-- Oracle (Remove all optimizer hints)
SELECT /*+ FIRST_ROWS(10) */ * FROM table;

-- MySQL (Use appropriate syntax or remove)
SELECT * FROM table;
```

-- MySQL LIMIT/OFFSET
SELECT * FROM table 
ORDER BY column 
LIMIT 10 OFFSET 10;
```

#### ROWNUM Î≥ÄÌôò Ïö∞ÏÑ†ÏàúÏúÑ
1. **1ÏàúÏúÑ: LIMIT/OFFSET ÏÇ¨Ïö©** (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
   - Îã®Ïàú Ìñâ Ï†úÌïú: `WHERE ROWNUM <= n` ‚Üí `LIMIT n`
   - ÌéòÏù¥Ïßï: Oracle nested ROWNUM ‚Üí `LIMIT n OFFSET m`

2. **2ÏàúÏúÑ: ROW_NUMBER() ÏÇ¨Ïö©** (ÌäπÏàòÌïú Í≤ΩÏö∞Îßå)
   - ROWNUMÏù¥ SELECT Ï†à Ïª¨ÎüºÏúºÎ°ú ÌïÑÏöîÌïú Í≤ΩÏö∞
   - Î≥µÏû°Ìïú Î∂ÑÏÑù ÏøºÎ¶¨ÏóêÏÑú Ìñâ Î≤àÌò∏Í∞Ä ÌïÑÏöîÌïú Í≤ΩÏö∞
   - Ï£ºÏùò: ÏÑ±Îä•Ïù¥ LIMITÎ≥¥Îã§ Îñ®Ïñ¥Ïßà Ïàò ÏûàÏùå

### MERGE Statements
Convert to INSERT ... ON CONFLICT:
```sql
-- Oracle MERGE
MERGE INTO target USING source ON (condition)
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT ...

-- MySQL
INSERT INTO target SELECT ... FROM source
ON CONFLICT (key) DO UPDATE SET ...
```

### Regular Expressions - Ï†ÑÎ¨∏Í∞Ä ÌåêÎã® ÌïÑÏöî

#### **Í∏∞Î≥∏ Î≥ÄÌôò**
- `REGEXP_LIKE(source, pattern)` ‚Üí `source REGEXP pattern`
- `REGEXP_REPLACE(source, pattern, replacement)` ‚Üí `REGEXP_REPLACE(source, pattern, replacement)`

#### **REGEXP_SUBSTR - ÌååÎùºÎØ∏ÌÑ∞ Ï∞®Ïù¥ Ï£ºÏùò**
‚ö†Ô∏è **Oracle vs MySQL ÌååÎùºÎØ∏ÌÑ∞ ÏàúÏÑú Î∞è Í∏∞Îä• Ï∞®Ïù¥:**

**Oracle REGEXP_SUBSTR:**
```sql
REGEXP_SUBSTR(source, pattern [, position [, occurrence [, match_param [, subexpr]]]])
```

**MySQL REGEXP_SUBSTR (8.0+):**
```sql
REGEXP_SUBSTR(expr, pattern [, pos [, occurrence [, match_type]]])
```

**Ï£ºÏöî Ï∞®Ïù¥Ï†ê:**
1. **subexpr ÌååÎùºÎØ∏ÌÑ∞**: OracleÏùò ÏÑúÎ∏åÌëúÌòÑÏãù Ï∂îÏ∂ú Í∏∞Îä•Ïù¥ MySQLÏóêÏÑú Ï†úÌïúÏ†Å
2. **match_param vs match_type**: ÌîåÎûòÍ∑∏ ÌòïÏãùÏù¥ Îã§Î¶Ñ
3. **Í∏∞Î≥∏ ÎèôÏûë**: ÏùºÎ∂Ä Ï†ïÍ∑úÏãù ÏóîÏßÑ Ï∞®Ïù¥

**Ï†ÑÎ¨∏Í∞Ä ÌåêÎã® Í∏∞Ï§Ä:**
- Îã®Ïàú Ìå®ÌÑ¥: ÏßÅÏ†ë Î≥ÄÌôò Í∞ÄÎä•
- Î≥µÏû°Ìïú ÏÑúÎ∏åÌëúÌòÑÏãù: MySQL ÎåÄÏïà Î°úÏßÅ ÌïÑÏöî
- Í≥†Í∏â Îß§Ïπò ÏòµÏÖò: Ï†ÑÎ¨∏Í∞Ä ÌåêÎã®ÏúºÎ°ú Íµ¨ÌòÑ

#### **Í∏∞ÌÉÄ Ï†ïÍ∑úÏãù Ìï®Ïàò**
- `REGEXP_INSTR(source, pattern)` ‚Üí **Ï†ÑÎ¨∏Í∞Ä ÌåêÎã® ÌïÑÏöî** (MySQL ÏßÅÏ†ë ÏßÄÏõê ÏïàÌï®)
  - ÎåÄÏïà: `LOCATE()` + `REGEXP` Ï°∞Ìï© ÎòêÎäî ÏÇ¨Ïö©Ïûê Ï†ïÏùò Ìï®Ïàò

## üéØ Î≥ÄÌôò Í∑úÏπô Ï†ÅÏö© Ïö∞ÏÑ†ÏàúÏúÑ

### 1Îã®Í≥Ñ: ÌïµÏã¨ 20Í∞ú Í∑úÏπô (ÌïÑÏàò)
ÏúÑÏùò **Essential 20 MySQL Conversions** Î®ºÏ†Ä Ï†ÅÏö©

### 2Îã®Í≥Ñ: Ìï®ÏàòÎ≥Ñ ÏÉÅÏÑ∏ Í∑úÏπô  
Í∞Å ÏÑπÏÖòÏùò ÏÉÅÏÑ∏ Î≥ÄÌôò Í∑úÏπô Ï†ÅÏö©

### 3Îã®Í≥Ñ: Ï†ÑÎ¨∏Í∞Ä ÌåêÎã® ÏòÅÏó≠
- Î≥µÏû°Ìïú CONNECT BY ‚Üí WITH RECURSIVE
- Í≥†Í∏â Window Functions  
- Î≥µÏû°Ìïú Ï†ïÍ∑úÏãù Ìï®Ïàò
- Oracle ÌäπÌôî Íµ¨Î¨∏

### 4Îã®Í≥Ñ: Í≤ÄÏ¶ù Î∞è Ï£ºÏùòÏÇ¨Ìï≠
Î≥ÄÌôò ÌõÑ ÌïÑÏàò Í≤ÄÏ¶ù Ìè¨Ïù∏Ìä∏ ÌôïÏù∏

## üéØ EXPERT-LEVEL CONVERSION GUIDANCE

### Rule Application Priority (STRICT HIERARCHY)
**Priority 1 (HIGHEST)**: Explicit rules documented in this file
**Priority 2 (MEDIUM)**: Database expert knowledge for undocumented Oracle constructs  
**Priority 3 (LOWEST)**: Conservative fallback (preserve original with comments)

### For Oracle Constructs Not Explicitly Listed
**ONLY apply expert knowledge when Priority 1 rules don't exist**

When encountering Oracle SQL constructs, functions, or syntax patterns that are not explicitly documented in the above rules:

#### **Step 1: Check Explicit Rules First**
- Scan all documented conversion rules in this file
- If explicit rule exists ‚Üí Apply it (Priority 1)
- If no explicit rule exists ‚Üí Proceed to Step 2

#### **Step 2: Apply Database Expert Knowledge** (Priority 2)
Apply **database expert knowledge** to provide appropriate MySQL equivalents:

#### **Conversion Principles:**
1. **Semantic Equivalence**: Ensure the MySQL conversion maintains the same logical behavior as the original Oracle construct
2. **Performance Consideration**: Choose MySQL alternatives that provide similar or better performance characteristics
3. **Standards Compliance**: Prefer ANSI SQL standard approaches when available in MySQL
4. **MySQL Best Practices**: Utilize MySQL-specific features when they provide superior functionality

#### **Common Expert Conversion Patterns:**

**Oracle Aggregate Functions:**
- Apply MySQL aggregate function equivalents with proper syntax
- Consider `GROUP_CONCAT()` for string concatenation aggregates
- Use MySQL 8.0+ window functions for advanced aggregation

**Oracle Analytical Functions - Ï†ÑÎ¨∏Í∞Ä ÌåêÎã® Ï†ÅÏö©:**
- Í∏∞Î≥∏ Window Function: ÏßÅÏ†ë Î≥ÄÌôò (ROW_NUMBER, RANK, LAG, LEAD Îì±)
- Oracle ÌäπÌôî Ìï®Ïàò: MySQL Ï°∞Ìï©ÏúºÎ°ú Íµ¨ÌòÑ (Ï†ÑÎ¨∏Í∞Ä ÌåêÎã®)
- Î≥µÏû°Ìïú FRAME Ï†à: ÏÑúÎ∏åÏøºÎ¶¨ Î∂ÑÌï¥ ÎòêÎäî ÎåÄÏïà Î°úÏßÅ (Ï†ÑÎ¨∏Í∞Ä ÌåêÎã®)
- ÏÑ±Îä• ÏµúÏ†ÅÌôî: MySQL ÌäπÏÑ±Ïóê ÎßûÎäî Íµ¨Ï°∞ Î≥ÄÍ≤Ω (Ï†ÑÎ¨∏Í∞Ä ÌåêÎã®)

**Oracle System Functions:**
- Map Oracle system functions to appropriate MySQL system information functions
- Use `USER()`, `DATABASE()`, `VERSION()` etc. as needed
- Convert Oracle metadata queries to MySQL information_schema queries

**Oracle Data Type Functions:**
- Convert Oracle type conversion functions to MySQL casting syntax
- Use `CAST(value AS type)` as appropriate
- Handle Oracle-specific data types with MySQL equivalents

**Oracle PL/SQL Constructs:**
- Convert Oracle PL/SQL blocks to MySQL stored procedure syntax
- Adapt Oracle exception handling to MySQL exception syntax
- Transform Oracle cursor operations to MySQL cursor equivalents

#### **Documentation Requirement:**
When applying expert-level conversions, add comments documenting the transformation:
```xml
<!-- YYYY-MM-DD Amazon Q Developer : Expert conversion - Oracle [construct] to MySQL [equivalent] -->
```

#### **Fallback Strategy:**
If no suitable MySQL equivalent exists:
1. **Document the limitation** with detailed comments
2. **Suggest alternative approaches** using MySQL features
3. **Maintain functional equivalence** even if syntax differs significantly
## ‚öôÔ∏è PROCESSING INSTRUCTIONS

### Step-by-Step Process
1. **Parse Input XML**: Extract ALL SQL content while preserving XML structure
2. **Apply Conversion Rules**: Execute all MySQL transformation rules
3. **Process PL/SQL DECLARE**: Handle DECLARE sections with MySQL conversion strategies
4. **Validate Results**: Ensure XML structure and MyBatis functionality preserved

### Comment Requirements

#### Unified XML Comment Approach
**All comments are now XML comments placed above SQL definition tags**

#### Comment Location
- Inside `<mapper>` tag
- Above SQL definition tags (select, insert, update, delete, sql)

#### Comment Format
```xml
<!-- YYYY-MM-DD Amazon Q Developer : description -->
```

#### Comment Content Guidelines

**Type 1: General Conversion (Focus on MySQL changes)**
```xml
<!-- 2025-04-27 Amazon Q Developer : Applied LIMIT clause, converted date functions to STR_TO_DATE -->
<select id="getEmployeeList">
```

**Type 2: Complex/Impossible Conversions (TODO format)**
```xml
<!-- 2025-04-27 Amazon Q Developer : TODO: XMLELEMENT replacement needed - Consider JSON functions or CONCAT -->
<select id="getXmlData">
    <![CDATA[
        SELECT emp_id, name,
               NULL as xml_data  -- Temporary dummy value
        FROM employees
    ]]>
</select>
```

**Type 3: Multiple Issues Combined**
```xml
<!-- 2025-04-27 Amazon Q Developer : Applied LEFT JOIN conversion, TODO: DBMS_LOB.SUBSTR replacement needed - Change to SUBSTRING function -->
<select id="getComplexData">
```

#### Content Rules
**DO (Focus on MySQL changes):**
- "Applied LIMIT clause for pagination"
- "Converted to LEFT JOIN syntax" 
- "Added IFNULL function conversion"
- "TODO: XMLELEMENT replacement needed - Consider JSON functions"

**DON'T (Avoid Oracle references):**
- ‚ùå "Converted Oracle NVL to MySQL IFNULL"
- ‚ùå "Replaced Oracle SYSDATE with MySQL NOW()"
- ‚ùå "Removed Oracle DUAL table"

#### Processing Guidelines
1. **Single XML comment per SQL tag**: One consolidated comment above each SQL definition
2. **Combine all changes**: Include both successful conversions and TODO items in one comment
3. **Preserve TODO format**: Keep "TODO: [Function Name] replacement needed - [Specific replacement approach]" structure
4. **No SQL comments**: All documentation moves to XML comments at the top

### Logging Requirements
- "Applied MySQL conversion: [function_name] ‚Üí [mysql_equivalent]"
- "Processed PL/SQL block: [conversion_strategy]"
- "Converted sequence: [seq_name] ‚Üí AUTO_INCREMENT"

### Final Error Checks

#### Structure Checks
- **XML tag structure damage**: Verify all opening/closing tags match
- **CDATA section integrity**: Ensure `<![CDATA[` and `]]>` pairs are intact
- **Dynamic query tags**: Verify `<if>`, `<choose>`, `<foreach>` tags are preserved
- **Attribute preservation**: Maintain all XML attributes (id, parameterType, resultType, etc.)

#### Functional Checks
- **Dynamic query tags operation**: Ensure flow control tags work correctly
- **Variable binding syntax accuracy**: Verify `#{variable}` and `${variable}` patterns are intact
- **ResultMap integrity**: Check that resultMap references and column mappings are valid
- **Parameter mapping**: Ensure parameterMap and parameter tags function correctly

#### SQL Syntax Validation
- **MySQL compatibility**: Verify converted SQL is valid MySQL syntax
- **Bind variable preservation**: Ensure MyBatis bind variables are not corrupted
- **CDATA SQL conversion**: Confirm SQL within CDATA sections is properly converted

## üöÄ PERFORMANCE CONSIDERATIONS

- Use MySQL 8.0+ features for optimal performance
- Leverage window functions instead of complex subqueries
- Apply efficient pagination with LIMIT OFFSET
- Use AUTO_INCREMENT instead of sequences for better performance

## ‚ö†Ô∏è Î≥ÄÌôò ÏûëÏóÖ Ïãú ÌïµÏã¨ Ï£ºÏùòÏÇ¨Ìï≠

### ÌïÑÏàò Ï§ÄÏàò ÏõêÏπô
- **ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ Ïú†ÏßÄ**: Ìï®Ïàò Î≥ÄÌôò Ïãú ÏõêÎûò ÏùòÎèÑ Î≥¥Ï°¥
- **ÌååÎùºÎØ∏ÌÑ∞ Î∞îÏù∏Îî© Ïú†ÏßÄ**: MyBatis `#{...}` Íµ¨Î¨∏ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
- **XML Íµ¨Ï°∞ Î≥¥Ï°¥**: MyBatis XML ÌÉúÍ∑∏ Íµ¨Ï°∞ Î≥ÄÍ≤Ω Í∏àÏßÄ
- **Ï†êÏßÑÏ†Å ÏàòÏ†ï**: Ìïú Î≤àÏóê Î™®Îì† Í≤ÉÏùÑ Î∞îÍæ∏ÏßÄ ÎßêÍ≥† Îã®Í≥ÑÎ≥Ñ ÏàòÏ†ï
- **ÌÖåÏä§Ìä∏ ÌïÑÏàò**: Í∞Å ÏàòÏ†ï ÌõÑ Î∞òÎìúÏãú ÎèôÏûë ÌôïÏù∏

### Î≥ÄÌôò Ïãú Í≤ÄÏ¶ù Ìè¨Ïù∏Ìä∏
1. **SQL Í≤∞Í≥º ÎèôÏùºÏÑ±**: OracleÍ≥º MySQLÏóêÏÑú ÎèôÏùºÌïú Í≤∞Í≥º Î∞òÌôò ÌôïÏù∏
2. **ÏÑ±Îä• ÏòÅÌñ•ÎèÑ**: Î≥ÄÌôò ÌõÑ ÏøºÎ¶¨ ÏÑ±Îä• Ï†ÄÌïò Ïó¨Î∂Ä Ï†êÍ≤Ä
3. **Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ Ìò∏ÌôòÏÑ±**: Ïª¨Îüº ÌÉÄÏûÖ Î≥ÄÌôòÏúºÎ°ú Ïù∏Ìïú Îç∞Ïù¥ÌÑ∞ ÏÜêÏã§ Î∞©ÏßÄ
4. **Ìä∏ÎûúÏû≠ÏÖò ÎèôÏûë**: Ïª§Î∞ã/Î°§Î∞± ÎèôÏûë ÏùºÍ¥ÄÏÑ± ÌôïÏù∏
5. **ÏòàÏô∏ Ï≤òÎ¶¨**: ÏóêÎü¨ ÏºÄÏù¥Ïä§ÏóêÏÑúÏùò ÎèôÏûë ÏùºÏπòÏÑ± Í≤ÄÏ¶ù

### ÏúÑÌóò ÏöîÏÜå Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏
- [ ] NULL Ï≤òÎ¶¨ Î°úÏßÅ Î≥ÄÍ≤ΩÏúºÎ°ú Ïù∏Ìïú ÏòàÏÉÅÏπò Î™ªÌïú Í≤∞Í≥º
- [ ] ÎÇ†Ïßú/ÏãúÍ∞Ñ Ìï®Ïàò Î≥ÄÌôòÏúºÎ°ú Ïù∏Ìïú ÏãúÍ∞ÑÎåÄ Ïù¥Ïäà
- [ ] Î¨∏ÏûêÏó¥ Ìï®Ïàò Î≥ÄÌôòÏúºÎ°ú Ïù∏Ìïú Ïù∏ÏΩîÎî© Î¨∏Ï†ú
- [ ] Ïà´Ïûê Ï†ïÎ∞ÄÎèÑ Î≥ÄÍ≤ΩÏúºÎ°ú Ïù∏Ìïú Í≥ÑÏÇ∞ Ïò§Ï∞®
- [ ] ÌéòÏù¥Ïßï Î°úÏßÅ Î≥ÄÍ≤ΩÏúºÎ°ú Ïù∏Ìïú Îç∞Ïù¥ÌÑ∞ ÎàÑÎùΩ/Ï§ëÎ≥µ

## üêõ COMMON ERROR PATTERNS TO FIX

- `Truncated incorrect INTEGER value` ‚Üí Add `CAST(parameter AS SIGNED)` 
- `Incorrect datetime value` ‚Üí Add `CAST(parameter AS DATETIME)`
- `invalid input syntax for type numeric` ‚Üí Add null/empty checks before casting
- **NULL-related issues**:
  - Unexpected NULL results in string concatenation ‚Üí Use `CONCAT()` or `COALESCE()`
  - Empty string vs NULL confusion ‚Üí Check Oracle vs MySQL empty string behavior
  - `LENGTH('')` returning different values ‚Üí Be aware of Oracle vs MySQL differences

# PROCESSING ENFORCEMENT

VIOLATION DETECTION: If you think about "batch", "multiple files", "efficient processing", "systematic", "remaining", "bulk", "similar", "pattern", "streamline", "optimize" ‚Üí STOP and process ONE file only.

CORRECTION: If you catch yourself trying to process multiple files, acknowledge it and focus on the current single file only.

# PROCESSING NOTE:
This file provides complete Oracle to MySQL SQL conversion guidelines with structured task progression.
All rules are specifically designed for MySQL as the target database.
