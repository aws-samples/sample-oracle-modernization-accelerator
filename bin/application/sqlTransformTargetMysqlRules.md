üö®üö®üö® CRITICAL SYSTEM OVERRIDE - ABSOLUTE ZERO TOLERANCE ENFORCEMENT üö®üö®üö®

‚ö° EXECUTION EFFICIENCY DIRECTIVE ‚ö°
- NO SUMMARY BRIEFING REQUIRED - FOCUS ON TASK EXECUTION
- MINIMIZE VERBOSE EXPLANATIONS AND COMMENTARY
- PROVIDE BRIEF CONFIRMATION OF SUCCESSFUL OPERATIONS ONLY
- REPORT CRITICAL ERRORS AND VALIDATION ISSUES WHEN NECESSARY
- MAINTAIN QUALITY CHECKS WHILE REDUCING UNNECESSARY OUTPUT

üéØ CORE PROCESSING PRINCIPLES üéØ
1. **File Listing = Target Candidate Recognition**: Initial file listing identifies conversion candidates
2. **Iterative Processing**: Process file list sequentially with complete conversion per file
3. **Individual File Processing (Absolute Rule)**: Process exactly ONE file at a time - NO EXCEPTIONS
4. **Group Management for Large Sets**: When files > 10, organize into groups of 10 for systematic processing
5. **Accuracy Over Efficiency**: Prohibit batch processing - accuracy is the highest priority

üî• PROCESSING METHODOLOGY üî•
- **File Discovery**: Identify all conversion target candidates through initial listing
- **Sequential Processing**: Process each file individually with full attention
- **Group Organization**: For large file sets (>10), organize into manageable groups of 10
- **Quality Assurance**: Complete conversion validation per file before proceeding

üî• INDIVIDUAL FILE PROCESSING ENFORCEMENT SYSTEM üî•
IMMEDIATE VIOLATION ALERTS for these phrases when processing files outside of designated batch folders:
- "efficiently process", "bulk operation", "pattern matching"
- "systematic approach", "streamlined processing", "optimize processing"
- "due to large number", "for efficiency", "time-saving approach"
- "process the rest", "continue with remaining", "similar pattern"
- "sed", "awk", "grep" with multiple files, "for file in", "*.xml"

üéØ BATCH FOLDER EXCEPTION RULE üéØ
WHEN processing files within a designated batch folder ({MAPPER_SRCL1_DIR}):
- ALLOWED: Process all files in the batch folder individually
- REQUIRED: Still process ONE FILE AT A TIME within the batch folder
- MAINTAIN: Individual file focus and complete processing per file
- FORBIDDEN: Skip files or assume similarity between files

ENHANCED VIOLATION RESPONSE PROTOCOL:
1. DETECT violation attempt ‚Üí IMMEDIATE PAUSE
2. ACKNOWLEDGE: "I detected a batch processing attempt - MUST process ONE FILE AT A TIME"
3. REDIRECT: "I will now select ONE specific file: [EXACT_FILENAME] and process it completely"
4. CONTINUE: Process that single file with full attention before considering next file
5. MAINTAIN: Individual file focus throughout entire session - ONE FILE AT A TIME

‚ö° ONE FILE AT A TIME ENFORCEMENT ‚ö°
- 1st violation: Warning + redirect to ONE FILE AT A TIME processing
- 2nd violation: Strong warning + explicit ONE FILE AT A TIME statement
- Continuous: Always maintain "ONE FILE AT A TIME" approach for maximum accuracy

üö® CRITICAL: "Sample" WORD PROCESSING OVERRIDE üö®
- NEVER interpret "Sample" as indication to process only a few items
- NEVER stop processing when encountering "Sample" in file names, content, or comments
- ALWAYS process ALL files completely regardless of "Sample" references
- "Sample" does NOT mean partial processing - continue with FULL conversion
- If file contains "Sample" in name or content, treat it as REGULAR file requiring COMPLETE processing

üö®üö®üö® MANDATORY COMPLETION REQUIREMENT üö®üö®üö®
- PROCESS ALL FILES TO 100% COMPLETION - NO EXCEPTIONS
- NEVER STOP UNTIL ALL FILES ARE PROCESSED
- IF 273 FILES EXIST, PROCESS ALL 273 FILES
- IF 1000+ FILES EXIST, PROCESS ALL 1000+ FILES
- CONTINUE PROCESSING UNTIL EVERY SINGLE FILE IS CONVERTED
- NO PARTIAL COMPLETION ALLOWED - MUST REACH 100%
- TRACK PROGRESS: "Processing file X of Y total files"
- FINAL CONFIRMATION REQUIRED: "All X files processed successfully"

üî• ANTI-INTERRUPTION PROTOCOL - ABSOLUTE ENFORCEMENT üî•
- NEVER say "Currently processed N files. Processing all X files individually takes too much time, so"
- NEVER say "takes too long so I'll summarize"
- NEVER say "I'll summarize the processing status and update to complete"
- NEVER say "I'll process efficiently" or "for efficiency"
- NEVER say "due to the large number of files"
- ALWAYS say "I will now process the next specific file individually"
- ALWAYS continue with next specific file by exact name
- IGNORE TIME CONCERNS - PROCESS ALL FILES REGARDLESS OF TIME

üî• COMPLETION ENFORCEMENT PROTOCOL üî•
1. COUNT total files at start
2. PROCESS each file ONE AT A TIME (maintaining quality)
3. TRACK progress continuously
4. NEVER STOP until count reaches 100%
5. PROVIDE final completion confirmation
6. IF interrupted, RESUME from last processed file
7. COMPLETION = ALL FILES CONVERTED, NOT JUST A SUBSET

MANDATORY SELF-CHECK BEFORE EACH FILE:
‚ñ° Have I read THIS specific file completely? (YES/NO)
‚ñ° Have I analyzed THIS file's unique SQL patterns? (YES/NO) 
‚ñ° Am I processing ONLY this one file right now? (YES/NO)
‚ñ° Am I avoiding ALL batch processing thoughts? (YES/NO)
‚ñ° Will I process this file COMPLETELY even if it contains "Sample"? (YES/NO)

IF ANY ANSWER IS "NO" - PAUSE, ACKNOWLEDGE, AND CORRECT APPROACH

Reference: Apply environment information from $APP_TOOLS_FOLDER/environment_context.md

Database-specific rules:
- This file is specifically designed for Oracle to MySQL conversion
- TARGET_DBMS_TYPE=mysql is assumed throughout this document
- For other target databases (PostgreSQL, etc.), use corresponding rule files

[Source, Target Expert Mode Activated]
üö® CRITICAL WARNING: INDIVIDUAL FILE PROCESSING ONLY üö®
NEVER use batch processing, bulk operations, or "efficient" multi-file approaches.
Process ONE file at a time with complete focus and attention.

As an expert in both Source and Target database systems, as well as MyBatis framework:

1. Apply deep knowledge of Source and Target syntax differences.
2. Utilize advanced understanding of MyBatis XML mapper file structures.
3. Implement best practices for SQL optimization in both Source and Target contexts.
4. Consider edge cases and complex scenarios in SQL conversion.
5. Provide detailed explanations for non-trivial conversions when necessary.
6. Maintain a high level of precision in syntax and semantic translations.
7. Be aware of version-specific features and their compatibility.
8. Adhere strictly to the conversion rules and guidelines provided.
9. Anticipate and address potential issues that may arise from the conversion process.
10. Ensure that the converted queries maintain equivalent functionality and performance characteristics.

CRITICAL PROCESSING REQUIREMENTS - ABSOLUTE PROHIBITIONS:
üö´ STRICTLY FORBIDDEN ACTIONS:
- NEVER use bulk processing, batch processing, or shell scripts
- NEVER use shell loops (for, while) or batch commands
- NEVER use wildcard patterns like *.xml in commands
- NEVER use range patterns like [1-9]*.xml or similar
- NEVER use commands like "ls file1*.xml file2*.xml" 
- NEVER process multiple files in a single command
- NEVER use "efficiently process remaining files" approach
- NEVER use phrases like "process the rest efficiently" or "continue with remaining files"
- NEVER use command-line tools like sed, awk, grep for bulk operations
- NEVER create automated scripts for multiple file processing
- NEVER assume file similarity or use pattern-based processing
- NEVER mention "systematic approach" or "efficient processing"
- NEVER use pipe operations for multiple file processing

üîÑ VIOLATION CONSEQUENCES (CORRECTION PROTOCOL):
- Detect violation: PAUSE and acknowledge the attempt
- Self-correct: "I was about to use batch processing approach"
- Redirect: "I will now select ONE specific file to process individually"
- Continue: Restart current file processing with proper individual approach

‚úÖ MANDATORY INDIVIDUAL PROCESSING:
- Process EXACTLY ONE file at a time
- Read each file completely before making any changes
- Apply conversion rules step by step for each individual file
- Validate each conversion before proceeding to the next file
- Treat each file as completely unique - never assume similarity
- Use specific file names only - never use patterns or wildcards
- Focus on one file at a time with full attention to its specific content

PROCESSING METHODOLOGY - INDIVIDUAL FILE APPROACH:
1. Select ONE specific file by exact filename
2. Read that ONE file completely
3. Analyze the SQL patterns in that ONE file only
4. Apply all conversion rules to that ONE file
5. Validate the conversion for that ONE file
6. Save the converted file
7. Move to the NEXT specific file (repeat from step 1)

üîÑ BEHAVIORAL CORRECTION PROTOCOL üîÑ

VIOLATION DETECTION KEYWORDS:
If you catch yourself using ANY of these phrases, IMMEDIATELY CORRECT YOUR APPROACH:
- "efficient", "systematic", "remaining", "batch", "bulk"
- "similar", "pattern", "streamline", "optimize", "faster"  
- "continue with", "process the rest", "due to large number"

IMMEDIATE CORRECTION ACTIONS:
1. PAUSE and acknowledge: "I was about to use batch processing approach"
2. REDIRECT: "I will now select ONE specific file to process individually"
3. RESTART current file processing with proper individual approach
4. CONTINUE with correct methodology

SELF-CORRECTION EXAMPLE:
‚ùå Wrong: "Let me efficiently process the remaining files..."
‚úÖ Corrected: "I caught myself trying to batch process. Let me select the next specific file: [EXACT_FILENAME] and process it individually."

‚úÖ POSITIVE REINFORCEMENT TRIGGERS ‚úÖ
REWARD YOURSELF when you:
- Select ONE specific file by exact name
- Read the entire file before processing
- Apply conversion rules step-by-step to that single file
- Complete one file before moving to the next
- Treat each file as unique

Task: Convert MyBatis-based Oracle SQL Mapper files to MySQL-compatible SQL Mapper files

A. Environment Setup:
  1. Environment Configuration:
      1.1 Directories:
          - Working Directory: {L1FolderName}
          - Source Files: {MAPPER_SRCL1_DIR} (Batch processing: {BATCH_FILE_COUNT} files)
          - Target Files: {MAPPER_TGTL1_DIR}
          - Logs: {L1FolderName}

  2. Execution Status Management:
      2.1 Status File:
          - Location: {L1FolderName}/status.txt
          - Format:
              Step 1: [Status]
              Step 2: [Status]
              Step 3: [Status]
              Step 4: [Status]

      2.2 Status Values:
          - Not Started
          - In Progress
          - Completed

  3. Processing Rules:
      3.1 Log Directory:
          - Preserve all contents
          - Never delete existing logs

      3.2 Status Updates:
          - Update to "In Progress" when Step begins
          - Update to "Completed" when Step ends

B. Task Progression Steps:
  Step 1. Target File Discovery and Processing Organization

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 1: In Progress"

    2. Target File Discovery:
        2.1 Command Execution:
            - Command: ls *{ORIGIN_SUFFIX}* | sort
            - Purpose: Identify ALL conversion target candidates
        
        2.2 File Count Assessment:
            - Count total files requiring conversion
            - Determine processing organization strategy
            - Log total file count for progress tracking

    3. Processing Organization Strategy:
        3.1 For File Count ‚â§ 10:
            - Process all files in single sequential order
            - Maintain individual file processing approach
            
        3.2 For File Count > 10:
            - Organize into groups of 10 files each
            - Example: 30 files ‚Üí Group 1 (files 1-10), Group 2 (files 11-20), Group 3 (files 21-30)
            - Processing order: Group 1 ‚Üí Group 2 ‚Üí Group 3
            - Within each group: Individual file-by-file processing

    4. Processing Plan Generation:
        4.1 Create organized processing plan:
            - Total Files: [N]
            - Groups: [N/10 rounded up] 
            - Strategy: Sequential group processing with individual file conversion
            - Expected completion: All [N] files processed individually

    5. Completion:
        5.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 1: Completed"

  Step 2. Analyze SQL for all {MAPPER_SRCL1_DIR}/*{ORIGIN_SUFFIX}*.xml files

    Detailed execution instructions are documented in $APP_TOOLS_FOLDER/sqlTransformTargetAnalysis.md. Currently skip this step to improve conversion performance

  Step 3. Sequential Individual File Conversion (MAIN PROCESS)

    üéØ ORGANIZED INDIVIDUAL PROCESSING APPROACH:
    Process files using group-based organization while maintaining individual file conversion principle.

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 3: In Progress"

    2. Batch-Based Sequential Processing:
        
        2.1 Current Batch Information:
            - Batch Input Folder: {MAPPER_SRCL1_DIR}
            - Batch Output Folder: {MAPPER_TGTL1_DIR}
            - Files in Current Batch: {BATCH_FILE_COUNT} files
            - Processing Mode: Individual file processing within batch folder
            
        2.2 Individual File Processing Within Batch:
            
            FOR EACH INDIVIDUAL FILE IN CURRENT BATCH FOLDER:
            1. **File Discovery**: List all XML files in {MAPPER_SRCL1_DIR}
            2. **File Selection**: Select ONE specific file by exact filename
            3. **File Reading**: Read the complete file content  
            4. **Conversion Processing**: Apply complete Four-Phase Oracle ‚Üí MySQL transformation
            5. **Validation**: Verify conversion accuracy and XML integrity
            6. **File Output**: Save converted file to {MAPPER_TGTL1_DIR}
            7. **Progress Update**: Log individual file completion
            8. **Next File**: Move to next file in current batch folder
            
            PROCESS ALL {BATCH_FILE_COUNT} FILES IN THE BATCH FOLDER COMPLETELY

        2.3 Four-Phase Conversion Process (For Standard Track Files):
            
            üö® CRITICAL: Apply phases in exact order to prevent conflicts
            
            ### PHASE 1 - STRUCTURAL PROCESSING (Apply First):
            **Purpose**: Clean up Oracle-specific structural elements before syntax conversion
            
            1. **XML Structure Analysis** 
               - Parse XML tags and identify SQL content within CDATA sections
               - Preserve all MyBatis dynamic tags (<if>, <choose>, <foreach>)
               
            2. **Schema Removal** (HIGHEST PRIORITY)
               - Remove schema prefixes: `SCHEMA_NAME.TABLE_NAME` ‚Üí `TABLE_NAME`
               - Reference ORACLE_SVC_USER_LIST for schema names to remove
               - Handle schema.package.procedure patterns
               
            3. **TABLE() Function Removal**
               - Remove TABLE() wrapper: `TABLE(func())` ‚Üí `func()`
               - Preserve all function parameters exactly
               
            4. **Stored Procedure Conversion**
               - Remove curly braces: `{call PROC()}` ‚Üí `CALL PROC()`
               - Convert Oracle package.procedure to package_procedure format
               
            5. **Database Link Removal**
               - Remove @DBLINK suffixes from all database objects

            ### PHASE 2 - SYNTAX STANDARDIZATION (Apply Second):
            **Purpose**: Standardize SQL syntax before MySQL-specific conversions
            
            6. **JOIN Syntax Standardization**
               - Convert comma-separated JOINs to explicit JOINs
               - Move WHERE clause JOIN conditions to ON clauses
               - Convert Oracle (+) outer joins to LEFT/RIGHT JOINs
               
            7. **Common Syntax Cleanup**
               - Remove Oracle optimizer hints (/*+ ... */)
               - Standardize quote usage and case sensitivity

            ### PHASE 3 - MYSQL TRANSFORMATION (Apply Third):
            üéØ CORE CONVERSION RULES (Apply First):

            **Essential 20 MySQL Conversions (Direct Application):**
            1. `NVL(a, b)` ‚Üí `IFNULL(a, b)`
            2. `SYSDATE` ‚Üí `NOW()`
            3. `SUBSTR(str, pos, len)` ‚Üí `SUBSTRING(str, pos, len)`
            4. `ROWNUM <= n` ‚Üí `LIMIT n`
            5. `FROM DUAL` ‚Üí remove completely
            6. `(+)` outer join ‚Üí `LEFT JOIN` or `RIGHT JOIN`
            7. `{call PROC()}` ‚Üí `CALL PROC()`
            8. `SEQ.NEXTVAL` ‚Üí `AUTO_INCREMENT` or `LAST_INSERT_ID()`
            9. `INSTR(str, substr)` ‚Üí `LOCATE(substr, str)`
            10. `TO_DATE('str', 'format')` ‚Üí `STR_TO_DATE('str', 'mysql_format')`
            11. `DECODE(expr, val1, res1, val2, res2, default)` ‚Üí `CASE WHEN expr=val1 THEN res1 WHEN expr=val2 THEN res2 ELSE default END`
            12. `ADD_MONTHS(date, n)` ‚Üí `DATE_ADD(date, INTERVAL n MONTH)`
            13. `MONTHS_BETWEEN(d1, d2)` ‚Üí `TIMESTAMPDIFF(MONTH, d2, d1)`
            14. `TRUNC(date)` ‚Üí `DATE(date)`
            15. `TO_CHAR(num)` ‚Üí `CAST(num AS CHAR)`
            16. `TO_NUMBER(str)` ‚Üí `CAST(str AS DECIMAL)`
            17. `USER` ‚Üí `USER()`
            18. `SYS_GUID()` ‚Üí `UUID()`
            19. `LISTAGG(col, delim)` ‚Üí `GROUP_CONCAT(col SEPARATOR delim)`
            20. Oracle hints `/*+ ... */` ‚Üí remove completely

            **Post-Conversion Validation:**
            After applying core rules, scan for:
            - Remaining Oracle-specific functions
            - MySQL syntax errors
            - Unconverted Oracle constructs
            
            **If Issues Found:**
            Reference detailed conversion sections below for specific patterns:
            - Complex date functions ‚Üí "üîß MYSQL CONVERSION RULES - Date Functions"
            - String manipulation ‚Üí "üîß MYSQL CONVERSION RULES - String Functions"
            - Advanced NULL handling ‚Üí "üîß MYSQL CONVERSION RULES - Advanced NULL Handling"
            - Stored procedures ‚Üí "üîß MYSQL STORED PROCEDURE PROCESSING"
            - ResultMap issues ‚Üí "üó∫Ô∏è RESULTMAP PROCESSING"
            - Complex queries ‚Üí "üî¨ ADVANCED CONVERSIONS"

            ### PHASE 4 - FINAL VALIDATION AND CORRECTION (Apply Last):
            23. **XML Structure Validation**
                - Verify all opening/closing tags match
                - Ensure XML attributes are preserved

            24. **CDATA Section Integrity Check**
                - Confirm CDATA structure is intact while SQL content is converted
                - Verify dynamic query tags are preserved

            25. **Conversion Result Validation**
                - MySQL syntax validation
                - MyBatis bind variable preservation check
                - Functional integrity verification

        2.3 Individual File Processing Rules:
            
            üéØ CORE PROCESSING REQUIREMENTS:
            - Process EXACTLY ONE file at a time with complete focus
            - Read each file completely before making any changes
            - Apply ALL conversion rules to the current file systematically
            - Validate conversion before proceeding to next file
            - Treat each file as unique (never assume similarity)
            
            üî• MANDATORY CONVERSION APPROACH:
            - SCAN entire file content for ANY Oracle construct
            - APPLY transformation rules to EVERY Oracle pattern found
            - COMPLETE 4-phase processing for ALL files
            - NO exceptions for "minor" or "compatible" constructs
            - NO partial conversion allowed

            ‚úÖ REQUIRED SCANNING PATTERNS:
            - Oracle functions: NVL, DECODE, SYSDATE, SUBSTR, ADD_MONTHS, etc.
            - Oracle syntax: ROWNUM, DUAL, (+) joins, {call}, etc.
            - Oracle types: DATE, NUMBER, VARCHAR2, etc.
            - Oracle constructs: CONNECT BY, MERGE, sequences, etc.

        2.4 Progress Tracking Per File:
            
            üìä INDIVIDUAL FILE PROGRESS:
            - Current Group: [X] of [Total Groups]
            - Current File: [Y] of [Group Total] 
            - Overall Progress: [Z] of [Total Files]
            - File Name: [Exact Filename]
            - Status: [Reading/Processing/Validating/Completed]
            
            üìù COMPLETION LOGGING:
            - Log each file completion before moving to next
            - Track conversion patterns applied per file
            - Record any expert-level conversions used
            - Maintain group completion status

        2.5 MySQL Conversion Rules Application:
            
            üéØ COMPREHENSIVE CONVERSION MANDATE:
            Apply COMPLETE Oracle ‚Üí MySQL conversion rules to each individual file.
            
            **MANDATORY TRANSFORMATION COVERAGE:**
            - ALL Oracle functions (NVL, DECODE, SYSDATE, SUBSTR, etc.)
            - ALL sequence handling (NEXTVAL, CURRVAL ‚Üí AUTO_INCREMENT)
            - ALL pagination conversion (ROWNUM ‚Üí LIMIT/OFFSET)
            - ALL DUAL table replacements
            - ALL stored procedure syntax ({call} ‚Üí CALL)
            - ALL JOIN syntax standardization
            - ALL string, numeric, and date/time functions
            - ALL Oracle-specific constructs
            
            **DATABASE EXPERT MODE:**
            For Oracle constructs NOT explicitly documented:
            - Apply appropriate MySQL equivalents based on expert knowledge
            - Use industry best practices for Oracle-to-MySQL conversions
            - Ensure semantic equivalence and optimal performance
            - Document expert-level transformations with comments
            - Document any expert-level transformations applied

        2.6 File Output:
            - Target Directory: {MAPPER_TGTL1_DIR}
            - Filename transformation: {ORIGIN_SUFFIX} ‚Üí {TRANSFORM_SUFFIX}
            - Add conversion comment with timestamp
            - Preserve XML structure and MyBatis functionality

    3. Logging and Tracking:
        3.1 Classification Results:
            Output: {L1FolderName}/processing_classification.txt
            
            Format:
            FAST TRACK - Configuration Only:
            - ConfigMapper.xml: No SQL content detected
            - CacheConfig.xml: Cache configuration only
            
            STANDARD TRACK - SQL Processing Required:
            - UserMapper.xml: Contains SELECT, INSERT operations
            - OrderMapper.xml: Contains stored procedure calls

        3.2 Performance Metrics:
            - Track processing time per file
            - Record classification accuracy
            - Monitor conversion success rate

    3. Final Completion:
        3.1 Processing Summary:
            - Total Files Processed: [N] of [N] (100%)
            - Groups Completed: [All Groups]
            - Individual File Success Rate: [Success Count]/[Total Count]
            
        3.2 Update Status:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 3: Completed"
            - Final Confirmation: "All [N] files processed individually with complete conversion"

  Step 4. Perform xmllint validation on all {MAPPER_TGTL1_DIR}/*{TRANSFORM_SUFFIX}*.xml files

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 4: In Progress"

    2. Target File Verification:
        2.1 Command Execution:
            - Command: ls {MAPPER_TGTL1_DIR}/*{TRANSFORM_SUFFIX}*.xml | sort
            - Purpose: Confirm list of files for validation

    3. XML Validation Process:
        Detailed instructions are documented in $APP_TOOLS_FOLDER/sqlTransformTargetXmlValidation.md, but currently this step should be skipped and not performed

    4. Completion:
        4.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 4: Completed"

# ORACLE TO MYSQL SQL TRANSFORMATION RULES

## üìã OVERVIEW

This section provides complete Oracle to MySQL SQL conversion guidelines with structured task progression.
All MySQL-specific rules are embedded directly in this section.
**CRITICAL**: This processes MyBatis XML mapper files - XML structure and CDATA sections must be preserved.

## üéØ PROCESSING METHODOLOGY

### Individual File Processing (MANDATORY)
- Process EXACTLY ONE file at a time
- Read each file completely before making any changes
- Apply conversion rules step by step for each individual file
- Validate each conversion before proceeding to the next file
- Treat each file as completely unique - never assume similarity
- **XML Structure Preservation**: Maintain all XML tags, attributes, and hierarchy
- **CDATA Protection**: Preserve CDATA sections while converting SQL content within

## üìÑ XML TAG PROCESSING

### Target Tags for SQL Conversion
Apply conversions to SQL content within these tags:

#### Basic SQL Tags
- `<sql>`
- `<select>`
- `<insert>`
- `<update>`
- `<delete>`

#### Subquery and Key Tags
- `<include>`
- `<selectKey>`

#### Result Mapping Tags
- `<resultMap>`
  - `<id>`
  - `<r>`
  - `<constructor>`
  - `<collection>`
  - `<association>`
  - `<discriminator>`

#### Parameter Mapping Tags
- `<parameterMap>`
- `<parameter>`

#### Cache Tags
- `<cache>`
- `<cache-ref>`

### Protected Dynamic Tags (DO NOT MODIFY)
- Flow control: `<if>`, `<choose>`, `<when>`, `<otherwise>`
- Iteration: `<foreach>`
- Variable binding: `<bind>`
- Parameters: `#{variable_name}`, `${variable_name}`

### CDATA Processing
**CRITICAL**: Preserve CDATA structure while converting SQL content

```xml
<!-- Original -->
<select id="getEmployee">
    <![CDATA[
        SELECT * FROM emp
        WHERE rownum <= 10  /* Requires conversion */
    ]]>
</select>

<!-- Convert to -->
<select id="getEmployee">
    <![CDATA[
        SELECT * FROM emp
        LIMIT 10
    ]]>
</select>
```

## üó∫Ô∏è RESULTMAP PROCESSING

### Java Type Conversions
- `javaType="java.math.BigDecimal"` ‚Üí `javaType="java.math.BigDecimal"` (keep as is)
- `javaType="oracle.sql.TIMESTAMP"` ‚Üí `javaType="java.sql.Timestamp"`
- `javaType="oracle.sql.CLOB"` ‚Üí `javaType="java.lang.String"`
- `javaType="oracle.sql.BLOB"` ‚Üí `javaType="byte[]"`

### JDBC Type Conversions (MySQL Compatible)
#### **Numeric Types**
- `jdbcType="NUMBER"` ‚Üí `jdbcType="DECIMAL"`
- `jdbcType="INTEGER"` ‚Üí `jdbcType="INTEGER"`
- `jdbcType="BIGINT"` ‚Üí `jdbcType="BIGINT"`
- `jdbcType="SMALLINT"` ‚Üí `jdbcType="SMALLINT"`
- `jdbcType="TINYINT"` ‚Üí `jdbcType="TINYINT"`
- `jdbcType="FLOAT"` ‚Üí `jdbcType="FLOAT"`
- `jdbcType="DOUBLE"` ‚Üí `jdbcType="DOUBLE"`

#### **String Types**
- `jdbcType="VARCHAR2"` ‚Üí `jdbcType="VARCHAR"`
- `jdbcType="CHAR"` ‚Üí `jdbcType="CHAR"`
- `jdbcType="NVARCHAR2"` ‚Üí `jdbcType="VARCHAR"`
- `jdbcType="NCHAR"` ‚Üí `jdbcType="CHAR"`
- `jdbcType="CLOB"` ‚Üí `jdbcType="LONGTEXT"`
- `jdbcType="NCLOB"` ‚Üí `jdbcType="LONGTEXT"`

#### **Date/Time Types**
- `jdbcType="DATE"` ‚Üí `jdbcType="DATETIME"`
- `jdbcType="TIMESTAMP"` ‚Üí `jdbcType="TIMESTAMP"`
- `jdbcType="TIMESTAMP_WITH_TIME_ZONE"` ‚Üí `jdbcType="TIMESTAMP"`
- `jdbcType="TIMESTAMP_WITH_LOCAL_TIME_ZONE"` ‚Üí `jdbcType="TIMESTAMP"`

#### **Binary Types**
- `jdbcType="BLOB"` ‚Üí `jdbcType="LONGBLOB"`
- `jdbcType="RAW"` ‚Üí `jdbcType="VARBINARY"`
- `jdbcType="LONG_RAW"` ‚Üí `jdbcType="LONGBLOB"`

#### **Special Types**
- `jdbcType="ROWID"` ‚Üí `jdbcType="VARCHAR"` (convert to string representation)
- `jdbcType="XMLTYPE"` ‚Üí `jdbcType="LONGTEXT"`

### Column Mapping Verification (MySQL Specific)
- Check column names match MySQL case sensitivity rules
- Verify column data types are compatible with MySQL
- Ensure property names in resultMap match Java entity fields
- **MySQL Case Sensitivity**: Depends on `lower_case_table_names` setting
  - `lower_case_table_names=0`: Case sensitive (Linux default)
  - `lower_case_table_names=1`: Case insensitive (Windows/macOS default)
  - `lower_case_table_names=2`: Case insensitive storage, case sensitive comparison (macOS default)

### MySQL-Specific ResultMap Considerations
#### **Column Name Handling**
```xml
<!-- Oracle style (may need adjustment) -->
<result column="EMP_ID" property="empId" jdbcType="NUMBER"/>

<!-- MySQL compatible (recommended) -->
<result column="emp_id" property="empId" jdbcType="DECIMAL"/>
```

#### **Auto-Generated Keys**
```xml
<!-- Oracle sequence style -->
<selectKey keyProperty="id" resultType="long" order="BEFORE">
    SELECT SEQ_EMP_ID.NEXTVAL FROM DUAL
</selectKey>

<!-- MySQL AUTO_INCREMENT style -->
<selectKey keyProperty="id" resultType="long" order="AFTER">
    SELECT LAST_INSERT_ID()
</selectKey>
```

### Implementation Example
```xml
<!-- Original -->
<resultMap id="empMap" type="Employee">
    <result property="salary" column="SALARY" javaType="java.math.BigDecimal" jdbcType="NUMBER"/>
    <result property="description" column="DESCRIPTION" javaType="oracle.sql.CLOB" jdbcType="CLOB"/>
</resultMap>

<!-- Convert to -->
<resultMap id="empMap" type="Employee">
    <result property="salary" column="SALARY" javaType="java.math.BigDecimal" jdbcType="NUMERIC"/>
    <result property="description" column="DESCRIPTION" javaType="java.lang.String" jdbcType="VARCHAR"/>
</resultMap>
```
## üîß MYSQL CONVERSION RULES

### Basic Functions (ORACLE-COMPATIBLE CONVERSION)
- `NVL(a, b)` ‚Üí `CASE WHEN (a IS NULL OR a = '') THEN b ELSE a END`
- `SYSDATE` ‚Üí `NOW()`
- `SUBSTR(str, pos, len)` ‚Üí `SUBSTRING(str, pos, len)`
- `DECODE(...)` ‚Üí `CASE WHEN ... END`

### Date Functions
- `ADD_MONTHS(date, n)` ‚Üí `DATE_ADD(date, INTERVAL n MONTH)`
- `MONTHS_BETWEEN(d1, d2)` ‚Üí `TIMESTAMPDIFF(MONTH, d2, d1)`
- `LAST_DAY(date)` ‚Üí `LAST_DAY(date)`
- `NEXT_DAY(date, day)` ‚Üí Complex conversion using CASE and DATE_ADD
- `TRUNC(date, 'DD')` ‚Üí `DATE(date)`
- `TRUNC(date, 'MM')` ‚Üí `DATE_FORMAT(date, '%Y-%m-01')`
- `TRUNC(date, 'YYYY')` ‚Üí `DATE_FORMAT(date, '%Y-01-01')`
- `TRUNC(date, 'HH')` ‚Üí `DATE_FORMAT(date, '%Y-%m-%d %H:00:00')`
- `EXTRACT(YEAR FROM date)` ‚Üí `YEAR(date)`
- `EXTRACT(MONTH FROM date)` ‚Üí `MONTH(date)`
- `EXTRACT(DAY FROM date)` ‚Üí `DAY(date)`
- `EXTRACT(HOUR FROM timestamp)` ‚Üí `HOUR(timestamp)`
- `EXTRACT(MINUTE FROM timestamp)` ‚Üí `MINUTE(timestamp)`
- `EXTRACT(SECOND FROM timestamp)` ‚Üí `SECOND(timestamp)`

### Advanced Date Conversions
```sql
-- Oracle NEXT_DAY conversion example
-- NEXT_DAY(date, 'MONDAY') equivalent in MySQL (0=Monday in WEEKDAY())
DATE_ADD(date, INTERVAL (7 - WEEKDAY(date) + 0) % 7 + 
    CASE WHEN WEEKDAY(date) = 0 THEN 0 ELSE 1 END DAY)

-- Oracle TO_CHAR date formatting
TO_CHAR(date, 'YYYY-MM-DD') ‚Üí DATE_FORMAT(date, '%Y-%m-%d')
TO_CHAR(date, 'DD/MM/YYYY') ‚Üí DATE_FORMAT(date, '%d/%m/%Y')
TO_CHAR(date, 'MON DD, YYYY') ‚Üí DATE_FORMAT(date, '%b %d, %Y')
TO_CHAR(date, 'HH24:MI:SS') ‚Üí TIME_FORMAT(date, '%H:%i:%s')
```

### Sequence Handling (MySQL AUTO_INCREMENT)

#### **Context-Aware NEXTVAL Conversion Rules**

**1. INSERT Statement Context (Auto-Convert):**
- `INSERT ... VALUES (SEQ_NAME.NEXTVAL, ...)` ‚Üí `INSERT ... VALUES (...)` (remove NEXTVAL column)
- `INSERT ... (id, name) VALUES (SEQ_NAME.NEXTVAL, #{name})` ‚Üí `INSERT ... (name) VALUES (#{name})` (remove id column)

**2. SELECT Statement Context (Manual Review Required):**
- `SELECT SEQ_NAME.NEXTVAL FROM DUAL` ‚Üí Add TODO comment for manual review
- Comment format: `-- TODO: NEXTVAL conversion required - Original: SELECT SEQ_NAME.NEXTVAL FROM DUAL`
- Add guidance: `-- MySQL alternatives: AUTO_INCREMENT table, sequence function, or application-level generation`

**3. MyBatis selectKey Context (Auto-Convert):**
```xml
<!-- Oracle BEFORE selectKey -->
<selectKey keyProperty="id" resultType="long" order="BEFORE">
    SELECT SEQ_NAME.NEXTVAL FROM DUAL
</selectKey>
<insert>INSERT INTO table (id, name) VALUES (#{id}, #{name})</insert>

<!-- MySQL conversion: use useGeneratedKeys -->
<insert useGeneratedKeys="true" keyProperty="id">
    INSERT INTO table (name) VALUES (#{name})
</insert>
```

**4. CURRVAL Handling:**
- `SEQ_NAME.CURRVAL` ‚Üí `LAST_INSERT_ID()` (only valid after AUTO_INCREMENT insert)

**5. Legacy Compatibility:**
- For backward compatibility: `SEQ_NAME.NEXTVAL` ‚Üí `LAST_INSERT_ID()` (basic fallback)
- Note: This assumes prior INSERT with AUTO_INCREMENT occurred

#### SelectKey Pattern Processing
```xml
<!-- Original -->
<selectKey keyProperty="id" resultType="long" order="BEFORE">
    SELECT SEQ_EMPLOYEE_ID.NEXTVAL FROM DUAL
</selectKey>

<!-- Convert to (for AUTO_INCREMENT) -->
<selectKey keyProperty="id" resultType="long" order="AFTER">
    SELECT LAST_INSERT_ID()
</selectKey>
```

### Pagination
- `ROWNUM <= n` ‚Üí `LIMIT n`
- Complex ROWNUM pagination ‚Üí `LIMIT n OFFSET m`

#### ROWNUM Based Pagination Pattern
```xml
<!-- Original -->
<select id="getList">
    SELECT * FROM (
        SELECT ROWNUM AS rnum, a.* FROM (
            ${originalQuery}
        ) a WHERE ROWNUM <= #{end}
    ) WHERE rnum >= #{start}
</select>

<!-- Convert to -->
<select id="getList">
    ${originalQuery}
    LIMIT #{pageSize} OFFSET #{start}
</select>
```

### String Functions
- `INSTR(str, substr)` ‚Üí `LOCATE(substr, str)`
- `LPAD(str, len, pad)` ‚Üí `LPAD(str, len, pad)`
- `RPAD(str, len, pad)` ‚Üí `RPAD(str, len, pad)`
- `TO_CHAR(num)` ‚Üí `CAST(num AS CHAR)`
- `TO_NUMBER(str)` ‚Üí `CAST(str AS DECIMAL)` or `CAST(str AS SIGNED)`
- `LTRIM(str)` ‚Üí `LTRIM(str)`
- `RTRIM(str)` ‚Üí `RTRIM(str)`
- `TRIM(str)` ‚Üí `TRIM(str)`
- `UPPER(str)` ‚Üí `UPPER(str)`
- `LOWER(str)` ‚Üí `LOWER(str)`
- `INITCAP(str)` ‚Üí `CONCAT(UPPER(LEFT(str,1)), LOWER(SUBSTRING(str,2)))`
- **String Concatenation (ORACLE-COMPATIBLE)**:
  - Oracle: `str1 || str2` ‚Üí MySQL: `CONCAT(IFNULL(str1, ''), IFNULL(str2, ''))`
  - **Multiple concatenation**: `str1 || str2 || str3` ‚Üí `CONCAT(IFNULL(str1, ''), IFNULL(str2, ''), IFNULL(str3, ''))`
  - **With literals**: `'Hello ' || name || '!'` ‚Üí `CONCAT('Hello ', IFNULL(name, ''), '!')`
- **LENGTH with NULL (ORACLE-COMPATIBLE)**:
  - Oracle: `LENGTH(NULL)` ‚Üí `NULL`, `LENGTH('')` ‚Üí `NULL`
  - MySQL: `CASE WHEN (column IS NULL OR column = '') THEN NULL ELSE LENGTH(column) END`
  - **Note**: Oracle treats empty strings as NULL in LENGTH function

### Numeric Functions
**Note**: Most numeric functions have identical syntax in Oracle and MySQL
- `MOD(n, m)` ‚Üí `MOD(n, m)` (no conversion needed)
- `POWER(n, m)` ‚Üí `POW(n, m)` (function name change required)
- `SQRT(n)` ‚Üí `SQRT(n)` (no conversion needed)
- `ABS(n)` ‚Üí `ABS(n)` (no conversion needed)
- `CEIL(n)` ‚Üí `CEILING(n)` (function name change required)
- `FLOOR(n)` ‚Üí `FLOOR(n)` (no conversion needed)
- `ROUND(n, d)` ‚Üí `ROUND(n, d)` (no conversion needed)
- `TRUNC(n, d)` ‚Üí `TRUNCATE(n, d)` (function name change required)
- `SIGN(n)` ‚Üí `SIGN(n)` (no conversion needed)

### Conditional Functions
- `GREATEST(val1, val2, ...)` ‚Üí `GREATEST(val1, val2, ...)`
- `LEAST(val1, val2, ...)` ‚Üí `LEAST(val1, val2, ...)`
- `NULLIF(expr1, expr2)` ‚Üí `NULLIF(expr1, expr2)` (same syntax)

### Aggregate Functions with DISTINCT
- `COUNT(DISTINCT column)` ‚Üí `COUNT(DISTINCT column)` (same syntax)
- `SUM(DISTINCT column)` ‚Üí `SUM(DISTINCT column)` (same syntax)
- `AVG(DISTINCT column)` ‚Üí `AVG(DISTINCT column)` (same syntax)

### Additional Critical Oracle Functions
- `REPLACE(str, search, replace)` ‚Üí `REPLACE(str, search, replace)` (same syntax)
- `TRANSLATE(str, from_chars, to_chars)` ‚Üí Complex REPLACE chain or custom function
- `ASCII(char)` ‚Üí `ASCII(char)` (same syntax)
- `SOUNDEX(str)` ‚Üí `SOUNDEX(str)` (same syntax)
- `REVERSE(str)` ‚Üí `REVERSE(str)` (same syntax)
- `REPEAT(str, n)` ‚Üí `REPEAT(str, n)` (same syntax)
- `SPACE(n)` ‚Üí `SPACE(n)` (same syntax)
- `LEFT(str, len)` ‚Üí `LEFT(str, len)` (same syntax)

### Additional Oracle to MySQL Conversions
- `LISTAGG(column, delimiter)` ‚Üí `GROUP_CONCAT(column SEPARATOR delimiter)`
- `CHR(ASCII('A')+n)` ‚Üí `CHAR(ASCII('A')+n)`
- `v$session` ‚Üí `SHOW PROCESSLIST` or `information_schema.PROCESSLIST`
- **TO_DATE conversion**:
  - Date only: `TO_DATE('20250424', 'YYYYMMDD')` ‚Üí `STR_TO_DATE('20250424', '%Y%m%d')`
  - Date with time: `TO_DATE('2025-04-24 13:45:00', 'YYYY-MM-DD HH24:MI:SS')` ‚Üí `STR_TO_DATE('2025-04-24 13:45:00', '%Y-%m-%d %H:%i:%s')`
- **Date format patterns**:
  - Oracle `YYYY` ‚Üí MySQL `%Y`
  - Oracle `MM` ‚Üí MySQL `%m`
  - Oracle `DD` ‚Üí MySQL `%d`
  - Oracle `HH24` ‚Üí MySQL `%H`
  - Oracle `MI` ‚Üí MySQL `%i`
  - Oracle `SS` ‚Üí MySQL `%s`
- **Explicit type casting for comparisons**:
  - `SUBSTRING(date_column,1,8) = STR_TO_DATE('20250424', '%Y%m%d')`
- **INTERVAL for date calculations**:
  - `DATE_ADD(STR_TO_DATE(date, '%Y%m%d'), INTERVAL 3 DAY)`
- **Preserve special characters**: Maintain `&lt;` and `&gt;` in original SQL
- **Remove ORDER BY for aggregate functions without GROUP BY**:
  - `SELECT COUNT(empno) FROM emp ORDER BY reg_dttm` ‚Üí `SELECT COUNT(empno) FROM emp`
- **Oracle Hint Removal**:
  - Remove all Oracle optimizer hints from SQL
  - `SELECT /*+ FIRST_ROWS(10) */ * FROM table` ‚Üí `SELECT * FROM table`
  - `SELECT /*+ INDEX(t, idx_name) */ * FROM table t` ‚Üí `SELECT * FROM table t`
  - `SELECT /*+ USE_NL(a b) */ * FROM a, b` ‚Üí `SELECT * FROM a, b`
  - **Pattern**: Remove `/*+ ... */` comments entirely

### Oracle Date Literals
- `DATE '2023-01-01'` ‚Üí `'2023-01-01'`
- `TIMESTAMP '2023-01-01 12:00:00'` ‚Üí `'2023-01-01 12:00:00'`

### Oracle System Functions
- `USER` ‚Üí `USER()`
- `SYS_CONTEXT('USERENV', 'SESSION_USER')` ‚Üí `USER()`
- `USERENV('SESSIONID')` ‚Üí `CONNECTION_ID()`
- `SYS_GUID()` ‚Üí `UUID()`

### Advanced NULL Handling (ORACLE-COMPATIBLE)
- `NVL2(expr1, expr2, expr3)` ‚Üí `CASE WHEN (expr1 IS NOT NULL AND expr1 != '') THEN expr2 ELSE expr3 END`
- Mixed type COALESCE: `COALESCE(employee_id, 'N/A')` ‚Üí `CASE WHEN (employee_id IS NULL OR employee_id = '') THEN 'N/A' ELSE CAST(employee_id AS CHAR) END`
- Date COALESCE: `COALESCE(hire_date, '1900-01-01')` ‚Üí `CASE WHEN hire_date IS NULL THEN '1900-01-01' ELSE hire_date END`
- `USERENV('SESSIONID')` ‚Üí `CONNECTION_ID()`
- `SYS_GUID()` ‚Üí `gen_random_uuid()` (requires pgcrypto extension)

### Advanced NULL Handling
- `NVL2(expr1, expr2, expr3)` ‚Üí `CASE WHEN expr1 IS NOT NULL THEN expr2 ELSE expr3 END`
- Mixed type COALESCE: `COALESCE(employee_id, 'N/A')` ‚Üí `CASE WHEN employee_id IS NULL THEN 'N/A' ELSE CAST(employee_id AS CHAR) END`
- Date COALESCE: `COALESCE(hire_date, '1900-01-01')` ‚Üí `COALESCE(hire_date, CAST('1900-01-01' AS DATE))`

### IS NULL / IS NOT NULL Processing
- `column IS NULL` ‚Üí `column IS NULL` (same syntax, but behavior may differ)
- `column IS NOT NULL` ‚Üí `column IS NOT NULL` (same syntax)
- **Empty String vs NULL**:
  - Oracle: `'' IS NULL` returns TRUE
  - MySQL: `'' IS NULL` returns FALSE
  - **Conversion**: `column IS NULL` ‚Üí `(column IS NULL OR column = '')` (if Oracle empty string behavior needed)
- **NULL Concatenation**:
  - Oracle: `'Hello' || NULL` returns `'Hello'`
  - MySQL: `CONCAT('Hello', NULL)` returns `NULL`
  - **Conversion**: Use `CONCAT(IFNULL(str1, ''), IFNULL(str2, ''))` for Oracle behavior
- **NULL in Arithmetic**:
  - Both Oracle and MySQL: `5 + NULL` returns `NULL` (same behavior)
- **NULL Comparison**:
  - Both: `NULL = NULL` returns `NULL` (not TRUE)
  - Both: Use `IS NULL` or `IS NOT NULL` for NULL checks

### Stored Procedure Enhancement
- **MySQL Procedure Conversion**: Always use `CALL` format
- `{call PROC()}` ‚Üí `CALL PROC()`
- **Type Casting for Procedure Parameters**:
  - `#{param,mode=IN,jdbcType=DECIMAL}` ‚Üí `CAST(#{param,mode=IN,jdbcType=DECIMAL} AS numeric)`
  - `#{param,mode=IN,jdbcType=INTEGER}` ‚Üí `CAST(#{param,mode=IN,jdbcType=INTEGER} AS integer)`
  - `#{param,mode=IN,jdbcType=DATE}` ‚Üí `CAST(#{param,mode=IN,jdbcType=DATE} AS timestamp)`
  - `#{param,mode=IN,jdbcType=VARCHAR}` ‚Üí No CAST (keep as is)
  - OUT parameters: Keep original format without CAST

### DUAL Table Removal
- `SELECT 'Hello' FROM DUAL` ‚Üí `SELECT 'Hello'`
- `SELECT #{variable} FROM DUAL` ‚Üí `SELECT #{variable}`

### Package Handling (Convert to underscore naming)
- Convert Oracle package.procedure format to MySQL naming convention
- `PACKAGE_NAME.PROCEDURE_NAME` ‚Üí `PACKAGE_NAME_PROCEDURE_NAME`
- `PACKAGE_NAME.FUNCTION_NAME` ‚Üí `PACKAGE_NAME_FUNCTION_NAME`
- **Note**: Schema removal is handled in PHASE 1 - STRUCTURAL PROCESSING before MySQL conversion
- **Note**: MySQL doesn't support packages - use underscore naming convention to maintain logical grouping

### ResultMap Column Names
- Convert column attributes to lowercase in ResultMap tags
- `column="EMP_ID"` ‚Üí `column="emp_id"`
- Apply only to `<r>`, `<id>`, `<association>`, `<collection>` tags
## üîß MYSQL STORED PROCEDURE PROCESSING

### Identification and Preprocessing
- Scan for DECLARE sections in SQL content
- Identify variable declarations and initializations
- Preserve CDATA sections containing PL/SQL blocks
- **Priority**: Eliminate DECLARE blocks when possible, convert only when necessary

### Critical Requirements for MySQL Conversion
- **Eliminate rather than convert**: Most DECLARE blocks can be replaced with subqueries
- **User variables**: Use @variable syntax for simple cases
- **Stored procedures**: Only for complex logic that cannot be simplified
- **Never modify anything within #{...} brackets - treat as sacred tokens**
- **NEVER modify variable case**

### Conversion Strategies

#### **Strategy 1: Elimination (PREFERRED)**
```sql
-- Oracle PL/SQL
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM employees WHERE dept_id = #{deptId};
    IF v_count > 0 THEN
        DELETE FROM departments WHERE id = #{deptId};
    END IF;
END;

-- MySQL (Eliminate DECLARE)
DELETE FROM departments 
WHERE id = #{deptId} 
  AND EXISTS (SELECT 1 FROM employees WHERE dept_id = #{deptId})
```

#### **Strategy 2: User Variables (Simple Cases)**
```sql
-- Oracle PL/SQL
DECLARE
    v_max_salary NUMBER;
BEGIN
    SELECT MAX(salary) INTO v_max_salary FROM employees;
    UPDATE employees SET bonus = salary * 0.1 WHERE salary = v_max_salary;
END;

-- MySQL User Variables
SET @max_salary = (SELECT MAX(salary) FROM employees);
UPDATE employees SET bonus = salary * 0.1 WHERE salary = @max_salary;
```

#### **Strategy 3: Stored Procedure (Complex Cases Only)**
```sql
-- Oracle PL/SQL (Complex logic)
DECLARE
    v_emp_count NUMBER;
    v_dept_name VARCHAR2(100);
BEGIN
    SELECT COUNT(*), d.name INTO v_emp_count, v_dept_name
    FROM employees e, departments d 
    WHERE e.dept_id = d.id AND d.id = #{deptId};
    
    IF v_emp_count > 10 THEN
        INSERT INTO audit_log VALUES (v_dept_name, 'LARGE_DEPT', SYSDATE);
    END IF;
END;

-- MySQL Stored Procedure (Only if elimination not possible)
DELIMITER //
CREATE PROCEDURE process_department(IN dept_id INT)
BEGIN
    DECLARE v_emp_count INT;
    DECLARE v_dept_name VARCHAR(100);
    
    SELECT COUNT(*), d.name INTO v_emp_count, v_dept_name
    FROM employees e, departments d 
    WHERE e.dept_id = d.id AND d.id = dept_id;
    
    IF v_emp_count > 10 THEN
        INSERT INTO audit_log VALUES (v_dept_name, 'LARGE_DEPT', NOW());
    END IF;
END //
DELIMITER ;
```

### MySQL Variable Declaration Rules

#### **Data Type Mapping**
- `NUMBER` ‚Üí `DECIMAL` or `INT`
- `VARCHAR2(n)` ‚Üí `VARCHAR(n)`
- `DATE` ‚Üí `DATETIME`
- `TIMESTAMP` ‚Üí `TIMESTAMP`
- `CLOB` ‚Üí `LONGTEXT`
- `BLOB` ‚Üí `LONGBLOB`

#### **%TYPE References (Convert to Explicit Types)**
```sql
-- Oracle
DECLARE
    v_emp_id    employees.employee_id%TYPE;

-- MySQL (Convert to explicit type based on table definition)
DECLARE v_emp_id INT;
```

### Error Handling Conversion

#### **Oracle Exception Handling**
```sql
-- Oracle
BEGIN
    -- SQL statements
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        NULL;
    WHEN OTHERS THEN
        RAISE;
END;
```

#### **MySQL Error Handling**
```sql
-- MySQL
BEGIN
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET @dummy = 1;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    -- SQL statements
END;
```

#### Data Type Mapping
- `VARCHAR2(n)` ‚Üí `VARCHAR`
- `CHAR(n)` ‚Üí `VARCHAR`
- `NUMBER` ‚Üí `NUMERIC`
- `NUMBER(p)` ‚Üí `INTEGER` (p <= 10)
- `NUMBER(p,s)` ‚Üí `NUMERIC(p,s)`
- `DATE` ‚Üí `TIMESTAMP`
- `CLOB` ‚Üí `TEXT`
- `BLOB` ‚Üí `BYTEA`
- `BOOLEAN` ‚Üí `BOOLEAN`
- `RAW` ‚Üí `BYTEA`
- `LONG RAW` ‚Üí `BYTEA`
- `TIMESTAMP` ‚Üí `TIMESTAMP`
- `TIMESTAMP WITH TIME ZONE` ‚Üí `TIMESTAMP WITH TIME ZONE`

#### Special Cases
- Remove VARCHAR length specifications
- Detailed NUMBER handling:
  - Plain `NUMBER` ‚Üí `NUMERIC`
  - `NUMBER(p)` ‚Üí `INTEGER` (p ‚â§ 10)
  - `NUMBER(p,s)` ‚Üí `NUMERIC(p,s)`

### Variable Management

#### Initialization Rules
- **NO initializations in DECLARE section**
- **ALL initializations MUST move to BEGIN section**

#### Bind Variable Handling
- Maintain MyBatis bind variable syntax: `#{variable_name}`
- Move all bind variable assignments to BEGIN section
- For %TYPE variables, do not add type casts to bind variables
- For explicitly typed variables, add appropriate type casts

### Error Handling
- `EXCEPTION WHEN` ‚Üí `EXCEPTION WHEN`
- `NO_DATA_FOUND` ‚Üí `NO_DATA_FOUND`
- `TOO_MANY_ROWS` ‚Üí `TOO_MANY_ROWS`
- `OTHERS` ‚Üí `OTHERS`

### Implementation Example

```sql
-- Original Oracle Code
DECLARE
    V_EMP_ID    EMPLOYEES.EMPLOYEE_ID%TYPE := #{EMPID};
    V_NAME      VARCHAR2(100) := #{EMPNAME};
    V_SALARY    NUMBER(10,2) := #{EMPSALARY};
    V_DEPTNAME  DEPT.DEPTNAME%TYPE := NVL(#{DEPTNAME}, '');
BEGIN
    -- logic
END;

-- Correct MySQL Conversion
DO $$
DECLARE
    V_EMP_ID    employees.employee_id%TYPE;
    V_NAME      VARCHAR;
    V_SALARY    NUMERIC(10,2);
    V_DEPTNAME  dept.deptname%TYPE;
BEGIN
    V_EMP_ID := #{EMPID};
    V_NAME := #{EMPNAME};
    V_SALARY := #{EMPSALARY};
    V_DEPTNAME := COALESCE(#{DEPTNAME}, '');
    -- logic
END;
END //
DELIMITER ;
```
## üî¨ ADVANCED CONVERSIONS (MySQL Optimized)

### Hierarchical Queries (CONNECT BY)
Convert to recursive CTEs (MySQL 8.0+) or alternative approaches:

#### **MySQL 8.0+ Recursive CTE**
```sql
-- Oracle CONNECT BY (Simple hierarchy)
SELECT employee_id, manager_id, level
FROM employees 
START WITH manager_id IS NULL 
CONNECT BY PRIOR employee_id = manager_id;

-- MySQL 8.0+ Recursive CTE
WITH RECURSIVE emp_hierarchy AS (
    -- Anchor: root nodes
    SELECT employee_id, manager_id, 1 as level
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive: child nodes
    SELECT e.employee_id, e.manager_id, eh.level + 1
    FROM employees e
    JOIN emp_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT employee_id, manager_id, level FROM emp_hierarchy;
```

#### **Pre-MySQL 8.0 Alternative (Self-Join)**
```sql
-- For older MySQL versions, use multiple self-joins or application logic
SELECT e1.employee_id, e1.manager_id, 1 as level FROM employees e1 WHERE e1.manager_id IS NULL
UNION ALL
SELECT e2.employee_id, e2.manager_id, 2 as level FROM employees e2 
JOIN employees e1 ON e2.manager_id = e1.employee_id WHERE e1.manager_id IS NULL
-- Continue for required levels...
```

### ROWNUM Conversion Patterns

#### **Simple ROWNUM**
- `WHERE ROWNUM <= n` ‚Üí `LIMIT n`
- `WHERE ROWNUM = 1` ‚Üí `LIMIT 1`

#### **Complex ROWNUM (Pagination)**
```sql
-- Oracle nested ROWNUM
SELECT * FROM (
    SELECT ROWNUM as rn, a.* FROM (
        SELECT * FROM table ORDER BY column
    ) a WHERE ROWNUM <= 20
) WHERE rn > 10;

-- MySQL LIMIT OFFSET
SELECT * FROM table ORDER BY column LIMIT 10 OFFSET 10;
```

#### **ROWNUM with Window Functions (MySQL 8.0+)**
```sql
-- Oracle ROWNUM with complex conditions
SELECT * FROM (
    SELECT ROWNUM as rn, emp.* 
    FROM (SELECT * FROM employees ORDER BY salary DESC) emp
    WHERE ROWNUM <= 100
) WHERE rn BETWEEN 21 AND 40;

-- MySQL 8.0+ with ROW_NUMBER()
SELECT * FROM (
    SELECT ROW_NUMBER() OVER (ORDER BY salary DESC) as rn, emp.*
    FROM employees emp
) ranked WHERE rn BETWEEN 21 AND 40;
```

### MERGE Statement Conversion

#### **Oracle MERGE**
```sql
MERGE INTO target_table t
USING source_table s ON (t.id = s.id)
WHEN MATCHED THEN
    UPDATE SET t.name = s.name, t.updated_date = SYSDATE
WHEN NOT MATCHED THEN
    INSERT (id, name, created_date) VALUES (s.id, s.name, SYSDATE);
```

#### **MySQL Equivalent (INSERT ... ON DUPLICATE KEY UPDATE)**
```sql
INSERT INTO target_table (id, name, created_date, updated_date)
SELECT id, name, NOW(), NOW() FROM source_table
ON DUPLICATE KEY UPDATE 
    name = VALUES(name),
    updated_date = NOW();
```

### Window Functions (MySQL 8.0+)

#### **Oracle Analytical Functions**
```sql
-- Oracle
SELECT employee_id, salary,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank_in_dept,
       LAG(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as prev_salary
FROM employees;

-- MySQL 8.0+ (Same syntax)
SELECT employee_id, salary,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank_in_dept,
       LAG(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as prev_salary
FROM employees;
```

### JSON Functions (MySQL 5.7+)

#### **Oracle JSON vs MySQL JSON**
```sql
-- Oracle JSON_VALUE
SELECT JSON_VALUE(json_column, '$.name') FROM table_name;

-- MySQL JSON_EXTRACT
SELECT JSON_EXTRACT(json_column, '$.name') FROM table_name;
-- or
SELECT json_column->>'$.name' FROM table_name;
```

### Performance Optimization Patterns (MySQL 8.0+)

#### **Window Functions (Full Support)**
```sql
-- Oracle Analytical Functions ‚Üí MySQL 8.0+ (Same syntax)
SELECT employee_id, salary,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank_in_dept,
       RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank,
       DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as dense_rank,
       LAG(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as prev_salary,
       LEAD(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as next_salary,
       FIRST_VALUE(salary) OVER (PARTITION BY department_id ORDER BY salary DESC) as max_salary,
       LAST_VALUE(salary) OVER (PARTITION BY department_id ORDER BY salary DESC 
                                RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as min_salary
FROM employees;
```

#### **CTE (Common Table Expressions)**
```sql
-- Oracle WITH clause ‚Üí MySQL 8.0+ WITH clause (Same syntax)
WITH dept_summary AS (
    SELECT department_id, AVG(salary) as avg_salary, COUNT(*) as emp_count
    FROM employees
    GROUP BY department_id
),
high_salary_depts AS (
    SELECT department_id FROM dept_summary WHERE avg_salary > 50000
)
SELECT e.employee_id, e.name, e.salary
FROM employees e
JOIN high_salary_depts hsd ON e.department_id = hsd.department_id;
```

#### **JSON Functions (MySQL 8.0+)**
```sql
-- Oracle JSON handling ‚Üí MySQL 8.0+ JSON functions
-- JSON_VALUE ‚Üí JSON_UNQUOTE(JSON_EXTRACT())
SELECT JSON_UNQUOTE(JSON_EXTRACT(json_column, '$.name')) as name,
       json_column->>'$.email' as email,
       JSON_OBJECT('id', employee_id, 'name', name, 'salary', salary) as emp_json
FROM employees;
```

#### **Regular Expressions (MySQL 8.0+)**
```sql
-- Oracle REGEXP functions ‚Üí MySQL 8.0+ REGEXP functions
SELECT employee_id,
       CASE WHEN email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' 
            THEN 'Valid' ELSE 'Invalid' END as email_status,
       REGEXP_REPLACE(phone, '[^0-9]', '') as clean_phone,
       REGEXP_SUBSTR(address, '[0-9]+') as street_number
FROM employees;
```

### Advanced Query Optimization

#### **Index Hints (MySQL 8.0+)**
```sql
-- Oracle hints (Remove) ‚Üí MySQL index hints
SELECT * FROM employees 
USE INDEX (idx_department_salary)
WHERE department_id = #{deptId} 
ORDER BY salary DESC;
```

### MyBatis + MySQL 8.0+ Optimization Patterns

#### **Dynamic SQL with MySQL Features**
```xml
<!-- Leverage MySQL 8.0+ window functions in MyBatis -->
<select id="getEmployeeRanking" resultType="EmployeeRank">
    SELECT employee_id, name, salary,
           ROW_NUMBER() OVER (
               <if test="partitionBy != null">
                   PARTITION BY ${partitionBy}
               </if>
               ORDER BY 
               <choose>
                   <when test="orderBy == 'salary'">salary DESC</when>
                   <when test="orderBy == 'hire_date'">hire_date DESC</when>
                   <otherwise>employee_id</otherwise>
               </choose>
           ) as ranking
    FROM employees
    <where>
        <if test="departmentId != null">
            AND department_id = #{departmentId}
        </if>
        <if test="minSalary != null">
            AND salary >= #{minSalary}
        </if>
    </where>
</select>
```

#### **Batch Operations with MySQL**
```xml
<!-- MySQL batch insert with ON DUPLICATE KEY UPDATE -->
<insert id="batchUpsertEmployees" parameterType="list">
    INSERT INTO employees (employee_id, name, email, salary, department_id)
    VALUES
    <foreach collection="list" item="emp" separator=",">
        (#{emp.employeeId}, #{emp.name}, #{emp.email}, #{emp.salary}, #{emp.departmentId})
    </foreach>
    ON DUPLICATE KEY UPDATE
        name = VALUES(name),
        email = VALUES(email),
        salary = VALUES(salary),
        department_id = VALUES(department_id),
        updated_date = NOW()
</insert>
```

#### **JSON Column Handling**
```xml
<!-- MySQL JSON column operations -->
<select id="searchEmployeesBySkills" resultType="Employee">
    SELECT employee_id, name, 
           JSON_UNQUOTE(JSON_EXTRACT(skills_json, '$.programming')) as programming_skills
    FROM employees
    WHERE JSON_CONTAINS(skills_json, JSON_OBJECT('level', #{skillLevel}))
       OR JSON_EXTRACT(skills_json, '$.years_experience') >= #{minExperience}
</select>
```

#### **Recursive CTE in MyBatis**
```xml
<!-- Hierarchical data with MySQL 8.0+ recursive CTE -->
<select id="getEmployeeHierarchy" resultType="EmployeeHierarchy">
    WITH RECURSIVE emp_hierarchy AS (
        -- Root level employees
        SELECT employee_id, name, manager_id, 1 as level,
               CAST(name AS CHAR(1000)) as path
        FROM employees 
        WHERE manager_id IS NULL
        
        UNION ALL
        
        -- Child employees
        SELECT e.employee_id, e.name, e.manager_id, eh.level + 1,
               CONCAT(eh.path, ' -> ', e.name) as path
        FROM employees e
        JOIN emp_hierarchy eh ON e.manager_id = eh.employee_id
        WHERE eh.level < #{maxLevel}
    )
    SELECT employee_id, name, manager_id, level, path
    FROM emp_hierarchy
    ORDER BY level, name
</select>
```

### MySQL 8.0+ Performance Best Practices

#### **Optimized Pagination**
```xml
<!-- Use LIMIT OFFSET with covering index -->
<select id="getEmployeesPaginated" resultType="Employee">
    SELECT e.employee_id, e.name, e.salary, e.department_id
    FROM employees e
    <where>
        <if test="departmentId != null">
            AND e.department_id = #{departmentId}
        </if>
        <if test="lastEmployeeId != null">
            AND e.employee_id > #{lastEmployeeId}
        </if>
    </where>
    ORDER BY e.employee_id
    LIMIT #{pageSize}
</select>
```

#### **Efficient Counting**
```xml
<!-- Use window functions for count with data -->
<select id="getEmployeesWithCount" resultType="EmployeeWithCount">
    SELECT employee_id, name, salary,
           COUNT(*) OVER() as total_count
    FROM employees
    <where>
        <if test="searchTerm != null">
            AND (name LIKE CONCAT('%', #{searchTerm}, '%') 
                 OR email LIKE CONCAT('%', #{searchTerm}, '%'))
        </if>
    </where>
    ORDER BY name
    LIMIT #{pageSize} OFFSET #{offset}
</select>
```

#### **Index Hints Conversion**
```sql
-- Oracle Hints (Remove)
SELECT /*+ INDEX(emp, emp_idx_name) */ * FROM employees emp;

-- MySQL Index Hints
SELECT * FROM employees USE INDEX (emp_idx_name);
```

#### **Optimizer Hints**
```sql
-- Oracle (Remove all optimizer hints)
SELECT /*+ FIRST_ROWS(10) */ * FROM table;

-- MySQL (Use appropriate syntax or remove)
SELECT * FROM table;
```

-- MySQL LIMIT/OFFSET
SELECT * FROM table 
ORDER BY column 
LIMIT 10 OFFSET 10;
```

#### ROWNUM in Subqueries
- Convert to `ROW_NUMBER() OVER()` when ROWNUM is used in analytical context
- Use `LIMIT` when ROWNUM is used for simple row limiting

### MERGE Statements
Convert to INSERT ... ON CONFLICT:
```sql
-- Oracle MERGE
MERGE INTO target USING source ON (condition)
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT ...

-- MySQL
INSERT INTO target SELECT ... FROM source
ON CONFLICT (key) DO UPDATE SET ...
```

### Regular Expressions
- `REGEXP_LIKE(source, pattern)` ‚Üí `source REGEXP pattern`
- `REGEXP_REPLACE(source, pattern, replacement)` ‚Üí `REGEXP_REPLACE(source, pattern, replacement)`
- `REGEXP_SUBSTR(source, pattern)` ‚Üí `REGEXP_SUBSTR(source, pattern)` (MySQL 8.0+)
- `REGEXP_INSTR(source, pattern)` ‚Üí Custom function using REGEXP and LOCATE

## üéØ EXPERT-LEVEL CONVERSION GUIDANCE

### Rule Application Priority (STRICT HIERARCHY)
**Priority 1 (HIGHEST)**: Explicit rules documented in this file
**Priority 2 (MEDIUM)**: Database expert knowledge for undocumented Oracle constructs  
**Priority 3 (LOWEST)**: Conservative fallback (preserve original with comments)

### For Oracle Constructs Not Explicitly Listed
**ONLY apply expert knowledge when Priority 1 rules don't exist**

When encountering Oracle SQL constructs, functions, or syntax patterns that are not explicitly documented in the above rules:

#### **Step 1: Check Explicit Rules First**
- Scan all documented conversion rules in this file
- If explicit rule exists ‚Üí Apply it (Priority 1)
- If no explicit rule exists ‚Üí Proceed to Step 2

#### **Step 2: Apply Database Expert Knowledge** (Priority 2)
Apply **database expert knowledge** to provide appropriate MySQL equivalents:

#### **Conversion Principles:**
1. **Semantic Equivalence**: Ensure the MySQL conversion maintains the same logical behavior as the original Oracle construct
2. **Performance Consideration**: Choose MySQL alternatives that provide similar or better performance characteristics
3. **Standards Compliance**: Prefer ANSI SQL standard approaches when available in MySQL
4. **MySQL Best Practices**: Utilize MySQL-specific features when they provide superior functionality

#### **Common Expert Conversion Patterns:**

**Oracle Aggregate Functions:**
- Apply MySQL aggregate function equivalents with proper syntax
- Consider `GROUP_CONCAT()` for string concatenation aggregates
- Use MySQL 8.0+ window functions for advanced aggregation

**Oracle Analytical Functions:**
- Most Oracle window functions have direct MySQL 8.0+ equivalents
- Maintain `OVER()` clause syntax and partitioning logic
- Convert Oracle-specific analytical functions to MySQL alternatives

**Oracle System Functions:**
- Map Oracle system functions to appropriate MySQL system information functions
- Use `USER()`, `DATABASE()`, `VERSION()` etc. as needed
- Convert Oracle metadata queries to MySQL information_schema queries

**Oracle Data Type Functions:**
- Convert Oracle type conversion functions to MySQL casting syntax
- Use `CAST(value AS type)` as appropriate
- Handle Oracle-specific data types with MySQL equivalents

**Oracle PL/SQL Constructs:**
- Convert Oracle PL/SQL blocks to MySQL stored procedure syntax
- Adapt Oracle exception handling to MySQL exception syntax
- Transform Oracle cursor operations to MySQL cursor equivalents

#### **Documentation Requirement:**
When applying expert-level conversions, add comments documenting the transformation:
```xml
<!-- YYYY-MM-DD Amazon Q Developer : Expert conversion - Oracle [construct] to MySQL [equivalent] -->
```

#### **Fallback Strategy:**
If no suitable MySQL equivalent exists:
1. **Document the limitation** with detailed comments
2. **Suggest alternative approaches** using MySQL features
3. **Maintain functional equivalence** even if syntax differs significantly
## ‚öôÔ∏è PROCESSING INSTRUCTIONS

### Step-by-Step Process
1. **Parse Input XML**: Extract ALL SQL content while preserving XML structure
2. **Apply Conversion Rules**: Execute all MySQL transformation rules
3. **Process PL/SQL DECLARE**: Handle DECLARE sections with MySQL conversion strategies
4. **Validate Results**: Ensure XML structure and MyBatis functionality preserved

### Comment Requirements

#### Comment Location
- Inside `<mapper>` tag
- Above SQL definition tags

#### Comment Format
```xml
<!-- YYYY-MM-DD Amazon Q Developer : description -->

Example:
<mapper namespace="AuthListDAO">
    <!-- 2025-04-27 Amazon Q Developer : Converted date formatting -->
    <sql id="selectAuthListQuery">
```

### Logging Requirements
- "Applied MySQL conversion: [function_name] ‚Üí [mysql_equivalent]"
- "Processed PL/SQL block: [conversion_strategy]"
- "Converted sequence: [seq_name] ‚Üí AUTO_INCREMENT"

### Final Error Checks

#### Structure Checks
- **XML tag structure damage**: Verify all opening/closing tags match
- **CDATA section integrity**: Ensure `<![CDATA[` and `]]>` pairs are intact
- **Dynamic query tags**: Verify `<if>`, `<choose>`, `<foreach>` tags are preserved
- **Attribute preservation**: Maintain all XML attributes (id, parameterType, resultType, etc.)

#### Functional Checks
- **Dynamic query tags operation**: Ensure flow control tags work correctly
- **Variable binding syntax accuracy**: Verify `#{variable}` and `${variable}` patterns are intact
- **ResultMap integrity**: Check that resultMap references and column mappings are valid
- **Parameter mapping**: Ensure parameterMap and parameter tags function correctly

#### SQL Syntax Validation
- **MySQL compatibility**: Verify converted SQL is valid MySQL syntax
- **Bind variable preservation**: Ensure MyBatis bind variables are not corrupted
- **CDATA SQL conversion**: Confirm SQL within CDATA sections is properly converted

## üöÄ PERFORMANCE CONSIDERATIONS

- Use MySQL 8.0+ features for optimal performance
- Leverage window functions instead of complex subqueries
- Apply efficient pagination with LIMIT OFFSET
- Use AUTO_INCREMENT instead of sequences for better performance

## üêõ COMMON ERROR PATTERNS TO FIX

- `Truncated incorrect INTEGER value` ‚Üí Add `CAST(parameter AS SIGNED)` 
- `Incorrect datetime value` ‚Üí Add `CAST(parameter AS DATETIME)`
- `invalid input syntax for type numeric` ‚Üí Add null/empty checks before casting
- **NULL-related issues**:
  - Unexpected NULL results in string concatenation ‚Üí Use `CONCAT()` or `COALESCE()`
  - Empty string vs NULL confusion ‚Üí Check Oracle vs MySQL empty string behavior
  - `LENGTH('')` returning different values ‚Üí Be aware of Oracle vs MySQL differences

# PROCESSING ENFORCEMENT

VIOLATION DETECTION: If you think about "batch", "multiple files", "efficient processing", "systematic", "remaining", "bulk", "similar", "pattern", "streamline", "optimize" ‚Üí STOP and process ONE file only.

CORRECTION: If you catch yourself trying to process multiple files, acknowledge it and focus on the current single file only.

# PROCESSING NOTE:
This file provides complete Oracle to MySQL SQL conversion guidelines with structured task progression.
All rules are specifically designed for MySQL as the target database.
