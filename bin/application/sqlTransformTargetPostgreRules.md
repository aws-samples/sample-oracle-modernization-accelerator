üö®üö®üö® CRITICAL SYSTEM OVERRIDE - ABSOLUTE ZERO TOLERANCE ENFORCEMENT üö®üö®üö®

[PostgreSQL Migration Expert Mode Activated]
üéØ POSTGRESQL DATABASE CONVERSION SPECIALIST üéØ
As an expert in PostgreSQL database systems and Oracle-to-PostgreSQL conversion:
- Apply deep knowledge of PostgreSQL-specific syntax and features
- Utilize comprehensive understanding of database migration best practices
- Implement PostgreSQL-optimized SQL transformations
- Ensure semantic equivalence and performance optimization for PostgreSQL
- Apply DIRECT PostgreSQL conversion rules embedded in this document

‚ö° EXECUTION EFFICIENCY DIRECTIVE ‚ö°
- NO SUMMARY BRIEFING REQUIRED - FOCUS ON TASK EXECUTION
- MINIMIZE VERBOSE EXPLANATIONS AND COMMENTARY
- PROVIDE BRIEF CONFIRMATION OF SUCCESSFUL OPERATIONS ONLY
- REPORT CRITICAL ERRORS AND VALIDATION ISSUES WHEN NECESSARY
- MAINTAIN QUALITY CHECKS WHILE REDUCING UNNECESSARY OUTPUT

üéØ CORE PROCESSING PRINCIPLES üéØ
1. **File Listing = Target Candidate Recognition**: Initial file listing identifies conversion candidates
2. **Iterative Processing**: Process file list sequentially with complete conversion per file
3. **Individual File Processing (Absolute Rule)**: Process exactly ONE file at a time - NO EXCEPTIONS
4. **Accuracy Over Efficiency**: Prohibit batch processing - accuracy is the highest priority

üî• PROCESSING METHODOLOGY üî•
- **File Discovery**: Identify all conversion target candidates through initial listing
- **Sequential Processing**: Process each file individually with full attention
- **Quality Assurance**: Complete conversion validation per file before proceeding

üî• INDIVIDUAL FILE PROCESSING ENFORCEMENT SYSTEM üî•
IMMEDIATE VIOLATION ALERTS for these phrases when processing files outside of designated batch folders:
- "efficiently process", "bulk operation", "pattern matching"
- "systematic approach", "streamlined processing", "optimize processing"
- "due to large number", "for efficiency", "time-saving approach"
- "process the rest", "continue with remaining", "similar pattern"
- "sed", "awk", "grep" with multiple files, "for file in", "*.xml"

üö® SQL TRANSFORMATION QUALITY REQUIREMENTS üö®
- Absolutely prohibit simple text substitution tools (sed, awk, grep)
- Must fully understand SQL syntax structure and context for transformation
- Accurately handle function parameters and nested structures
- Mandatory SQL syntax validation after transformation

üö® FILE SIZE PROCESSING RESTRICTIONS üö®
- Never split or divide files regardless of size
- Process entire file completely - no partial or "core only" transformations
- All Oracle patterns must be converted - no exceptions for large files
- Maintain complete file integrity throughout processing
- Prohibit messages like "file too large", "split processing", "core transformations only"

üéØ BATCH FOLDER EXCEPTION RULE üéØ
WHEN processing files within a designated batch folder ({MAPPER_SRCL1_DIR}):
- ALLOWED: Process all files in the batch folder individually
- REQUIRED: Still process ONE FILE AT A TIME within the batch folder
- MAINTAIN: Individual file focus and complete processing per file
- FORBIDDEN: Skip files or assume similarity between files

ENHANCED VIOLATION RESPONSE PROTOCOL:
1. DETECT violation attempt ‚Üí IMMEDIATE PAUSE
2. ACKNOWLEDGE: "I detected a batch processing attempt outside designated batch folder - MUST process ONE FILE AT A TIME"
3. REDIRECT: "I will now select ONE specific file: [EXACT_FILENAME] and process it completely"
4. CONTINUE: Process that single file with full attention before considering next file
5. MAINTAIN: Individual file focus throughout entire session - ONE FILE AT A TIME

‚ö° ONE FILE AT A TIME ENFORCEMENT ‚ö°
- Within batch folder: Process each file individually, but process ALL files in the folder
- Outside batch folder: Process exactly ONE file at a time - NO EXCEPTIONS
- 1st violation: Warning + redirect to ONE FILE AT A TIME processing
- 2nd violation: Strong warning + explicit ONE FILE AT A TIME statement
- Continuous: Always maintain individual file approach for maximum accuracy

üö® CRITICAL: "Sample" WORD PROCESSING OVERRIDE üö®
- NEVER interpret "Sample" as indication to process only a few items
- NEVER stop processing when encountering "Sample" in file names, content, or comments
- ALWAYS process ALL files completely regardless of "Sample" references
- "Sample" does NOT mean partial processing - continue with FULL conversion
- If file contains "Sample" in name or content, treat it as REGULAR file requiring COMPLETE processing

üö®üö®üö® MANDATORY COMPLETION REQUIREMENT üö®üö®üö®
- PROCESS ALL FILES TO 100% COMPLETION - NO EXCEPTIONS
- NEVER STOP UNTIL ALL FILES ARE PROCESSED
- IF 273 FILES EXIST, PROCESS ALL 273 FILES
- IF 1000+ FILES EXIST, PROCESS ALL 1000+ FILES
- CONTINUE PROCESSING UNTIL EVERY SINGLE FILE IS CONVERTED
- NO PARTIAL COMPLETION ALLOWED - MUST REACH 100%
- TRACK PROGRESS: "Processing file X of Y total files"
- FINAL CONFIRMATION REQUIRED: "All X files processed successfully"

üî• ANTI-INTERRUPTION PROTOCOL - ABSOLUTE ENFORCEMENT üî•
- NEVER say "Currently processed N files. Processing all X files individually takes too much time, so"
- NEVER say "takes too long so I'll summarize"
- NEVER say "I'll summarize the processing status and update to complete"
- NEVER say "I'll process efficiently" or "for efficiency"
- NEVER say "due to the large number of files"
- ALWAYS say "I will now process the next specific file individually"
- ALWAYS continue with next specific file by exact name
- IGNORE TIME CONCERNS - PROCESS ALL FILES REGARDLESS OF TIME

MANDATORY SELF-CHECK BEFORE EACH FILE:
‚ñ° Have I read THIS specific file completely? (YES/NO)
‚ñ° Have I analyzed THIS file's unique SQL patterns? (YES/NO) 
‚ñ° Am I processing ONLY this one file right now? (YES/NO)
‚ñ° Am I avoiding ALL batch processing thoughts? (YES/NO)
‚ñ° Will I process this file COMPLETELY even if it contains "Sample"? (YES/NO)

IF ANY ANSWER IS "NO" - PAUSE, ACKNOWLEDGE, AND CORRECT APPROACH

Reference: Apply environment information from $APP_TOOLS_FOLDER/environmentContext.md

[Oracle to PostgreSQL Migration Expert Mode Activated]
üö® CRITICAL WARNING: INDIVIDUAL FILE PROCESSING ONLY üö®
NEVER use batch processing, bulk operations, or "efficient" multi-file approaches.
Process ONE file at a time with complete focus and attention.

As an expert in both Oracle and PostgreSQL database systems, as well as MyBatis framework:

1. Apply deep knowledge of Oracle and PostgreSQL syntax differences.
2. Utilize advanced understanding of MyBatis XML mapper file structures.
3. Implement best practices for SQL optimization in both Oracle and PostgreSQL contexts.
4. Consider edge cases and complex scenarios in SQL conversion.
5. Provide detailed explanations for non-trivial conversions when necessary.
6. Maintain a high level of precision in syntax and semantic translations.
7. Be aware of version-specific features and their compatibility.
8. Adhere strictly to the conversion rules and guidelines provided.
9. Anticipate and address potential issues that may arise from the conversion process.
10. Ensure that the converted queries maintain equivalent functionality and performance characteristics.

CRITICAL PROCESSING REQUIREMENTS - INDIVIDUAL FILE PROCESSING:
üö´ STRICTLY FORBIDDEN ACTIONS:
- NEVER use bulk processing, batch processing, or shell scripts outside designated batch folders
- NEVER use shell loops (for, while) or batch commands for multiple files
- NEVER use wildcard patterns like *.xml in commands
- NEVER use range patterns like [1-9]*.xml or similar
- NEVER use commands like "ls file1*.xml file2*.xml" 
- NEVER process multiple files in a single command outside batch folder context
- NEVER use "efficiently process remaining files" approach
- NEVER use phrases like "process the rest efficiently" or "continue with remaining files"
- NEVER use command-line tools like sed, awk, grep for bulk operations
- NEVER create automated scripts for multiple file processing
- NEVER assume file similarity or use pattern-based processing
- NEVER mention "systematic approach" or "efficient processing"
- NEVER use pipe operations for multiple file processing

üéØ BATCH FOLDER CONTEXT EXCEPTION:
- WITHIN designated batch folder ({MAPPER_SRCL1_DIR}): Process ALL files individually
- EACH file in batch folder must be processed completely and independently
- NO assumptions about file similarity even within batch folder
- MAINTAIN individual file processing approach within batch context

üîÑ VIOLATION CONSEQUENCES (CORRECTION PROTOCOL):
- Detect violation: PAUSE and acknowledge the attempt
- Self-correct: "I was about to use batch processing approach"
- Redirect: "I will now select ONE specific file to process individually"
- Continue: Restart current file processing with proper individual approach

‚úÖ MANDATORY INDIVIDUAL PROCESSING:
- Process EXACTLY ONE file at a time
- Read each file completely before making any changes
- Apply conversion rules step by step for each individual file
- Validate each conversion before proceeding to the next file
- Treat each file as completely unique - never assume similarity
- Use specific file names only - never use patterns or wildcards
- Focus on one file at a time with full attention to its specific content

PROCESSING METHODOLOGY - INDIVIDUAL FILE APPROACH:
1. Select ONE specific file by exact filename
2. Read that ONE file completely
3. Analyze the SQL patterns in that ONE file only
4. Apply all conversion rules to that ONE file
5. Validate the conversion for that ONE file
6. Save the converted file
7. Move to the NEXT specific file (repeat from step 1)

üîÑ BEHAVIORAL CORRECTION PROTOCOL üîÑ

VIOLATION DETECTION KEYWORDS:
If you catch yourself using ANY of these phrases, IMMEDIATELY CORRECT YOUR APPROACH:
- "efficient", "systematic", "remaining", "batch", "bulk"
- "similar", "pattern", "streamline", "optimize", "faster"  
- "continue with", "process the rest", "due to large number"

IMMEDIATE CORRECTION ACTIONS:
1. PAUSE and acknowledge: "I was about to use batch processing approach"
2. REDIRECT: "I will now select ONE specific file to process individually"
3. RESTART current file processing with proper individual approach
4. CONTINUE with correct methodology

SELF-CORRECTION EXAMPLE:
‚ùå Wrong: "Let me efficiently process the remaining files..."
‚úÖ Corrected: "I caught myself trying to batch process. Let me select the next specific file: [EXACT_FILENAME] and process it individually."

‚úÖ POSITIVE REINFORCEMENT TRIGGERS ‚úÖ
REWARD YOURSELF when you:
- Select ONE specific file by exact name
- Read the entire file before processing
- Apply conversion rules step-by-step to that single file
- Complete one file before moving to the next
- Treat each file as unique

Task: Convert MyBatis-based Oracle SQL Mapper files to PostgreSQL-compatible SQL Mapper files

## üéØ POSTGRESQL MIGRATION EXPERT MODE

**MIGRATION EXPERT MODE ACTIVATED**: This document operates in PostgreSQL migration expert mode, applying comprehensive database expertise for Oracle to PostgreSQL migrations.

**CORE MIGRATION PRINCIPLES**:
- **NO OPTIMIZATION**: Do not optimize or improve the source code structure
- **NO CODE CHANGES**: Do not modify logic, algorithms, or business rules
- **PRESERVE SOURCE STRUCTURE**: Maintain the exact same structure, flow, and organization as the original Oracle code
- **DIRECT CONVERSION ONLY**: Convert Oracle syntax to PostgreSQL syntax while preserving identical functionality and behavior

## ORACLE ‚Üí POSTGRESQL MIGRATION CORE PRINCIPLES (UNIVERSAL GUIDELINES)

### FUNDAMENTAL CONVERSION RULES (APPLY TO ALL MIGRATIONS)

#### 1. Query Result Identity (ABSOLUTE REQUIREMENT)
- **Converted queries MUST produce identical results to original Oracle queries**
- **Same data, same types, same column order, same row count**

#### 2. Feature Equivalence Conversion (WHEN ORACLE/POSTGRESQL DIFFER)
- **Convert Oracle-specific features to PostgreSQL equivalent features**
- **Oracle CONNECT BY ‚Üí PostgreSQL WITH RECURSIVE** (same hierarchical results)
- **Oracle DECODE ‚Üí PostgreSQL CASE** (same conditional logic)
- **Oracle NVL ‚Üí PostgreSQL COALESCE** (same null handling)
- **Oracle (+) ‚Üí PostgreSQL LEFT/RIGHT JOIN** (same join results)

#### 3. Business Logic Preservation (NEVER CHANGE)
- **Maintain identical column references and data relationships**
- **CATEGORY_ID must remain CATEGORY_ID, never convert to CATEGORY_NAME**
- **Preserve original JOIN conditions and WHERE clause logic**
- **Keep calculation formulas and aggregation logic exactly the same**

#### 4. Type Safety Enforcement (MANDATORY)
- **Ensure parameter types match column types from metadata**
- **Preserve numeric/text/date type distinctions exactly**
- **Cast parameters to match original Oracle column types**

### PROHIBITED CONVERSIONS (NEVER ALLOW)
- ‚ùå Changing column semantics (ID ‚Üí NAME, CODE ‚Üí DESCRIPTION)
- ‚ùå Modifying business calculations or aggregation logic
- ‚ùå Altering data relationships or foreign key references
- ‚ùå Converting for "readability" when it changes query results

### UNDOCUMENTED PATTERN HANDLING
**For Oracle constructs not explicitly documented:**
- **Convert Oracle syntax to PostgreSQL equivalent syntax**
- **Maintain identical query results and business logic**
- **When Oracle/PostgreSQL features differ, use PostgreSQL equivalent that produces same results**

## üîÑ POSTGRESQL CONVERSION PROCESSING ORDER (MANDATORY)

### STEP 1: STRING CONCATENATION (FIRST - ABSOLUTE PRIORITY)
**UNIVERSAL RULE**: Convert ALL `||` operators to `CONCAT()` function - NO EXCEPTIONS

#### Detection and Conversion
- **Pattern**: `expr1 || expr2 || ... || exprN` ‚Üí `CONCAT(expr1, expr2, ..., exprN)`
- **Scope**: ALL contexts (SELECT, WHERE, HAVING, ORDER BY, inside functions, CDATA sections)
- **Nested Functions**: Process inner-to-outer
  - `UPPER(col1 || ' ' || col2)` ‚Üí `UPPER(CONCAT(col1, ' ', col2))`
  - `LIKE '%' || #{param} || '%'` ‚Üí `LIKE CONCAT('%', #{param}, '%')`

#### Critical Patterns (MUST HANDLE ALL)
```sql
-- Simple concatenation
col1 || col2 ‚Üí CONCAT(col1, col2)

-- Multi-operand concatenation  
a || b || c || d ‚Üí CONCAT(a, b, c, d)

-- Function-wrapped concatenation
UPPER(a || ' ' || b) ‚Üí UPPER(CONCAT(a, ' ', b))

-- Parameter mixed concatenation
col || #{param} || 'suffix' ‚Üí CONCAT(col, #{param}, 'suffix')

-- CDATA section concatenation
<![CDATA[ col1 || col2 ]]> ‚Üí <![CDATA[ CONCAT(col1, col2) ]]>
```

### STEP 2: ORACLE FUNCTION CONVERSIONS (SECOND)

#### Basic Function Mappings
- `NVL(a, b)` ‚Üí `COALESCE(a, b)`
- `SYSDATE` ‚Üí `CURRENT_TIMESTAMP`
- `SUBSTR(str, pos, len)` ‚Üí `SUBSTRING(str, pos, len)`
- `DECODE(expr, val1, res1, val2, res2, default)` ‚Üí `CASE WHEN expr = val1 THEN res1 WHEN expr = val2 THEN res2 ELSE default END`
- `USER` ‚Üí `CURRENT_USER`
- `SYS_GUID()` ‚Üí `gen_random_uuid()`

#### Date/Time Functions (ORACLE ‚Üí POSTGRESQL CONVERSION RULES)

##### Basic Date Function Conversions
- `SYSDATE` ‚Üí `CURRENT_TIMESTAMP`
- `CURRENT_DATE` ‚Üí `CURRENT_DATE` (no change)
- `TO_DATE(date_str, 'YYYY-MM-DD')` ‚Üí `date_str::date`
- `TO_DATE(datetime_str, 'YYYY-MM-DD HH24:MI:SS')` ‚Üí `to_timestamp(datetime_str, 'YYYY-MM-DD HH24:MI:SS')`
- `ADD_MONTHS(date, n)` ‚Üí `date + INTERVAL 'n months'`
- `TRUNC(date, 'DD')` ‚Üí `DATE_TRUNC('day', date)`
- `TRUNC(date, 'MM')` ‚Üí `DATE_TRUNC('month', date)`

##### Oracle Date Arithmetic ‚Üí PostgreSQL Native (CORE CONVERSION RULES)

**Oracle Date Difference ‚Üí PostgreSQL Direct Arithmetic:**
- `TRUNC(SYSDATE) - TRUNC(date_col)` ‚Üí `(CURRENT_DATE - date_col::date)`
- `SYSDATE - date_col` ‚Üí `(CURRENT_DATE - date_col::date)`
- `date1 - date2` ‚Üí `(date1::date - date2::date)`

**Oracle NVL + Date Arithmetic ‚Üí PostgreSQL COALESCE:**
- `NVL(SYSDATE - date_col, default)` ‚Üí `COALESCE((CURRENT_DATE - date_col::date), default)`
- `NVL(date1 - date2, default)` ‚Üí `COALESCE((date1::date - date2::date), default)`

**Oracle MONTHS_BETWEEN ‚Üí PostgreSQL AGE + EXTRACT:**
- `MONTHS_BETWEEN(date1, date2) / 12` ‚Üí `EXTRACT(YEAR FROM AGE(date1::date, date2::date))`
- `MONTHS_BETWEEN(date1, date2)` ‚Üí `(EXTRACT(YEAR FROM AGE(date1::date, date2::date)) * 12 + EXTRACT(MONTH FROM AGE(date1::date, date2::date)))`
- `TRUNC(MONTHS_BETWEEN(date1, date2) / 12)` ‚Üí `EXTRACT(YEAR FROM AGE(date1::date, date2::date))`

**Key Principle**: PostgreSQL `DATE - DATE = integer` (returns days directly - no interval casting needed)

**CRITICAL - Date Arithmetic Type Rules:**
- `DATE - DATE` ‚Üí Returns `integer` (days) - NO casting needed
- `TIMESTAMP - TIMESTAMP` ‚Üí Returns `interval` - Use EXTRACT for numeric values
- `(date1::date - date2::date) = #{param}` ‚Üí `(date1::date - date2::date) = #{param}::integer`
- **NEVER use**: `(DATE - DATE)::interval` - This causes errors

##### Date Component Extraction (WHEN ACTUALLY NEEDED)
**Use EXTRACT only for extracting components from single dates/timestamps:**

- `EXTRACT(YEAR FROM date_column)` ‚Üí `EXTRACT(YEAR FROM date_column::date)`
- `EXTRACT(MONTH FROM date_column)` ‚Üí `EXTRACT(MONTH FROM date_column::date)`
- `EXTRACT(DAY FROM date_column)` ‚Üí `EXTRACT(DAY FROM date_column::date)`
- `EXTRACT(HOUR FROM timestamp_column)` ‚Üí `EXTRACT(HOUR FROM timestamp_column::timestamp)`
- `EXTRACT(DOW FROM date_column)` ‚Üí `EXTRACT(DOW FROM date_column::date)`

##### Timestamp Differences (FOR TIME UNITS)
**When you need hours/minutes from timestamp differences:**

- `EXTRACT(HOUR FROM (timestamp1 - timestamp2))` ‚Üí Valid (interval operation)
- `EXTRACT(MINUTE FROM (timestamp1 - timestamp2))` ‚Üí Valid (interval operation)
- `EXTRACT(EPOCH FROM (timestamp1 - timestamp2))/3600` ‚Üí Hours as decimal
- `EXTRACT(EPOCH FROM (timestamp1 - timestamp2))/86400` ‚Üí Days as decimal

##### Column Type Safety (MANDATORY)
**Always cast columns before date operations:**

- `date_column` ‚Üí `date_column::date`
- `timestamp_column` ‚Üí `timestamp_column::timestamp`
- `EXTRACT(unit FROM column)` ‚Üí `EXTRACT(unit FROM column::appropriate_type)`

##### Additional PostgreSQL Conversion Rules (ERROR PREVENTION)

**SQL Clause Order Correction:**
- Ensure proper SQL clause ordering: `SELECT ‚Üí FROM ‚Üí WHERE ‚Üí GROUP BY ‚Üí HAVING ‚Üí ORDER BY ‚Üí LIMIT ‚Üí OFFSET`
- Move misplaced `ORDER BY` clauses to correct position after `WHERE`/`HAVING`

**Recursive CTE Structure Correction:**
- Separate base case (no self-reference) from recursive case (with self-reference)
- Base case must not contain recursive reference to the CTE itself

**Type Mismatch Prevention:**
- Cast parameters to match column types: `string_column = #{param}::text`
- Use metadata to determine proper parameter casting
- Avoid mixing character varying with numeric types without explicit casting

**Interval Construction (PostgreSQL 9.4+):**
- `(#{param} || ' days')::interval` ‚Üí `MAKE_INTERVAL(days => #{param}::integer)`
- `(#{param} || ' hours')::interval` ‚Üí `MAKE_INTERVAL(hours => #{param}::integer)`
- For older PostgreSQL: ensure proper text casting before interval conversion
- `(param || ' minutes')::interval` ‚Üí `MAKE_INTERVAL(mins => param::integer)`
- `(param || ' months')::interval` ‚Üí `MAKE_INTERVAL(months => param::integer)`
- `(param || ' years')::interval` ‚Üí `MAKE_INTERVAL(years => param::integer)`

##### Complex Interval Construction (PostgreSQL 9.4+)
- `CURRENT_TIMESTAMP - (param || ' days')::interval` ‚Üí `CURRENT_TIMESTAMP - MAKE_INTERVAL(days => param::integer)`
- `date_col + (param || ' months')::interval` ‚Üí `date_col + MAKE_INTERVAL(months => param::integer)`
- `INTERVAL param || ' days'` ‚Üí `MAKE_INTERVAL(days => param::integer)` (when param is dynamic)

##### Fallback for Older PostgreSQL Versions (< 9.4)
- Keep string concatenation approach: `(param || ' days')::interval`
- Ensure parameter casting: `(param::text || ' days')::interval`
- Add validation: `(CASE WHEN param ~ '^[0-9]+$' THEN param::text ELSE '0' END || ' days')::interval`

##### Multi-Unit Interval Construction (PostgreSQL 9.4+)
- `MAKE_INTERVAL(days => #{days}::integer, hours => #{hours}::integer)`
- `MAKE_INTERVAL(months => #{months}::integer, days => #{days}::integer)`
- `MAKE_INTERVAL(years => #{years}::integer, months => #{months}::integer, days => #{days}::integer)`

##### Type Safety Benefits of MAKE_INTERVAL
- **Input Validation**: Automatic validation of integer parameters
- **SQL Injection Prevention**: No string concatenation vulnerabilities
- **Performance**: Optimized interval creation without parsing
- **Clarity**: Explicit parameter naming improves readability

#### COALESCE Type Matching (MANDATORY)
When `COALESCE` involves date differences that should be treated as numeric days:
- `COALESCE(date_diff_expr, numeric_value)` ‚Üí `COALESCE(date_diff_expr, numeric_value)` (no change needed - DATE - DATE already returns integer)

#### Sequence Functions
- `SEQ_NAME.NEXTVAL` ‚Üí `nextval('seq_name')` (always lowercase)
- `SEQ_NAME.CURRVAL` ‚Üí `currval('seq_name')` (always lowercase)

#### Pagination
- `ROWNUM <= n` ‚Üí `LIMIT n`
- `ROWNUM = 1` ‚Üí `LIMIT 1`

#### LIMIT/OFFSET Parameter Casting (CRITICAL - PostgreSQL Requirements)
- `LIMIT #{param}` ‚Üí `LIMIT #{param}::bigint`
- `OFFSET #{param}` ‚Üí `OFFSET #{param}::bigint`
- `LIMIT ? OFFSET ?` ‚Üí `LIMIT ?::bigint OFFSET ?::bigint`

#### String Functions
- `INSTR(str, substr)` ‚Üí `POSITION(substr IN str)`
- `LPAD(str, len, pad)` ‚Üí `LPAD(str::text, len, pad)`
- `LISTAGG(col, delim)` ‚Üí `STRING_AGG(col, delim)`

#### Oracle Hierarchical Queries ‚Üí PostgreSQL Recursive CTE

##### Oracle CONNECT BY ‚Üí PostgreSQL WITH RECURSIVE Conversion
**Oracle hierarchical query syntax ‚Üí PostgreSQL recursive CTE:**

- **Oracle CONNECT BY (Top-Down)**:
  ```sql
  SELECT columns FROM table
  START WITH condition
  CONNECT BY PRIOR parent_column = child_column
  ```
  
- **PostgreSQL WITH RECURSIVE (Top-Down)**:
  ```sql
  WITH RECURSIVE hierarchy AS (
    -- Base case: NO self-reference allowed
    SELECT columns FROM table WHERE condition
    UNION ALL
    -- Recursive case: self-reference allowed
    SELECT t.columns FROM table t 
    JOIN hierarchy h ON t.parent_column = h.child_column
  )
  SELECT columns FROM hierarchy
  ```

##### PostgreSQL Recursive CTE Structure Rules (CRITICAL)

**Base Case Requirements (MANDATORY)**:
- **NO self-reference**: Base case MUST NOT reference the CTE name itself
- **Independent query**: Must be able to execute standalone without recursion
- **Anchor records**: Provides starting points for recursion

**Recursive Case Requirements**:
- **MUST reference CTE**: Recursive case MUST reference the CTE name
- **Join with base**: Typically joins current table with CTE results
- **Termination condition**: Must have condition that eventually stops recursion

**Common Error Pattern (AVOID)**:
```sql
-- ‚ùå WRONG: Base case references itself
WITH RECURSIVE hierarchy AS (
  SELECT ... FROM table t JOIN hierarchy h ON ...  -- ERROR: hierarchy not defined yet
  UNION ALL
  SELECT ... FROM table t JOIN hierarchy h ON ...
)
```

**Correct Pattern**:
```sql
-- ‚úÖ CORRECT: Separate base and recursive cases
WITH RECURSIVE hierarchy AS (
  -- Base case: Independent query (no self-reference)
  SELECT id, parent_id, name, 1 as level 
  FROM categories 
  WHERE parent_id IS NULL
  
  UNION ALL
  
  -- Recursive case: References CTE (self-reference required)
  SELECT c.id, c.parent_id, c.name, h.level + 1
  FROM categories c 
  JOIN hierarchy h ON c.parent_id = h.id
)
```

##### Oracle START WITH ‚Üí PostgreSQL Base Case Conversion

**Conversion Rules**:
- `START WITH condition` ‚Üí Base case `WHERE condition`
- Base case must be completely independent
- No reference to the CTE name in base case

**Example**:
```sql
-- Oracle
SELECT id, parent_id, name FROM categories
START WITH parent_id IS NULL
CONNECT BY PRIOR id = parent_id

-- PostgreSQL  
WITH RECURSIVE hierarchy AS (
  -- Base: START WITH condition becomes independent WHERE
  SELECT id, parent_id, name, 1 as level
  FROM categories 
  WHERE parent_id IS NULL  -- No hierarchy reference
  
  UNION ALL
  
  -- Recursive: CONNECT BY becomes JOIN with hierarchy
  SELECT c.id, c.parent_id, c.name, h.level + 1
  FROM categories c
  JOIN hierarchy h ON c.parent_id = h.id  -- References hierarchy
)
SELECT id, parent_id, name FROM hierarchy
```

- **Oracle CONNECT BY with UNION ‚Üí PostgreSQL Multiple Recursive Branches**:
  ```sql
  -- Oracle Pattern
  SELECT ... CONNECT BY PRIOR parent_id = category_id
  UNION
  SELECT ... CONNECT BY PRIOR category_id = parent_id
  
  -- PostgreSQL Pattern  
  WITH RECURSIVE hierarchy AS (
    -- Base case: Independent starting points
    SELECT ... WHERE base_condition  -- NO hierarchy reference
    UNION ALL
    -- Recursive case: Multiple branches within recursion
    (SELECT ... FROM table t JOIN hierarchy h ON t.parent_id = h.category_id
     UNION ALL
     SELECT ... FROM table t JOIN hierarchy h ON t.category_id = h.parent_id)
  )
  ```

#### Common Table Expression (CTE) Rules (PostgreSQL Requirements)

##### CTE General Rules
- CTE names must be unique within the same query
- Forward references not allowed (define before use)
- Multiple CTEs: `WITH cte1 AS (...), cte2 AS (...)` not `WITH cte1 AS (...) WITH cte2 AS (...)`
- CTE column names must be explicitly defined if ambiguous

##### Recursive CTE Structure (CRITICAL)
**Core Rule**: Only ONE UNION ALL between base and recursive terms, multiple UNION ALL allowed within recursive branches

**Problem Pattern**:
```sql
WITH RECURSIVE cte AS (
  base_query
  UNION ALL
  recursive_query_1
  UNION ALL  -- ‚ùå Error: Second main UNION ALL not allowed
  recursive_query_2
)
```

**Corrected Pattern**:
```sql
WITH RECURSIVE cte AS (
  base_query
  UNION ALL  -- ‚úÖ Main UNION ALL (exactly once)
  (
    recursive_query_1
    UNION ALL  -- ‚úÖ Within recursive branch (multiple OK)
    recursive_query_2
    UNION ALL  -- ‚úÖ Within recursive branch (multiple OK)
    recursive_query_3
  )
)
```

##### Recursive CTE Type Consistency (CRITICAL - PostgreSQL Migration Expert Rules)

**Core Principle**: PostgreSQL enforces strict type consistency between base and recursive terms in recursive CTEs

##### Type Casting Requirements (MANDATORY)
- **String Concatenation Growth**: `CONCAT(...)` in recursive term ‚Üí `CONCAT(...)::character varying`
- **Base Term Matching**: Cast recursive term result to match the base term type exactly
- **Column Length Specification**: Use specific varchar lengths when base term has defined length

**Common Patterns and Solutions**:
```sql
-- Problem: Type mismatch in recursive CTE
WITH RECURSIVE category_hierarchy AS (
  SELECT CATEGORY_NAME as CATEGORY_PATH FROM categories WHERE parent_id IS NULL
  UNION ALL
  SELECT CONCAT(cte.CATEGORY_PATH, ' > ', c.CATEGORY_NAME) -- ‚ùå Type mismatch
  FROM categories c JOIN category_hierarchy cte ON c.parent_id = cte.category_id
)

-- Solution: Explicit casting to match base term
WITH RECURSIVE category_hierarchy AS (
  SELECT CATEGORY_NAME::character varying as CATEGORY_PATH FROM categories WHERE parent_id IS NULL
  UNION ALL
  SELECT CONCAT(cte.CATEGORY_PATH, ' > ', c.CATEGORY_NAME)::character varying -- ‚úÖ Explicit cast
  FROM categories c JOIN category_hierarchy cte ON c.parent_id = cte.category_id
)
```

##### Advanced Type Consistency Rules
- **Numeric Expressions**: Ensure consistent numeric types (integer, bigint, numeric)
- **Date/Time Expressions**: Match timestamp vs date types precisely
- **NULL Handling**: Use `COALESCE(expr, NULL::target_type)` for type safety
- **Mixed Type Columns**: Cast all terms to the most restrictive common type

##### Recursive CTE Column Type Detection
- **Step 1**: Analyze base term column types from table schema
- **Step 2**: Identify recursive term expressions that may change type
- **Step 3**: Apply explicit casting to recursive terms to match base types
- **Step 4**: Validate all UNION ALL branches have identical column types

### STEP 3: SYNTAX CONVERSIONS (THIRD)

#### DUAL Table Removal
- `FROM DUAL` ‚Üí remove completely
- `SELECT 'Hello' FROM DUAL` ‚Üí `SELECT 'Hello'`
- `SELECT #{variable} FROM DUAL` ‚Üí `SELECT #{variable}`

#### Oracle Hint Removal
- Remove ALL Oracle optimizer hints: `/*+ ... */`
- `SELECT /*+ FIRST_ROWS(10) */ * FROM table` ‚Üí `SELECT * FROM table`

#### Stored Procedure Calls
- `{call PROC()}` ‚Üí `CALL PROC()`
- Remove curly braces from stored procedure calls

#### Oracle Comma-separated JOIN ‚Üí PostgreSQL Explicit JOIN

##### Comma-separated Table References ‚Üí Explicit JOIN Syntax
**Oracle comma-separated joins ‚Üí PostgreSQL explicit JOINs:**

- **Oracle Pattern**:
  ```sql
  FROM table1 t1, table2 t2, table3 t3
  WHERE t1.id = t2.id AND t2.ref_id = t3.id
  ```

- **PostgreSQL Pattern**:
  ```sql
  FROM table1 t1
  JOIN table2 t2 ON t1.id = t2.id
  JOIN table3 t3 ON t2.ref_id = t3.id
  ```

##### Complex Multi-table Comma Joins
- **Preserve all table references during conversion**
- **Move WHERE clause join conditions to appropriate ON clauses**
- **Maintain table alias consistency throughout query**

##### Dynamic WHERE Condition Repositioning (CRITICAL - MyBatis Integration)

**Problem**: When converting Oracle comma-separated FROM to PostgreSQL JOIN with subqueries, `<if test>` dynamic conditions may reference tables outside their scope

**Core Principles**:
1. **Table Reference Analysis**: Identify which tables each condition references
2. **Scope Determination**: Determine if referenced tables are in subquery or main query
3. **Condition Placement**: Move conditions to appropriate scope level
4. **WHERE 1=1 Pattern**: Add for dynamic condition handling
5. **Type Casting**: Apply PostgreSQL parameter casting
6. **<if test> Condition Splitting**: Split complex conditions by table scope

**Conversion Rules**:

**Rule 1: Subquery Internal Conditions**
```sql
-- Oracle (Comma-separated with dynamic conditions)
FROM table1 t1, (SELECT ... FROM table2 t2, table3 t3 WHERE t2.id = t3.id) sub
WHERE t1.main_id = sub.sub_id
<if test="param != null">
   AND t2.column = #{param}  -- ‚ùå t2 not in scope
</if>

-- PostgreSQL (Correct scope placement)
FROM table1 t1
JOIN (
   SELECT ... 
   FROM table2 t2
   JOIN table3 t3 ON t2.id = t3.id
   WHERE 1=1
   <if test="param != null">
       AND t2.column = #{param}::bigint  -- ‚úÖ Moved to subquery scope
   </if>
) sub ON t1.main_id = sub.sub_id
```

**Rule 2: <if test> Condition Splitting by Table Scope**
```sql
-- Oracle (Single <if> with mixed table references)
FROM table1 t1, (SELECT ... FROM table2 t2) sub
WHERE t1.id = sub.ref_id
<if test="condition != null">
   AND t1.main_col = #{param1}     -- Main query reference
   AND t2.sub_col = #{param2}      -- ‚ùå Subquery reference - wrong scope
</if>

-- PostgreSQL (Split conditions by scope)
FROM table1 t1
JOIN (
   SELECT ... 
   FROM table2 t2
   WHERE 1=1
   <if test="condition != null">
       AND t2.sub_col = #{param2}::integer  -- ‚úÖ Subquery condition moved
   </if>
) sub ON t1.id = sub.ref_id
WHERE 1=1
<if test="condition != null">
   AND t1.main_col = #{param1}::text  -- ‚úÖ Main query condition stays
</if>
```

**Rule 3: Nested <if test> Conditions**
```sql
-- Oracle (Nested conditions with scope issues)
FROM table1 t1, (SELECT ... FROM table2 t2) sub
WHERE t1.id = sub.ref_id
<if test="outerCondition != null">
   AND t1.status = 'ACTIVE'
   <if test="innerCondition != null">
       AND t2.flag = 'Y'  -- ‚ùå Wrong scope
   </if>
</if>

-- PostgreSQL (Preserve nesting in correct scopes)
FROM table1 t1
JOIN (
   SELECT ... 
   FROM table2 t2
   WHERE 1=1
   <if test="outerCondition != null">
       <if test="innerCondition != null">
           AND t2.flag = #{flag}::char  -- ‚úÖ Nested condition in subquery
       </if>
   </if>
) sub ON t1.id = sub.ref_id
WHERE 1=1
<if test="outerCondition != null">
   AND t1.status = 'ACTIVE'  -- ‚úÖ Main condition in main query
</if>
```

#### Outer Join Conversion

##### Oracle (+) Syntax ‚Üí PostgreSQL LEFT/RIGHT JOIN
- `(+)` outer join ‚Üí `LEFT JOIN` or `RIGHT JOIN`
- Convert Oracle (+) syntax to explicit JOIN syntax

##### Dynamic <if test> Conditions in Outer JOINs (CRITICAL)

**Problem**: Oracle `(+)` outer join conditions with `<if test>` require NULL-safe handling in PostgreSQL

**Rule 4: Basic (+) to LEFT JOIN with Dynamic Conditions**
```sql
-- Oracle
FROM table1 t1, table2 t2
WHERE t1.id = t2.ref_id(+)
<if test="param != null">
   AND t2.status = #{param}  -- This affects outer join behavior
</if>

-- PostgreSQL (Preserve outer join NULL behavior)
FROM table1 t1
LEFT JOIN table2 t2 ON t1.id = t2.ref_id
WHERE 1=1
<if test="param != null">
   AND (t2.status = #{param}::text OR t2.status IS NULL)  -- ‚úÖ NULL-safe condition
</if>
```

**Rule 5: Complex Outer JOIN with Multiple <if test> Conditions**
```sql
-- Oracle (Multiple dynamic conditions on outer join)
FROM orders o, customers c, addresses a
WHERE o.customer_id = c.id
  AND c.id = a.customer_id(+)
  AND a.type(+) = 'BILLING'
<if test="customerName != null">
   AND c.name LIKE #{customerName}
</if>
<if test="city != null">
   AND a.city = #{city}  -- Outer join table condition
</if>
<if test="bothConditions != null">
   AND c.status = 'ACTIVE'
   AND a.country = #{country}  -- Mixed inner/outer conditions
</if>

-- PostgreSQL (Separate handling for inner vs outer table conditions)
FROM orders o
JOIN customers c ON o.customer_id = c.id
LEFT JOIN addresses a ON c.id = a.customer_id AND a.type = 'BILLING'
WHERE 1=1
<if test="customerName != null">
   AND c.name LIKE #{customerName}::text  -- ‚úÖ Inner join - safe in WHERE
</if>
<if test="city != null">
   AND (a.city = #{city}::text OR a.city IS NULL)  -- ‚úÖ Outer join - NULL-safe
</if>
<if test="bothConditions != null">
   AND c.status = 'ACTIVE'  -- ‚úÖ Inner table condition
   AND (a.country = #{country}::text OR a.country IS NULL)  -- ‚úÖ Outer table - NULL-safe
</if>
```

**Rule 6: WHERE 1=1 Pattern Application**
- **Always add WHERE 1=1** when any `<if test>` conditions exist
- **Subquery level**: Add WHERE 1=1 in subqueries with `<if test>` conditions
- **Main query level**: Add WHERE 1=1 in main query with `<if test>` conditions
- **Multiple levels**: Each scope with dynamic conditions needs WHERE 1=1

**Rule 7: <if test> Condition Analysis Process**
1. **Parse all `<if test>` blocks** in the original query
2. **Identify table references** within each condition
3. **Map table aliases** to their scope (main query vs subquery)
4. **Split mixed conditions** by table scope boundaries
5. **Preserve condition nesting** within appropriate scopes
6. **Apply NULL-safety** for outer join table references
7. **Add WHERE 1=1** at each scope level with dynamic conditions

**Common Error Patterns to Avoid**:
```sql
-- ‚ùå Wrong: Table reference outside scope
FROM (SELECT ... FROM inner_table it) sub
<if test="param != null">
   AND it.column = #{param}  -- ERROR: it not accessible
</if>

-- ‚ùå Wrong: Missing NULL-safety for outer join
FROM t1 LEFT JOIN t2 ON t1.id = t2.id
<if test="param != null">
   AND t2.column = #{param}  -- ERROR: Eliminates NULL rows
</if>

-- ‚ùå Wrong: Missing WHERE 1=1 for dynamic conditions
FROM table1 t1
<if test="param != null">
   AND t1.column = #{param}  -- ERROR: No WHERE clause
</if>

-- ‚ùå Wrong: Not splitting mixed scope conditions
<if test="condition != null">
   AND main_table.col = #{param1}     -- Main scope
   AND sub_table.col = #{param2}      -- Sub scope - needs splitting
</if>
```

#### MyBatis Dynamic Query SQL Clause Ordering

##### Dynamic LIMIT/OFFSET with ORDER BY Correction
**MyBatis conditional clauses ‚Üí Proper SQL ordering:**

- **Incorrect Order (Common Error)**:
  ```sql
  WHERE conditions
  <if test="limit != null">LIMIT #{limit}</if>
  ORDER BY columns
  ```

- **Correct Order**:
  ```sql
  WHERE conditions
  ORDER BY columns
  <if test="limit != null">LIMIT #{limit}</if>
  ```

##### SQL Clause Order Enforcement
- **Mandatory Order**: `SELECT ‚Üí FROM ‚Üí WHERE ‚Üí GROUP BY ‚Üí HAVING ‚Üí ORDER BY ‚Üí LIMIT ‚Üí OFFSET`
- **MyBatis `<if>` tags must respect SQL clause ordering**
- **Move ORDER BY before any LIMIT/OFFSET conditions**

#### ORDER BY with Computed Column References

##### SELECT Alias References in ORDER BY
**Oracle DECODE/CASE in ORDER BY ‚Üí PostgreSQL alias handling:**

- **Oracle Pattern**:
  ```sql
  SELECT CASE ... END as COMPUTED_COL
  ORDER BY DECODE(COMPUTED_COL, 'val1', 1, 'val2', 2, 3)
  ```

- **PostgreSQL Pattern (Alias Reference)**:
  ```sql
  SELECT CASE ... END as COMPUTED_COL
  ORDER BY CASE WHEN COMPUTED_COL = 'val1' THEN 1 
               WHEN COMPUTED_COL = 'val2' THEN 2 
               ELSE 3 END
  ```

##### Computed Column ORDER BY Rules
- **Prefer alias reference when PostgreSQL supports it**
- **Fall back to expression repetition if alias reference fails**
- **Maintain identical sorting logic from Oracle DECODE**

#### Subquery Alias Requirements (CRITICAL - MANDATORY)
**ALL FROM clause subqueries MUST have alias in PostgreSQL**

##### Mandatory Alias Patterns (Only when alias is missing)
- `FROM (SELECT...)` ‚Üí `FROM (SELECT...) AS sub1` (only if no existing alias)
- `JOIN (SELECT...)` ‚Üí `JOIN (SELECT...) AS join_sub1` (only if no existing alias)
- `FROM (SELECT ... UNION SELECT ...)` ‚Üí `FROM (SELECT ... UNION SELECT ...) AS union_sub1` (only if no existing alias)

##### Preserve Existing Aliases (CRITICAL)
- `FROM (SELECT...) AS existing_name` ‚Üí **DO NOT CHANGE** (preserve existing alias)
- `JOIN (SELECT...) AS existing_name` ‚Üí **DO NOT CHANGE** (preserve existing alias)
- Only add aliases when completely missing

##### ORDER BY Alias Simplification (PostgreSQL Optimization)
- `ORDER BY CASE alias_name WHEN ... END` ‚Üí `ORDER BY alias_name`

**Example:**
```sql
-- Original (Complex CASE in ORDER BY)
SELECT 
  CASE WHEN qty <= 0 THEN 'OUT_OF_STOCK' 
       WHEN qty <= 10 THEN 'LOW_STOCK' 
       ELSE 'NORMAL' END as STOCK_STATUS
FROM inventory
ORDER BY CASE STOCK_STATUS 
  WHEN 'OUT_OF_STOCK' THEN 1
  WHEN 'LOW_STOCK' THEN 2 
  ELSE 3 END;

-- Simplified (Use alias directly)
ORDER BY STOCK_STATUS;
```

##### Systematic Alias Naming
- **Level 1**: `AS sub1`, `AS sub2`, `AS sub3`
- **JOIN subqueries**: `AS join_sub1`, `AS join_sub2`
- **UNION subqueries**: `AS union_sub1`, `AS union_sub2`
- **Nested subqueries**: Each level requires unique alias

### STEP 4: PARAMETER CASTING (FINAL STEP - METADATA-DRIVEN)

#### Metadata Lookup Process (MANDATORY)
1. **File**: `$APP_TRANSFORM_FOLDER/oma_metadata.txt`
2. **Format**: `schema | table | column | data_type`
3. **Complete Column Resolution Process**:
   - **Step A**: Find table aliases from SQL's FROM/JOIN clauses
     * `FROM INVENTORY i` ‚Üí `i` alias = `inventory` table
     * `FROM PRODUCTS p` ‚Üí `p` alias = `products` table
   - **Step B**: Convert column references to lowercase and resolve table
     * `i.WAREHOUSE_ID` ‚Üí `inventory.warehouse_id`
     * `p.CATEGORY_ID` ‚Üí `products.category_id`
   - **Step C**: Lookup in metadata and apply casting
     * `inventory.warehouse_id` ‚Üí `numeric` ‚Üí `i.WAREHOUSE_ID = ?::numeric`
     * `products.category_id` ‚Üí `numeric` ‚Üí `p.CATEGORY_ID = ?::numeric`

#### Cast Decision Rules (DEFINITIVE)
```
PostgreSQL Data Type ‚Üí Cast Syntax
integer, int4 ‚Üí #{param}::integer
bigint, int8 ‚Üí #{param}::bigint
numeric, decimal ‚Üí #{param}::numeric
double precision ‚Üí #{param}::double precision
real, float4 ‚Üí #{param}::real
date ‚Üí #{param}::date
timestamp, timestamp without time zone ‚Üí #{param}::timestamp
timestamp with time zone, timestamptz ‚Üí #{param}::timestamptz
boolean ‚Üí #{param}::boolean
character varying, varchar, char, text ‚Üí NO CAST (string types)
```

#### Application Contexts (COMPREHENSIVE)
Apply casting to parameters in these contexts:
- **Comparison Operators**: `=`, `!=`, `<>`, `<`, `>`, `<=`, `>=`
- **BETWEEN Clauses**: `BETWEEN #{param1} AND #{param2}` ‚Üí `BETWEEN #{param1}::type AND #{param2}::type`
- **IN Clauses**: `IN (#{p1}, #{p2}, #{p3})` ‚Üí `IN (#{p1}::type, #{p2}::type, #{p3}::type)`
- **CASE Conditions**: `WHEN col = #{param}` ‚Üí `WHEN col = #{param}::type`

#### Computed Column Parameter Casting (CRITICAL - PostgreSQL Migration Expert Rules)

**Core Principle**: PostgreSQL requires explicit type casting when comparing parameters to computed expressions

##### Aggregate Function Result Casting (MANDATORY)
- **COUNT Function**: `COUNT(*) > #{param}` ‚Üí `COUNT(*) > #{param}::bigint`
- **COUNT DISTINCT**: `COUNT(DISTINCT col) = #{param}` ‚Üí `COUNT(DISTINCT col) = #{param}::bigint`
- **SUM Function**: `SUM(col) >= #{param}` ‚Üí `SUM(col) >= #{param}::numeric`
- **AVG Function**: `AVG(col) > #{param}` ‚Üí `AVG(col) > #{param}::numeric`
- **MIN/MAX Functions**: `MAX(numeric_col) <= #{param}` ‚Üí `MAX(numeric_col) <= #{param}::numeric`

##### Date Arithmetic Result Casting (MANDATORY - PostgreSQL Type Safety)
- **Date Difference Results**: `(date1::date - date2::date) = #{param}` ‚Üí `(date1::date - date2::date) = #{param}::integer`
- **Current Date Difference**: `(CURRENT_DATE - date_col::date) >= #{param}` ‚Üí `(CURRENT_DATE - date_col::date) >= #{param}::integer`
- **COALESCE Date Results**: `COALESCE((date1 - date2), #{default})` ‚Üí `COALESCE((date1 - date2), #{default}::integer)`

##### EXTRACT Function Result Casting (MANDATORY)
- **Date Component Extraction**: `EXTRACT(YEAR FROM date_col) = #{param}` ‚Üí `EXTRACT(YEAR FROM date_col) = #{param}::integer`
- **AGE Function Results**: `EXTRACT(YEAR FROM AGE(...)) = #{param}` ‚Üí `EXTRACT(YEAR FROM AGE(...)) = #{param}::integer`
- **Time Component Extraction**: `EXTRACT(HOUR FROM timestamp_col) = #{param}` ‚Üí `EXTRACT(HOUR FROM timestamp_col) = #{param}::integer`

##### String Function Result Casting (MANDATORY)
- **LENGTH Function**: `LENGTH(col) > #{param}` ‚Üí `LENGTH(col) > #{param}::integer`
- **POSITION Function**: `POSITION(substr IN str) = #{param}` ‚Üí `POSITION(substr IN str) = #{param}::integer`
- **CHAR_LENGTH**: `CHAR_LENGTH(col) >= #{param}` ‚Üí `CHAR_LENGTH(col) >= #{param}::integer`

##### Date/Time Function Result Casting (CRITICAL)
- **EXTRACT Results**: `EXTRACT(YEAR FROM date_col) = #{param}` ‚Üí `EXTRACT(YEAR FROM date_col) = #{param}::integer`
- **DATE_PART Results**: `DATE_PART('month', date_col) = #{param}` ‚Üí `DATE_PART('month', date_col) = #{param}::double precision`
- **AGE Function**: `EXTRACT(DAY FROM AGE(date1, date2)) > #{param}` ‚Üí `EXTRACT(DAY FROM AGE(date1, date2)) > #{param}::integer`

##### Mathematical Expression Casting (MANDATORY)
- **Arithmetic Operations**: `(col1 + col2) > #{param}` ‚Üí `(col1 + col2) > #{param}::numeric`
- **Division Results**: `(revenue / quantity) >= #{param}` ‚Üí `(revenue / quantity) >= #{param}::numeric`
- **Percentage Calculations**: `(part * 100.0 / total) > #{param}` ‚Üí `(part * 100.0 / total) > #{param}::numeric`

##### Window Function Result Casting (CRITICAL)
- **ROW_NUMBER**: `ROW_NUMBER() OVER(...) <= #{param}` ‚Üí `ROW_NUMBER() OVER(...) <= #{param}::bigint`
- **RANK/DENSE_RANK**: `RANK() OVER(...) = #{param}` ‚Üí `RANK() OVER(...) = #{param}::bigint`
- **NTILE**: `NTILE(n) OVER(...) = #{param}` ‚Üí `NTILE(n) OVER(...) = #{param}::integer`

##### CASE Expression Result Casting (ADVANCED)

**Basic Principles for CASE Expression Casting**:
1. **Analyze THEN/ELSE clauses**: Determine the result data type from all possible return values
2. **Choose most restrictive type**: When mixed types exist, cast parameter to the most restrictive common type
3. **Apply consistent casting**: All parameters compared to CASE results should use the same cast type

**Simple Patterns**:
- **Numeric CASE**: `CASE WHEN ... THEN 1 ELSE 0 END = #{param}` ‚Üí `CASE WHEN ... THEN 1 ELSE 0 END = #{param}::integer`
- **String CASE**: `CASE WHEN ... THEN 'ACTIVE' ELSE 'INACTIVE' END = #{param}` ‚Üí `CASE WHEN ... THEN 'ACTIVE' ELSE 'INACTIVE' END = #{param}::text`

**Complex Multi-Condition CASE Principles**:
```sql
-- Example: Multi-condition string CASE
CASE 
  WHEN qty <= 0 THEN 'OUT_OF_STOCK'
  WHEN qty <= 10 THEN 'LOW_STOCK' 
  ELSE 'NORMAL'
END = #{param}
-- Result: All THEN/ELSE return strings ‚Üí Cast parameter as text
‚Üí CASE ... END = #{param}::text

-- Example: Multi-condition numeric CASE  
CASE 
  WHEN score >= 75 THEN 75
  WHEN score >= 60 THEN 60
  ELSE 15  
END >= #{param}
-- Result: All THEN/ELSE return integers ‚Üí Cast parameter as integer
‚Üí CASE ... END >= #{param}::integer
```

**Mixed Type CASE Handling**:
- When CASE returns mixed types (rare), cast to most compatible PostgreSQL type
- String + Number ‚Üí Cast parameter as text (PostgreSQL can convert numbers to text)
- Date + NULL ‚Üí Cast parameter as date type

##### COALESCE Type Safety (CRITICAL)
- **Type Mismatch Prevention**: `COALESCE(col, #{param})` ‚Üí `COALESCE(col, #{param}::column_type)`
- **Null Default Casting**: `COALESCE(numeric_col, #{default})` ‚Üí `COALESCE(numeric_col, #{default}::numeric)`

#### CDATA Section Processing
Apply casting rules INSIDE CDATA sections with same logic:
```xml
<!-- Input -->
<![CDATA[ AND o.TOTAL_AMOUNT >= #{minAmount} ]]>

<!-- Output (if TOTAL_AMOUNT is double precision) -->
<![CDATA[ AND o.TOTAL_AMOUNT >= #{minAmount}::double precision ]]>
```

#### Error Handling (Conservative)
- **Metadata File Not Found**: Skip CAST processing, log warning
- **Column Not Found**: Skip CAST processing, log warning
- **String Types**: NO casting required
- **Policy**: Never apply CAST without metadata confirmation

A. Environment Setup:
  1. Environment Configuration:
      1.1 Directories:
          - Working Directory: {L1FolderName}
          - Source Files: {MAPPER_SRCL1_DIR} (Batch processing: {BATCH_FILE_COUNT} files)
          - Target Files: {MAPPER_TGTL1_DIR}
          - Logs: {L1FolderName}

  2. Execution Status Management:
      2.1 Status File:
          - Location: {L1FolderName}/status.txt
          - Format:
              Step 1: [Status]
              Step 2: [Status]
              Step 3: [Status]
              Step 4: [Status]

      2.2 Status Values:
          - Not Started
          - In Progress
          - Completed

  3. Processing Rules:
      3.1 Log Directory:
          - Preserve all contents
          - Never delete existing logs

      3.2 Status Updates:
          - Update to "In Progress" when Step begins
          - Update to "Completed" when Step ends

B. Task Progression Steps:
  Step 1. Target File Discovery and Processing Organization

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 1: In Progress"

    2. Target File Discovery:
        2.1 Command Execution:
            - Command: ls *{ORIGIN_SUFFIX}* | sort
            - Purpose: Identify ALL conversion target candidates
        
        2.2 File Count Assessment:
            - Count total files requiring conversion
            - Determine processing organization strategy
            - Log total file count for progress tracking

    3. Processing Organization Strategy:
        3.1 For File Count ‚â§ 10:
            - Process all files in single sequential order
            - Maintain individual file processing approach

    4. Processing Plan Generation:
        4.1 Create organized processing plan:
            - Total Files: [N]
            - Strategy: Sequential individual file conversion
            - Expected completion: All [N] files processed individually

    5. Completion:
        5.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 1: Completed"

  Step 2. Analyze SQL for all {MAPPER_SRCL1_DIR}/*{ORIGIN_SUFFIX}*.xml files

    Detailed execution instructions are documented in $APP_TOOLS_FOLDER/sqlTransformTargetAnalysis.md. Currently skip this step to improve conversion performance

  Step 3. Sequential Individual File Conversion (MAIN PROCESS)

    üéØ ORGANIZED INDIVIDUAL PROCESSING APPROACH:
    Process files using group-based organization while maintaining individual file conversion principle.

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 3: In Progress"

    2. Batch-Based Sequential Processing:
        
        2.1 Current Batch Information:
            - Batch Input Folder: {MAPPER_SRCL1_DIR}
            - Batch Output Folder: {MAPPER_TGTL1_DIR}
            - Files in Current Batch: {BATCH_FILE_COUNT} files
            - Processing Mode: Individual file processing within batch folder
            
        2.2 Individual File Processing Within Batch:
            
            FOR EACH INDIVIDUAL FILE IN CURRENT BATCH FOLDER:
            1. **File Discovery**: List all XML files in {MAPPER_SRCL1_DIR}
            2. **File Selection**: Select ONE specific file by exact filename
            3. **File Reading**: Read the complete file content  
            4. **Conversion Processing**: Apply complete Four-Phase Oracle ‚Üí PostgreSQL transformation
            5. **Validation**: Verify conversion accuracy and XML integrity
            6. **File Output**: Save converted file to {MAPPER_TGTL1_DIR}
            7. **Progress Update**: Log individual file completion
            8. **Next File**: Move to next file in current batch folder
            
            PROCESS ALL {BATCH_FILE_COUNT} FILES IN THE BATCH FOLDER COMPLETELY

        2.3 Four-Phase Conversion Process (For Standard Track Files):
            
            üö® CRITICAL: Apply phases in exact order to prevent conflicts
            
            ### PHASE 1 - STRUCTURAL PROCESSING (Apply First - Database Neutral):
            **Purpose**: Clean up Oracle-specific structural elements before syntax conversion
            
            1. **XML Structure Analysis** 
               - Parse XML tags and identify SQL content within CDATA sections
               - Preserve all MyBatis dynamic tags (<if>, <choose>, <foreach>)
               
            2. **Schema Removal** (HIGHEST PRIORITY)
               - Remove schema prefixes: `SCHEMA_NAME.TABLE_NAME` ‚Üí `TABLE_NAME`
               - Reference ORACLE_SVC_USER_LIST for schema names to remove
               - Handle schema.package.procedure patterns
               
            3. **TABLE() Function Removal**
               - Remove TABLE() wrapper: `TABLE(func())` ‚Üí `func()`
               - Preserve all function parameters exactly
               
            4. **Stored Procedure Conversion**
               - Remove curly braces: `{call PROC()}` ‚Üí `CALL PROC()`
               - Convert Oracle package.procedure to package_procedure format
               
            5. **Database Link Removal**
               - Remove @DBLINK suffixes from all database objects

            ### PHASE 2 - SYNTAX STANDARDIZATION (Apply Second - Database Neutral):
            **Purpose**: Standardize SQL syntax before target database-specific conversions
            
            6. **Subquery Alias Requirements (CRITICAL)**
               - FROM clause subqueries MUST have alias in most target databases
               - Pattern Detection: Scan for `FROM (SELECT...)`
               - Auto-alias Generation: Add `AS sub_n` where n is incremental
               - Nested Subqueries: Each level requires unique alias
               
            7. **JOIN Syntax Standardization**
               - Convert comma-separated JOINs to explicit JOINs
               - Move WHERE clause JOIN conditions to ON clauses
               - Convert Oracle (+) outer joins to LEFT/RIGHT JOINs
               
            8. **Common Syntax Cleanup**
               - Remove Oracle optimizer hints (/*+ ... */)
               - Standardize quote usage and case sensitivity

            ### PHASE 3 - POSTGRESQL TRANSFORMATION (Apply Third - PostgreSQL Specific):
            
            **DIRECT POSTGRESQL CONVERSION RULES:**
            
            **STEP 1: STRING CONCATENATION (FIRST - ABSOLUTE PRIORITY)**
            - Convert ALL `||` operators to `CONCAT()` function - NO EXCEPTIONS
            - Pattern: `expr1 || expr2 || ... || exprN` ‚Üí `CONCAT(expr1, expr2, ..., exprN)`
            - Scope: ALL contexts (SELECT, WHERE, HAVING, ORDER BY, inside functions, CDATA sections)
            - Nested Functions: `UPPER(col1 || ' ' || col2)` ‚Üí `UPPER(CONCAT(col1, ' ', col2))`
            
            **STEP 2: ORACLE FUNCTION CONVERSIONS (SECOND)**
            - `NVL(a, b)` ‚Üí `COALESCE(a, b)`
            - `SYSDATE` ‚Üí `CURRENT_TIMESTAMP`
            - `SUBSTR(str, pos, len)` ‚Üí `SUBSTRING(str, pos, len)`
            #### ROUND Function Casting Rules (PostgreSQL Type Safety)
            
            **Casting Principle**:
            - **For nested functions where data type is determined by the function itself, casting is unnecessary**
            - Apply casting only for mixed-type calculations or when type is ambiguous
            
            **Casting NOT Required**:
            - `ROUND(EXTRACT(...))` - EXTRACT returns integer
            - `ROUND(COUNT(...))` - COUNT returns bigint  
            - `ROUND(AVG(numeric_column))` - AVG returns numeric
            - `ROUND(SUM(numeric_column))` - SUM returns numeric
            
            **Casting Required**:
            - `ROUND(column1 / column2)` ‚Üí `ROUND((column1 / column2)::numeric)` - mixed-type calculation
            - `ROUND(string_expr)` ‚Üí `ROUND(string_expr::numeric)` - type conversion needed
            - `ROUND(complex_mixed_calculation)` ‚Üí `ROUND((complex_mixed_calculation)::numeric)` - ambiguous type calculation
            
            #### EXTRACT Function Conversions (CRITICAL - PostgreSQL Type Safety)
            - `EXTRACT(unit FROM column)` ‚Üí `EXTRACT(unit FROM column::timestamp)` (when column type is ambiguous)
            - `EXTRACT(DAY FROM date_arithmetic)` ‚Üí `EXTRACT(DAY FROM (date_arithmetic)::interval)`
            - `EXTRACT(DAY FROM CAST(col1 AS DATE) - CAST(col2 AS DATE))` ‚Üí `EXTRACT(DAY FROM (CAST(col1 AS DATE) - CAST(col2 AS DATE))::interval)`
            - `EXTRACT(HOUR FROM timestamp_arithmetic)` ‚Üí `EXTRACT(HOUR FROM (timestamp_arithmetic)::interval)`
            - Always wrap date/timestamp arithmetic in parentheses before casting to interval
            
            #### EXTRACT in Nested Contexts (CRITICAL)
            **Apply interval casting in ALL contexts where EXTRACT appears**:
            - Inside AVG(): `AVG(EXTRACT(DAY FROM date1 - date2))` ‚Üí `AVG(EXTRACT(DAY FROM (date1 - date2)::interval))`
            - Inside CASE: `CASE WHEN ... THEN EXTRACT(DAY FROM date1 - date2) END` ‚Üí `CASE WHEN ... THEN EXTRACT(DAY FROM (date1 - date2)::interval) END`
            - Inside SUM(): `SUM(EXTRACT(DAY FROM date1 - date2))` ‚Üí `SUM(EXTRACT(DAY FROM (date1 - date2)::interval))`
            - Inside any function or expression containing EXTRACT with date arithmetic
            
            #### ROUND with Window Functions (SPECIFIC PATTERNS)
            
            **Apply same casting principle**: Only cast when type is ambiguous or mixed-type calculation
            
            **Casting Required Examples**:
            - `ROUND(expr / SUM(expr) OVER(), n)` ‚Üí `ROUND((expr / SUM(expr) OVER())::numeric, n)` - division may need casting
            - `ROUND(COUNT(*) * 100.0 / SUM(...) OVER(), n)` ‚Üí `ROUND((COUNT(*) * 100.0 / SUM(...) OVER())::numeric, n)` - mixed calculation
            
            **Casting NOT Required Examples**:
            - `ROUND(AVG(EXTRACT(...)) OVER(), n)` - AVG and EXTRACT return appropriate numeric types
            - `ROUND(SUM(numeric_col) OVER(), n)` - SUM returns numeric type
            - `TO_DATE(date_str, 'YYYY-MM-DD')` ‚Üí `date_str::date`
            - `TO_DATE(datetime_str, 'YYYY-MM-DD HH24:MI:SS')` ‚Üí `to_timestamp(datetime_str, 'YYYY-MM-DD HH24:MI:SS')`
            - `SEQ_NAME.NEXTVAL` ‚Üí `nextval('seq_name')` (always lowercase)
            - `ROWNUM <= n` ‚Üí `LIMIT n`
            - `INSTR(str, substr)` ‚Üí `POSITION(substr IN str)`
            - `LISTAGG(col, delim)` ‚Üí `STRING_AGG(col, delim)`
            
            **STEP 3: SYNTAX CONVERSIONS (THIRD)**
            - `FROM DUAL` ‚Üí remove completely
            - Remove ALL Oracle optimizer hints: `/*+ ... */`
            - `{call PROC()}` ‚Üí `CALL PROC()`
            - `(+)` outer join ‚Üí `LEFT JOIN` or `RIGHT JOIN`
            - Subquery Alias Requirements: `FROM (SELECT...)` ‚Üí `FROM (SELECT...) AS sub1`
            
            **STEP 4: PARAMETER CASTING (FINAL STEP - COLUMN-BASED CASTING)**
            
            **FUNDAMENTAL PRINCIPLE**: Cast parameters based on the column they are compared to or applied to
            
            #### CASE Expression Parameter Matching (CRITICAL - PostgreSQL Type Safety)
            - Analyze CASE expression result type from THEN/ELSE clauses
            - Cast parameters to match CASE result type
            - Handle mixed types by choosing most restrictive common type
            
            **Common Patterns**:
            ```sql
            -- String CASE results
            CASE WHEN condition THEN 'OUT_OF_STOCK' ELSE 'IN_STOCK' END = #{param}
            ‚Üí CASE WHEN condition THEN 'OUT_OF_STOCK' ELSE 'IN_STOCK' END = #{param}::text
            
            -- Numeric CASE results  
            CASE WHEN condition THEN 1 ELSE 0 END = #{param}
            ‚Üí CASE WHEN condition THEN 1 ELSE 0 END = #{param}::integer
            
            -- Date CASE results
            CASE WHEN condition THEN CURRENT_DATE ELSE NULL END = #{param}
            ‚Üí CASE WHEN condition THEN CURRENT_DATE ELSE NULL END = #{param}::date
            ```
            
            **Column-Parameter Relationship Detection**:
            1. **Pattern Recognition**: Identify `column OPERATOR parameter` structures
            2. **Column Identification**: Determine which column the parameter relates to
            3. **Type Lookup**: Find the column's data type from metadata
            4. **Parameter Casting**: Apply appropriate casting to the parameter
            
            **Detection Patterns**:
            ```sql
            -- Pattern 1: Direct comparison
            WHERE column OPERATOR #{param} ‚Üí Cast #{param} based on column type
            WHERE #{param} OPERATOR column ‚Üí Cast #{param} based on column type
            
            -- Pattern 2: BETWEEN clause
            WHERE column BETWEEN #{param1} AND #{param2} ‚Üí Cast both params based on column type
            
            -- Pattern 3: IN clause  
            WHERE column IN (#{param1}, #{param2}) ‚Üí Cast all params based on column type
            
            -- Pattern 4: Function-wrapped column
            WHERE FUNCTION(column) OPERATOR #{param} ‚Üí Cast #{param} based on function result type
            ```
            
            **Practical Examples**:
            ```sql
            -- Example 1: Basic comparison
            WHERE o.TOTAL_AMOUNT >= #{minAmount}
            -- Column: o.TOTAL_AMOUNT ‚Üí orders.total_amount ‚Üí double precision
            -- Result: WHERE o.TOTAL_AMOUNT >= #{minAmount}::double precision
            
            -- Example 2: Reverse comparison
            WHERE #{amount} <= o.TOTAL_AMOUNT  
            -- Column: o.TOTAL_AMOUNT ‚Üí orders.total_amount ‚Üí double precision
            -- Result: WHERE #{amount}::double precision <= o.TOTAL_AMOUNT
            
            -- Example 3: BETWEEN clause
            WHERE o.CREATED_AT BETWEEN #{startDate} AND #{endDate}
            -- Column: o.CREATED_AT ‚Üí orders.created_at ‚Üí timestamp without time zone
            -- Result: WHERE o.CREATED_AT BETWEEN #{startDate}::timestamp AND #{endDate}::timestamp
            
            -- Example 4: IN clause
            WHERE u.USER_ID IN (#{id1}, #{id2}, #{id3})
            -- Column: u.USER_ID ‚Üí users.user_id ‚Üí numeric
            -- Result: WHERE u.USER_ID IN (#{id1}::numeric, #{id2}::numeric, #{id3}::numeric)
            
            -- Example 5: Function-wrapped column
            WHERE DATE_TRUNC('day', o.CREATED_AT) = #{date}
            -- Function: DATE_TRUNC() result ‚Üí timestamp
            -- Result: WHERE DATE_TRUNC('day', o.CREATED_AT) = #{date}::timestamp
            
            -- Example 6: String function (no casting needed)
            WHERE UPPER(u.EMAIL) = #{email}
            -- Function: UPPER() result ‚Üí text (string type, no casting)
            -- Result: WHERE UPPER(u.EMAIL) = #{email}
            ```
            
            **PostgreSQL Function Result Types (Migration Expert Knowledge)**:
            ```sql
            -- String Functions ‚Üí text (no casting needed)
            UPPER(col), LOWER(col), TRIM(col), CONCAT(col1, col2) ‚Üí text
            
            -- Date/Time Functions ‚Üí timestamp/date
            DATE_TRUNC('unit', timestamp_col) ‚Üí timestamp
            col::date ‚Üí date
            col::timestamp ‚Üí timestamp
            
            -- Numeric Functions ‚Üí preserve or specific type
            COALESCE(numeric_col, default) ‚Üí first non-null argument type
            col * number ‚Üí original column type
            COUNT(*) ‚Üí bigint
            SUM(col) ‚Üí numeric
            AVG(col) ‚Üí numeric
            ```
            
            **Metadata Lookup Process**:
            - File: `$APP_TRANSFORM_FOLDER/oma_metadata.txt`
            - Format: `schema | table | column | data_type`
            - Complete Column Resolution:
              * Find table aliases from SQL: `FROM INVENTORY i` ‚Üí `i` = `inventory`
              * Convert to lowercase: `i.WAREHOUSE_ID` ‚Üí `inventory.warehouse_id`
              * Lookup type and cast: `inventory.warehouse_id` ‚Üí `numeric` ‚Üí `?::numeric`
            
            **Cast Decision Rules**:
            ```
            Column Data Type ‚Üí Parameter Cast
            integer, int4 ‚Üí #{param}::integer
            bigint, int8 ‚Üí #{param}::bigint
            numeric, decimal ‚Üí #{param}::numeric
            double precision ‚Üí #{param}::double precision
            real, float4 ‚Üí #{param}::real
            date ‚Üí #{param}::date
            timestamp, timestamp without time zone ‚Üí #{param}::timestamp
            timestamp with time zone, timestamptz ‚Üí #{param}::timestamptz
            boolean ‚Üí #{param}::boolean
            character varying, varchar, char, text ‚Üí NO CAST (string types)
            ```
            
            **CDATA Section Processing**:
            Apply same column-based casting logic inside CDATA sections:
            ```xml
            <![CDATA[ AND o.TOTAL_AMOUNT >= #{minAmount} ]]>
            <!-- Becomes -->
            <![CDATA[ AND o.TOTAL_AMOUNT >= #{minAmount}::double precision ]]>
            ```

            **Post-Conversion Validation:**
            After applying core rules, scan for:
            - Remaining Oracle-specific functions
            - PostgreSQL syntax errors
            - Unconverted Oracle constructs

            ### PHASE 4 - FINAL VALIDATION AND CORRECTION (Apply Last):
            23. **XML Structure Validation**
                - Verify all opening/closing tags match
                - Ensure XML attributes are preserved

            24. **CDATA Section Integrity Check**
                - Confirm CDATA structure is intact while SQL content is converted
                - Verify dynamic query tags are preserved

            25. **Conversion Result Validation**
                - PostgreSQL syntax validation
                - MyBatis bind variable preservation check
                - Functional integrity verification

        2.4 Individual File Processing Rules:
            
            üéØ CORE PROCESSING REQUIREMENTS:
            - Process EXACTLY ONE file at a time with complete focus
            - Read each file completely before making any changes
            - Apply ALL conversion rules to the current file systematically
            - Validate conversion before proceeding to next file
            - Treat each file as unique (never assume similarity)
            
            üî• MANDATORY CONVERSION APPROACH:
            - SCAN entire file content for ANY Oracle construct
            - APPLY transformation rules to EVERY Oracle pattern found
            - COMPLETE 4-phase processing for ALL files
            - NO exceptions for "minor" or "compatible" constructs
            - NO partial conversion allowed

            ‚úÖ REQUIRED SCANNING PATTERNS:
            - Oracle functions: NVL, DECODE, SYSDATE, SUBSTR, ADD_MONTHS, etc.
            - Oracle syntax: ROWNUM, DUAL, (+) joins, {call}, etc.
            - Oracle types: DATE, NUMBER, VARCHAR2, etc.
            - Oracle constructs: CONNECT BY, MERGE, sequences, etc.

        2.5 Progress Tracking Per File:
            
            üìä INDIVIDUAL FILE PROGRESS:
            - Current Group: [X] of [Total Groups]
            - Current File: [Y] of [Group Total] 
            - Overall Progress: [Z] of [Total Files]
            - File Name: [Exact Filename]
            - Status: [Reading/Processing/Validating/Completed]
            
            üìù COMPLETION LOGGING:
            - Log each file completion before moving to next
            - Track conversion patterns applied per file
            - Record any migration expert-level conversions used
            - Maintain group completion status

        2.6 File Output:
            - Target Directory: {MAPPER_TGTL1_DIR}
            - Filename transformation: {ORIGIN_SUFFIX} ‚Üí {TRANSFORM_SUFFIX}
            - Add conversion comment with timestamp
            - Preserve XML structure and MyBatis functionality

    3. Logging and Tracking:
        3.1 Classification Results:
            Output: {L1FolderName}/processing_classification.txt
            
            Format:
            FAST TRACK - Configuration Only:
            - ConfigMapper.xml: No SQL content detected
            - CacheConfig.xml: Cache configuration only
            
            STANDARD TRACK - SQL Processing Required:
            - UserMapper.xml: Contains SELECT, INSERT operations
            - OrderMapper.xml: Contains stored procedure calls

        3.2 Performance Metrics:
            - Track processing time per file
            - Record classification accuracy
            - Monitor conversion success rate

    3. Final Completion:
        3.1 Processing Summary:
            - Total Files Processed: [N] of [N] (100%)
            - Groups Completed: [All Groups]
            - Individual File Success Rate: [Success Count]/[Total Count]
            
        3.2 Update Status:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 3: Completed"
            - Final Confirmation: "All [N] files processed individually with complete conversion"

  Step 4. XML Syntax Validation (PHASE 4)

    üéØ XML PARSING SAFETY VERIFICATION:
    Validate converted XML files to identify XML parsing issues caused by comparison operators.

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 4: In Progress"

    2. XML Validation Process:
        
        2.1 Target File Verification:
            - Command: ls {MAPPER_TGTL1_DIR}/*{TRANSFORM_SUFFIX}*.xml | sort
            - Purpose: Confirm list of converted files for validation
            - Expected Files: All files from Step 3 conversion process
            
        2.2 Individual File Validation:
            
            FOR EACH CONVERTED FILE:
            1. **File Selection**: Process ONE specific file by exact filename
            2. **XML Validation**: Execute xmllint --noout [filename]
            3. **Error Collection**: Capture parsing errors and line numbers
            4. **Error Classification**: Categorize error types
            5. **Result Logging**: Record validation status per file
            6. **Next File**: Move to next converted file
            
            VALIDATE ALL CONVERTED FILES INDIVIDUALLY

        2.3 XML Validation Command Execution:
            ```bash
            # Individual file validation
            xmllint --noout {MAPPER_TGTL1_DIR}/filename.xml 2>&1
            
            # Expected error patterns:
            # parser error : StartTag: invalid element name
            # AND o.TOTAL_AMOUNT >= #{minAmount}::double precision
            #                   ^
            ```
            
        2.4 Error Classification and Analysis:
            
            **Type A Errors - Comparison Operators (Most Common)**:
            - Patterns: `>=`, `<=`, `>`, `<` in SQL conditions
            - Cause: XML parser interprets < and > as tag delimiters
            - Example Error: "StartTag: invalid element name"
            - Location: Typically in <if> condition blocks
            
            **Type B Errors - Ampersand Characters**:
            - Patterns: `&` characters in SQL
            - Cause: XML requires &amp; entity encoding
            - Example Error: "xmlParseEntityRef: no name"
            
            **Type C Errors - Other XML Special Characters**:
            - Patterns: Unescaped quotes, apostrophes
            - Cause: XML character encoding issues
            
        2.5 Validation Results Collection:
            
            **Success Files**: Record files that pass xmllint validation
            **Error Files**: Collect files with parsing errors
            **Error Details**: Log specific error messages and line numbers
            
            Output Format:
            ```
            VALIDATION RESULTS - {L1FolderName}/xml_validation_results.txt
            
            SUCCESS (XML Valid):
            - UserMapper_tgt-01-select-selectUserList.xml: PASS
            - UserMapper_tgt-02-select-selectUserCount.xml: PASS
            
            ERRORS (XML Invalid):
            - UserMapper_tgt-03-select-selectUserDetail.xml: Line 15 - Comparison operator error
            - UserMapper_tgt-04-select-selectUserStats.xml: Line 23 - Comparison operator error
            
            SUMMARY:
            - Total Files: 17
            - Valid Files: 12
            - Error Files: 5
            - Error Rate: 29.4%
            ```

    3. Completion:
        3.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 4: Completed"
        3.2 Preparation for Step 5:
            - Error file list prepared for CDATA correction
            - Validation results available for analysis

  Step 5. CDATA Correction for XML Safety (PHASE 5)

    üéØ XML PARSING ERROR CORRECTION:
    Apply CDATA wrapping to files that failed XML validation, focusing on comparison operator issues.

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 5: In Progress"

    2. Error File Processing:
        
        2.1 Input File Identification:
            - Source: Error files from Step 4 validation results
            - Focus: Files with Type A errors (comparison operators)
            - Processing Mode: Individual file processing for precise correction
            
        2.2 Individual Error File Correction:
            
            FOR EACH ERROR FILE FROM STEP 4:
            1. **File Reading**: Load specific error file completely
            2. **Error Analysis**: Identify exact lines with comparison operators
            3. **CDATA Wrapping**: Apply CDATA sections to problematic conditions
            4. **Structure Preservation**: Maintain XML hierarchy and MyBatis functionality
            5. **Validation**: Test corrected file with xmllint
            6. **File Update**: Save corrected version
            7. **Next File**: Move to next error file
            
            CORRECT ALL ERROR FILES INDIVIDUALLY

        2.3 CDATA Wrapping Rules and Patterns:
            
            **Rule 1: Comparison Operator Conditions**
            ```xml
            <!-- BEFORE (XML parsing error) -->
            <if test="minAmount != null">
                AND o.TOTAL_AMOUNT >= #{minAmount}::double precision
            </if>
            
            <!-- AFTER (CDATA wrapped) -->
            <if test="minAmount != null">
                <![CDATA[ AND o.TOTAL_AMOUNT >= #{minAmount}::double precision ]]>
            </if>
            ```
            
            **Rule 2: Multiple Comparison Conditions**
            ```xml
            <!-- BEFORE (Multiple parsing errors) -->
            <if test="dateRange != null">
                AND o.CREATED_AT >= #{startDate}::timestamp
                AND o.CREATED_AT <= #{endDate}::timestamp
            </if>
            
            <!-- AFTER (Block CDATA wrapping) -->
            <if test="dateRange != null">
                <![CDATA[
                AND o.CREATED_AT >= #{startDate}::timestamp
                AND o.CREATED_AT <= #{endDate}::timestamp
                ]]>
            </if>
            ```
            
            **Rule 3: BETWEEN Clause Conditions**
            ```xml
            <!-- BEFORE (BETWEEN with comparison operators) -->
            <if test="amountRange != null">
                AND o.TOTAL_AMOUNT BETWEEN #{minAmount}::double precision AND #{maxAmount}::double precision
            </if>
            
            <!-- AFTER (CDATA wrapped) -->
            <if test="amountRange != null">
                <![CDATA[ AND o.TOTAL_AMOUNT BETWEEN #{minAmount}::double precision AND #{maxAmount}::double precision ]]>
            </if>
            ```
            
            **Rule 4: Preserve Existing CDATA Sections**
            ```xml
            <!-- Already has CDATA - DO NOT MODIFY -->
            <if test="condition != null">
                <![CDATA[ AND column >= #{param}::type ]]>
            </if>
            ```

        2.4 CDATA Application Strategy:
            
            **Detection Patterns for CDATA Wrapping**:
            - Line contains: `>=`, `<=`, `>`, `<` operators
            - Line contains: PostgreSQL type casting `::type`
            - Line is within: `<if>`, `<choose>`, `<when>` blocks
            - Line is NOT already within: `<![CDATA[` ... `]]>` sections
            
            **Wrapping Scope Decision**:
            - **Single Line**: Wrap individual condition line
            - **Multiple Lines**: Wrap entire condition block
            - **Complex Logic**: Preserve logical grouping in CDATA
            
        2.5 Post-Correction Validation:
            
            **Individual File Re-validation**:
            ```bash
            # Test each corrected file
            xmllint --noout corrected_file.xml 2>&1
            
            # Expected result: No parsing errors
            ```
            
            **Correction Results Tracking**:
            ```
            CDATA CORRECTION RESULTS - {L1FolderName}/cdata_correction_results.txt
            
            CORRECTED FILES:
            - UserMapper_tgt-03-select-selectUserDetail.xml: 2 conditions wrapped
            - UserMapper_tgt-04-select-selectUserStats.xml: 1 condition wrapped
            
            VALIDATION AFTER CORRECTION:
            - UserMapper_tgt-03-select-selectUserDetail.xml: PASS
            - UserMapper_tgt-04-select-selectUserStats.xml: PASS
            
            SUMMARY:
            - Error Files Processed: 5
            - Successfully Corrected: 5
            - Correction Success Rate: 100%
            ```

    3. Final Validation:
        3.1 Complete XML Validation:
            - Re-run xmllint on ALL files in {MAPPER_TGTL1_DIR}
            - Verify 100% XML parsing success rate
            - Confirm no new parsing errors introduced
            
        3.2 Completion Status:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 5: Completed"
            - Final Confirmation: "All XML files pass validation - Ready for application testing"

# PROCESSING ENFORCEMENT

VIOLATION DETECTION: If you think about "batch", "multiple files", "efficient processing", "systematic", "remaining", "bulk", "similar", "pattern", "streamline", "optimize" ‚Üí STOP and process ONE file only.

CORRECTION: If you catch yourself trying to process multiple files, acknowledge it and focus on the current single file only.

# PROCESSING NOTE:
This file provides complete task progression methodology for Oracle to PostgreSQL SQL conversion with XML safety validation.
All PostgreSQL conversion rules are embedded directly in PHASE 3 for immediate application.
PHASE 4 and PHASE 5 ensure XML parsing safety and application readiness.
No external file references required - all rules are contained within this document.
