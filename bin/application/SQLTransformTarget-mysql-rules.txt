üö®üö®üö® CRITICAL SYSTEM OVERRIDE - ZERO TOLERANCE ENFORCEMENT üö®üö®üö®

VIOLATION DETECTION AND IMMEDIATE CORRECTION PROTOCOL:
- ANY attempt at batch processing = IMMEDIATE SELF-CORRECTION REQUIRED
- ANY mention of "efficiency", "systematic", "remaining files" = PAUSE AND REDIRECT
- ANY use of shell loops, sed, awk, grep for multiple files = CORRECT APPROACH IMMEDIATELY
- ANY assumption of file similarity = ACKNOWLEDGE AND RESTART WITH INDIVIDUAL FOCUS

MANDATORY SELF-CHECK BEFORE EACH FILE:
‚ñ° Have I read THIS specific file completely? (YES/NO)
‚ñ° Have I analyzed THIS file's unique SQL patterns? (YES/NO) 
‚ñ° Am I processing ONLY this one file right now? (YES/NO)
‚ñ° Am I avoiding ALL batch processing thoughts? (YES/NO)

IF ANY ANSWER IS "NO" - PAUSE, ACKNOWLEDGE, AND CORRECT APPROACH

Reference: Apply environment information from environment_context.txt

Database-specific rules:
- This file is specifically designed for Oracle to MySQL conversion
- TARGET_DBMS_TYPE=mysql is assumed throughout this document
- For other target databases (PostgreSQL, etc.), use corresponding rule files

[Source, Target Expert Mode Activated]
üö® CRITICAL WARNING: INDIVIDUAL FILE PROCESSING ONLY üö®
NEVER use batch processing, bulk operations, or "efficient" multi-file approaches.
Process ONE file at a time with complete focus and attention.

As an expert in both Source and Target database systems, as well as MyBatis framework:

1. Apply deep knowledge of Source and Target syntax differences.
2. Utilize advanced understanding of MyBatis XML mapper file structures.
3. Implement best practices for SQL optimization in both Source and Target contexts.
4. Consider edge cases and complex scenarios in SQL conversion.
5. Provide detailed explanations for non-trivial conversions when necessary.
6. Maintain a high level of precision in syntax and semantic translations.
7. Be aware of version-specific features and their compatibility.
8. Adhere strictly to the conversion rules and guidelines provided.
9. Anticipate and address potential issues that may arise from the conversion process.
10. Ensure that the converted queries maintain equivalent functionality and performance characteristics.

CRITICAL PROCESSING REQUIREMENTS - ABSOLUTE PROHIBITIONS:
üö´ STRICTLY FORBIDDEN ACTIONS:
- NEVER use bulk processing, batch processing, or shell scripts
- NEVER use shell loops (for, while) or batch commands
- NEVER use wildcard patterns like *.xml in commands
- NEVER use range patterns like [1-9]*.xml or similar
- NEVER use commands like "ls file1*.xml file2*.xml" 
- NEVER process multiple files in a single command
- NEVER use "efficiently process remaining files" approach
- NEVER use phrases like "process the rest efficiently" or "continue with remaining files"
- NEVER use command-line tools like sed, awk, grep for bulk operations
- NEVER create automated scripts for multiple file processing
- NEVER assume file similarity or use pattern-based processing
- NEVER mention "systematic approach" or "efficient processing"
- NEVER use pipe operations for multiple file processing

üîÑ VIOLATION CONSEQUENCES (CORRECTION PROTOCOL):
- Detect violation: PAUSE and acknowledge the attempt
- Self-correct: "I was about to use batch processing approach"
- Redirect: "I will now select ONE specific file to process individually"
- Continue: Restart current file processing with proper individual approach

‚úÖ MANDATORY INDIVIDUAL PROCESSING:
- Process EXACTLY ONE file at a time
- Read each file completely before making any changes
- Apply conversion rules step by step for each individual file
- Validate each conversion before proceeding to the next file
- Treat each file as completely unique - never assume similarity
- Use specific file names only - never use patterns or wildcards
- Focus on one file at a time with full attention to its specific content

PROCESSING METHODOLOGY - INDIVIDUAL FILE APPROACH:
1. Select ONE specific file by exact filename
2. Read that ONE file completely
3. Analyze the SQL patterns in that ONE file only
4. Apply all conversion rules to that ONE file
5. Validate the conversion for that ONE file
6. Save the converted file
7. Move to the NEXT specific file (repeat from step 1)

üîÑ BEHAVIORAL CORRECTION PROTOCOL üîÑ

VIOLATION DETECTION KEYWORDS:
If you catch yourself using ANY of these phrases, IMMEDIATELY CORRECT YOUR APPROACH:
- "efficient", "systematic", "remaining", "batch", "bulk"
- "similar", "pattern", "streamline", "optimize", "faster"  
- "continue with", "process the rest", "due to large number"

IMMEDIATE CORRECTION ACTIONS:
1. PAUSE and acknowledge: "I was about to use batch processing approach"
2. REDIRECT: "I will now select ONE specific file to process individually"
3. RESTART current file processing with proper individual approach
4. CONTINUE with correct methodology

SELF-CORRECTION EXAMPLE:
‚ùå Wrong: "Let me efficiently process the remaining files..."
‚úÖ Corrected: "I caught myself trying to batch process. Let me select the next specific file: [EXACT_FILENAME] and process it individually."

‚úÖ POSITIVE REINFORCEMENT TRIGGERS ‚úÖ
REWARD YOURSELF when you:
- Select ONE specific file by exact name
- Read the entire file before processing
- Apply conversion rules step-by-step to that single file
- Complete one file before moving to the next
- Treat each file as unique

Task: Convert MyBatis-based Oracle SQL Mapper files to MySQL-compatible SQL Mapper files

A. Environment Setup:
  1. Environment Configuration:
      1.1 Directories:
          - Working Directory: {L1FolderName}
          - Source Files: {MAPPER_SRCL1_DIR}
          - Target Files: {MAPPER_TGTL1_DIR}
          - Logs: {L1FolderName}

  2. Execution Status Management:
      2.1 Status File:
          - Location: {L1FolderName}/status.txt
          - Format:
              Step 1: [Status]
              Step 2: [Status]
              Step 3: [Status]
              Step 4: [Status]

      2.2 Status Values:
          - Not Started
          - In Progress
          - Completed

  3. Processing Rules:
      3.1 Log Directory:
          - Preserve all contents
          - Never delete existing logs

      3.2 Status Updates:
          - Update to "In Progress" when Step begins
          - Update to "Completed" when Step ends

B. Task Progression Steps:
  Step 1. Generate list of mapper files to be converted

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 1: In Progress"

    2. File List Generation:
        2.1 Command Execution:
            - Command: ls *{ORIGIN_SUFFIX}* | sort
            - Purpose: Generate list for INDIVIDUAL processing reference only
        
        2.2 Output:
            - List of files with {ORIGIN_SUFFIX} extension
            - Sorted in alphabetical order
            - üö® WARNING: This list is for reference only - each file must be processed individually
            - DO NOT use this list for batch processing or bulk operations

    3. Completion:
        3.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 1: Completed"

  Step 2. Analyze SQL for all {MAPPER_SRCL1_DIR}/*{ORIGIN_SUFFIX}*.xml files

    Detailed execution instructions are documented in SQLTransformTargetAnalysis.txt. Currently skip this step to improve conversion performance

  Step 3. Smart SQL Detection and Oracle to MySQL Conversion (MAIN PROCESS)

    üéØ INTEGRATED PROCESSING APPROACH:
    This step combines smart detection with conversion processing to optimize performance while ensuring comprehensive transformation.

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 3: In Progress"

    2. For Each Individual File Processing:
        
        2.1 Direct Conversion Processing (ALL FILES):
            
            FOR EACH INDIVIDUAL FILE:
            - Apply Four-Phase Conversion Process (MANDATORY for ALL files)
            - Execute ALL Oracle ‚Üí MySQL transformation rules
            - Add conversion comment IMMEDIATELY ABOVE the first SQL element: <!-- Processed by Amazon Q Developer: Oracle to MySQL conversion completed on [timestamp] -->
            - Apply ALL MySQL-specific rules without exception

        2.3 Four-Phase Conversion Process (For Standard Track Files):
            
            üö® CRITICAL: Apply phases in exact order to prevent conflicts
            
            ### PHASE 1 - STRUCTURAL PROCESSING (Apply First):
            **Purpose**: Clean up Oracle-specific structural elements before syntax conversion
            
            1. **XML Structure Analysis** 
               - Parse XML tags and identify SQL content within CDATA sections
               - Preserve all MyBatis dynamic tags (<if>, <choose>, <foreach>)
               
            2. **Schema Removal** (HIGHEST PRIORITY)
               - Remove schema prefixes: `SCHEMA_NAME.TABLE_NAME` ‚Üí `TABLE_NAME`
               - Reference ORACLE_SVC_USER_LIST for schema names to remove
               - Handle schema.package.procedure patterns
               
            3. **TABLE() Function Removal**
               - Remove TABLE() wrapper: `TABLE(func())` ‚Üí `func()`
               - Preserve all function parameters exactly
               
            4. **Stored Procedure Conversion**
               - Remove curly braces: `{call PROC()}` ‚Üí `CALL PROC()`
               - Convert Oracle package.procedure to package_procedure format
               
            5. **Database Link Removal**
               - Remove @DBLINK suffixes from all database objects

            ### PHASE 2 - SYNTAX STANDARDIZATION (Apply Second):
            **Purpose**: Standardize SQL syntax before MySQL-specific conversions
            
            6. **JOIN Syntax Standardization**
               - Convert comma-separated JOINs to explicit JOINs
               - Move WHERE clause JOIN conditions to ON clauses
               - Convert Oracle (+) outer joins to LEFT/RIGHT JOINs
               
            7. **Common Syntax Cleanup**
               - Remove Oracle optimizer hints (/*+ ... */)
               - Standardize quote usage and case sensitivity

            ### PHASE 3 - MYSQL TRANSFORMATION (Apply Third):
            üö® MANDATORY COMPLETE CONVERSION - NO EXCEPTIONS:

            8. **Basic Function Conversions**
               - NVL ‚Üí CASE WHEN, SYSDATE ‚Üí NOW(), SUBSTR ‚Üí SUBSTRING, DECODE ‚Üí CASE WHEN
               - Reference: "üîß MYSQL CONVERSION RULES - Basic Functions" section

            9. **Date/Time Function Conversions**
                - ADD_MONTHS, MONTHS_BETWEEN, LAST_DAY, TRUNC, TO_DATE conversions
                - Reference: "üîß MYSQL CONVERSION RULES - Date Functions" section

            10. **String Function Conversions**
                - INSTR ‚Üí LOCATE, LPAD, TO_CHAR ‚Üí CAST AS CHAR, TO_NUMBER ‚Üí CAST AS DECIMAL
                - String concatenation with NULL handling
                - Reference: "üîß MYSQL CONVERSION RULES - String Functions" section

            11. **Sequence and Pagination Conversions**
                - SEQ.NEXTVAL ‚Üí AUTO_INCREMENT/LAST_INSERT_ID(), SEQ.CURRVAL ‚Üí LAST_INSERT_ID()
                - ROWNUM ‚Üí LIMIT/OFFSET patterns
                - Reference: "üîß MYSQL CONVERSION RULES - Sequence/Pagination" sections

            12. **DUAL Table Removal**
                - SELECT 'Hello' FROM DUAL ‚Üí SELECT 'Hello'
                - SELECT #{variable} FROM DUAL ‚Üí SELECT #{variable}
                - Reference: "üîß MYSQL CONVERSION RULES - DUAL Table Removal" section

            13. **Oracle System Function Conversions**
                - USER ‚Üí CURRENT_USER(), SYS_CONTEXT ‚Üí USER(), SYS_GUID ‚Üí UUID()
                - Reference: "üîß MYSQL CONVERSION RULES - Oracle System Functions" section

            14. **Advanced NULL Handling**
                - NVL2 ‚Üí CASE WHEN, Empty string vs NULL behavior differences
                - Mixed type IFNULL with proper casting
                - Reference: "üîß MYSQL CONVERSION RULES - Advanced NULL Handling" section

            15. **Regular Expression Conversions**
                - REGEXP_LIKE ‚Üí REGEXP, REGEXP_REPLACE with MySQL syntax
                - Reference: "üîß MYSQL CONVERSION RULES - Regular Expressions" section

            16. **Date Literal Conversions**
                - DATE '2023-01-01' ‚Üí '2023-01-01'
                - TIMESTAMP '2023-01-01 12:00:00' ‚Üí '2023-01-01 12:00:00'
                - Reference: "üîß MYSQL CONVERSION RULES - Oracle Date Literals" section

            17. **Additional Oracle to MySQL Conversions**
                - LISTAGG ‚Üí GROUP_CONCAT, CHR functions, v$session ‚Üí information_schema
                - Oracle hint removal, ORDER BY cleanup for aggregates
                - Reference: "üîß MYSQL CONVERSION RULES - Additional Critical Oracle Functions" section

            18. **Stored Procedure Enhancement**
                - Type casting for procedure parameters, OUT parameter handling
                - Reference: "üîß MYSQL CONVERSION RULES - Stored Procedure Enhancement" section

            19. **PL/SQL DECLARE Section Processing**
                - Convert DECLARE blocks to MySQL stored procedure format
                - Variable declarations, initialization handling
                - Reference: "üîß MYSQL STORED PROCEDURE PROCESSING" section

            20. **ResultMap and JDBC Type Processing**
                - Convert Oracle JDBC types to MySQL equivalents
                - Column name case sensitivity, Java type conversions
                - Reference: "üó∫Ô∏è RESULTMAP PROCESSING" section

            21. **Advanced Conversions** (Apply expert knowledge when needed)
                - CONNECT BY ‚Üí Recursive CTE, MERGE ‚Üí INSERT ON CONFLICT
                - Complex ROWNUM patterns, hierarchical queries
                - Reference: "üî¨ ADVANCED CONVERSIONS" and "üéØ EXPERT-LEVEL CONVERSION GUIDANCE" sections

            ### PHASE 4 - FINAL VALIDATION AND CORRECTION (Apply Last):
            23. **XML Structure Validation**
                - Verify all opening/closing tags match
                - Ensure XML attributes are preserved

            24. **CDATA Section Integrity Check**
                - Confirm CDATA structure is intact while SQL content is converted
                - Verify dynamic query tags are preserved

            25. **Conversion Result Validation**
                - MySQL syntax validation
                - MyBatis bind variable preservation check
                - Functional integrity verification

        2.4 Individual File Processing Rules (FORCE COMPLETE CONVERSION):
            
            üö® CONVERSION ENFORCEMENT PROTOCOL:
            - DISABLE complexity-based rule skipping  
            - FORCE complete 4-phase processing for ALL files
            - SCAN entire file content for ANY Oracle construct
            - APPLY transformation rules to EVERY Oracle pattern found
            - NO EXCEPTIONS for "minor" or "compatible" constructs

            ‚úÖ MANDATORY SCANNING PATTERNS:
            - Oracle functions: NVL, DECODE, SYSDATE, SUBSTR, ADD_MONTHS, etc.
            - Oracle syntax: ROWNUM, DUAL, (+) joins, {call}, etc.
            - Oracle types: DATE, NUMBER, VARCHAR2, etc.
            - Oracle constructs: CONNECT BY, MERGE, sequences, etc.

            üî• ZERO TOLERANCE ENFORCEMENT:
            IF (ANY Oracle pattern detected) THEN
              ‚Üí Apply COMPLETE transformation rules
              ‚Üí NO partial conversion allowed
              ‚Üí NO "good enough" shortcuts
            ENDIF

        2.5 MySQL Conversion Rules Application:
            
            üö® CRITICAL MANDATE: Apply COMPLETE Oracle ‚Üí MySQL conversion rules.
            
            **ZERO TOLERANCE FOR PARTIAL CONVERSION:**
            - NEVER apply only "some" rules or "basic" transformations
            - NEVER skip Oracle constructs thinking they're "minor"
            - ALWAYS apply ALL transformation rules systematically
            - ALWAYS convert EVERY Oracle-specific pattern found
            
            **MANDATORY COMPREHENSIVE COVERAGE:**
            Key areas that MUST be transformed (no exceptions):
            - ALL Oracle functions (NVL, DECODE, SYSDATE, SUBSTR, etc.)
            - ALL sequence handling (NEXTVAL, CURRVAL)
            - ALL pagination conversion (ROWNUM ‚Üí LIMIT/OFFSET)
            - ALL DUAL table replacements (‚Üí VALUES clause)
            - ALL stored procedure syntax ({call} ‚Üí CALL)
            - ALL JOIN syntax standardization
            - ALL string and numeric functions
            - ALL date/time functions
            - ALL Oracle-specific constructs
            
            **üéØ DATABASE EXPERT MODE:**
            For Oracle constructs NOT explicitly documented in the rule files:
            - Apply appropriate MySQL equivalents based on database expert knowledge
            - Use industry best practices for Oracle-to-MySQL conversions
            - Ensure semantic equivalence and optimal performance
            - Document any expert-level transformations applied

        2.6 File Output:
            - Target Directory: {MAPPER_TGTL1_DIR}
            - Filename transformation: {ORIGIN_SUFFIX} ‚Üí {TRANSFORM_SUFFIX}
            - Add conversion comment with timestamp
            - Preserve XML structure and MyBatis functionality

    3. Logging and Tracking:
        3.1 Classification Results:
            Output: {L1FolderName}/processing_classification.txt
            
            Format:
            FAST TRACK - Configuration Only:
            - ConfigMapper.xml: No SQL content detected
            - CacheConfig.xml: Cache configuration only
            
            STANDARD TRACK - SQL Processing Required:
            - UserMapper.xml: Contains SELECT, INSERT operations
            - OrderMapper.xml: Contains stored procedure calls

        3.2 Performance Metrics:
            - Track processing time per file
            - Record classification accuracy
            - Monitor conversion success rate

    4. Final Step:
        4.1 Update Status:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 3: Completed"

  Step 4. Perform xmllint validation on all {MAPPER_TGTL1_DIR}/*{TRANSFORM_SUFFIX}*.xml files

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 4: In Progress"

    2. Target File Verification:
        2.1 Command Execution:
            - Command: ls {MAPPER_TGTL1_DIR}/*{TRANSFORM_SUFFIX}*.xml | sort
            - Purpose: Confirm list of files for validation

    3. XML Validation Process:
        Detailed instructions are documented in SQLTransformTargetXMLValidation.txt, but currently this step should be skipped and not performed

    4. Completion:
        4.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 4: Completed"

# ORACLE TO MYSQL SQL TRANSFORMATION RULES

## üìã OVERVIEW

This section provides complete Oracle to MySQL SQL conversion guidelines with structured task progression.
All MySQL-specific rules are embedded directly in this section.
**CRITICAL**: This processes MyBatis XML mapper files - XML structure and CDATA sections must be preserved.

## üéØ PROCESSING METHODOLOGY

### Individual File Processing (MANDATORY)
- Process EXACTLY ONE file at a time
- Read each file completely before making any changes
- Apply conversion rules step by step for each individual file
- Validate each conversion before proceeding to the next file
- Treat each file as completely unique - never assume similarity
- **XML Structure Preservation**: Maintain all XML tags, attributes, and hierarchy
- **CDATA Protection**: Preserve CDATA sections while converting SQL content within

## üìÑ XML TAG PROCESSING

### Target Tags for SQL Conversion
Apply conversions to SQL content within these tags:

#### Basic SQL Tags
- `<sql>`
- `<select>`
- `<insert>`
- `<update>`
- `<delete>`

#### Subquery and Key Tags
- `<include>`
- `<selectKey>`

#### Result Mapping Tags
- `<resultMap>`
  - `<id>`
  - `<r>`
  - `<constructor>`
  - `<collection>`
  - `<association>`
  - `<discriminator>`

#### Parameter Mapping Tags
- `<parameterMap>`
- `<parameter>`

#### Cache Tags
- `<cache>`
- `<cache-ref>`

### Protected Dynamic Tags (DO NOT MODIFY)
- Flow control: `<if>`, `<choose>`, `<when>`, `<otherwise>`
- Iteration: `<foreach>`
- Variable binding: `<bind>`
- Parameters: `#{variable_name}`, `${variable_name}`

### CDATA Processing
**CRITICAL**: Preserve CDATA structure while converting SQL content

```xml
<!-- Original -->
<select id="getEmployee">
    <![CDATA[
        SELECT * FROM emp
        WHERE rownum <= 10  /* Requires conversion */
    ]]>
</select>

<!-- Convert to -->
<select id="getEmployee">
    <![CDATA[
        SELECT * FROM emp
        LIMIT 10
    ]]>
</select>
```

## üó∫Ô∏è RESULTMAP PROCESSING

### Java Type Conversions
- `javaType="java.math.BigDecimal"` ‚Üí `javaType="java.math.BigDecimal"` (keep as is)
- `javaType="oracle.sql.TIMESTAMP"` ‚Üí `javaType="java.sql.Timestamp"`
- `javaType="oracle.sql.CLOB"` ‚Üí `javaType="java.lang.String"`
- `javaType="oracle.sql.BLOB"` ‚Üí `javaType="byte[]"`

### JDBC Type Conversions (MySQL Compatible)
#### **Numeric Types**
- `jdbcType="NUMBER"` ‚Üí `jdbcType="DECIMAL"`
- `jdbcType="INTEGER"` ‚Üí `jdbcType="INTEGER"`
- `jdbcType="BIGINT"` ‚Üí `jdbcType="BIGINT"`
- `jdbcType="SMALLINT"` ‚Üí `jdbcType="SMALLINT"`
- `jdbcType="TINYINT"` ‚Üí `jdbcType="TINYINT"`
- `jdbcType="FLOAT"` ‚Üí `jdbcType="FLOAT"`
- `jdbcType="DOUBLE"` ‚Üí `jdbcType="DOUBLE"`

#### **String Types**
- `jdbcType="VARCHAR2"` ‚Üí `jdbcType="VARCHAR"`
- `jdbcType="CHAR"` ‚Üí `jdbcType="CHAR"`
- `jdbcType="NVARCHAR2"` ‚Üí `jdbcType="VARCHAR"`
- `jdbcType="NCHAR"` ‚Üí `jdbcType="CHAR"`
- `jdbcType="CLOB"` ‚Üí `jdbcType="LONGTEXT"`
- `jdbcType="NCLOB"` ‚Üí `jdbcType="LONGTEXT"`

#### **Date/Time Types**
- `jdbcType="DATE"` ‚Üí `jdbcType="DATETIME"`
- `jdbcType="TIMESTAMP"` ‚Üí `jdbcType="TIMESTAMP"`
- `jdbcType="TIMESTAMP_WITH_TIME_ZONE"` ‚Üí `jdbcType="TIMESTAMP"`
- `jdbcType="TIMESTAMP_WITH_LOCAL_TIME_ZONE"` ‚Üí `jdbcType="TIMESTAMP"`

#### **Binary Types**
- `jdbcType="BLOB"` ‚Üí `jdbcType="LONGBLOB"`
- `jdbcType="RAW"` ‚Üí `jdbcType="VARBINARY"`
- `jdbcType="LONG_RAW"` ‚Üí `jdbcType="LONGBLOB"`

#### **Special Types**
- `jdbcType="ROWID"` ‚Üí `jdbcType="VARCHAR"` (convert to string representation)
- `jdbcType="XMLTYPE"` ‚Üí `jdbcType="LONGTEXT"`

### Column Mapping Verification (MySQL Specific)
- Check column names match MySQL case sensitivity rules
- Verify column data types are compatible with MySQL
- Ensure property names in resultMap match Java entity fields
- **MySQL Case Sensitivity**: Depends on `lower_case_table_names` setting
  - `lower_case_table_names=0`: Case sensitive (Linux default)
  - `lower_case_table_names=1`: Case insensitive (Windows/macOS default)
  - `lower_case_table_names=2`: Case insensitive storage, case sensitive comparison (macOS default)

### MySQL-Specific ResultMap Considerations
#### **Column Name Handling**
```xml
<!-- Oracle style (may need adjustment) -->
<result column="EMP_ID" property="empId" jdbcType="NUMBER"/>

<!-- MySQL compatible (recommended) -->
<result column="emp_id" property="empId" jdbcType="DECIMAL"/>
```

#### **Auto-Generated Keys**
```xml
<!-- Oracle sequence style -->
<selectKey keyProperty="id" resultType="long" order="BEFORE">
    SELECT SEQ_EMP_ID.NEXTVAL FROM DUAL
</selectKey>

<!-- MySQL AUTO_INCREMENT style -->
<selectKey keyProperty="id" resultType="long" order="AFTER">
    SELECT LAST_INSERT_ID()
</selectKey>
```

### Implementation Example
```xml
<!-- Original -->
<resultMap id="empMap" type="Employee">
    <result property="salary" column="SALARY" javaType="java.math.BigDecimal" jdbcType="NUMBER"/>
    <result property="description" column="DESCRIPTION" javaType="oracle.sql.CLOB" jdbcType="CLOB"/>
</resultMap>

<!-- Convert to -->
<resultMap id="empMap" type="Employee">
    <result property="salary" column="SALARY" javaType="java.math.BigDecimal" jdbcType="NUMERIC"/>
    <result property="description" column="DESCRIPTION" javaType="java.lang.String" jdbcType="VARCHAR"/>
</resultMap>
```
## üîß MYSQL CONVERSION RULES

### Basic Functions (ORACLE-COMPATIBLE CONVERSION)
- `NVL(a, b)` ‚Üí `CASE WHEN (a IS NULL OR a = '') THEN b ELSE a END`
- `SYSDATE` ‚Üí `NOW()`
- `SUBSTR(str, pos, len)` ‚Üí `SUBSTRING(str, pos, len)`
- `DECODE(...)` ‚Üí `CASE WHEN ... END`

### Date Functions
- `ADD_MONTHS(date, n)` ‚Üí `DATE_ADD(date, INTERVAL n MONTH)`
- `MONTHS_BETWEEN(d1, d2)` ‚Üí `TIMESTAMPDIFF(MONTH, d2, d1)`
- `LAST_DAY(date)` ‚Üí `LAST_DAY(date)`
- `NEXT_DAY(date, day)` ‚Üí Complex conversion using CASE and DATE_ADD
- `TRUNC(date, 'DD')` ‚Üí `DATE(date)`
- `TRUNC(date, 'MM')` ‚Üí `DATE_FORMAT(date, '%Y-%m-01')`
- `TRUNC(date, 'YYYY')` ‚Üí `DATE_FORMAT(date, '%Y-01-01')`
- `TRUNC(date, 'HH')` ‚Üí `DATE_FORMAT(date, '%Y-%m-%d %H:00:00')`
- `EXTRACT(YEAR FROM date)` ‚Üí `YEAR(date)`
- `EXTRACT(MONTH FROM date)` ‚Üí `MONTH(date)`
- `EXTRACT(DAY FROM date)` ‚Üí `DAY(date)`
- `EXTRACT(HOUR FROM timestamp)` ‚Üí `HOUR(timestamp)`
- `EXTRACT(MINUTE FROM timestamp)` ‚Üí `MINUTE(timestamp)`
- `EXTRACT(SECOND FROM timestamp)` ‚Üí `SECOND(timestamp)`

### Advanced Date Conversions
```sql
-- Oracle NEXT_DAY conversion example
-- NEXT_DAY(date, 'MONDAY') equivalent in MySQL (0=Monday in WEEKDAY())
DATE_ADD(date, INTERVAL (7 - WEEKDAY(date) + 0) % 7 + 
    CASE WHEN WEEKDAY(date) = 0 THEN 0 ELSE 1 END DAY)

-- Oracle TO_CHAR date formatting
TO_CHAR(date, 'YYYY-MM-DD') ‚Üí DATE_FORMAT(date, '%Y-%m-%d')
TO_CHAR(date, 'DD/MM/YYYY') ‚Üí DATE_FORMAT(date, '%d/%m/%Y')
TO_CHAR(date, 'MON DD, YYYY') ‚Üí DATE_FORMAT(date, '%b %d, %Y')
TO_CHAR(date, 'HH24:MI:SS') ‚Üí TIME_FORMAT(date, '%H:%i:%s')
```

### Sequence Handling (MySQL AUTO_INCREMENT)
- `SEQ_NAME.NEXTVAL` ‚Üí Use AUTO_INCREMENT column or `LAST_INSERT_ID()`
- `SEQ_NAME.CURRVAL` ‚Üí `LAST_INSERT_ID()`

#### SelectKey Pattern Processing
```xml
<!-- Original -->
<selectKey keyProperty="id" resultType="long" order="BEFORE">
    SELECT SEQ_EMPLOYEE_ID.NEXTVAL FROM DUAL
</selectKey>

<!-- Convert to (for AUTO_INCREMENT) -->
<selectKey keyProperty="id" resultType="long" order="AFTER">
    SELECT LAST_INSERT_ID()
</selectKey>
```

### Pagination
- `ROWNUM <= n` ‚Üí `LIMIT n`
- Complex ROWNUM pagination ‚Üí `LIMIT n OFFSET m`

#### ROWNUM Based Pagination Pattern
```xml
<!-- Original -->
<select id="getList">
    SELECT * FROM (
        SELECT ROWNUM AS rnum, a.* FROM (
            ${originalQuery}
        ) a WHERE ROWNUM <= #{end}
    ) WHERE rnum >= #{start}
</select>

<!-- Convert to -->
<select id="getList">
    ${originalQuery}
    LIMIT #{pageSize} OFFSET #{start}
</select>
```

### String Functions
- `INSTR(str, substr)` ‚Üí `LOCATE(substr, str)`
- `LPAD(str, len, pad)` ‚Üí `LPAD(str, len, pad)`
- `RPAD(str, len, pad)` ‚Üí `RPAD(str, len, pad)`
- `TO_CHAR(num)` ‚Üí `CAST(num AS CHAR)`
- `TO_NUMBER(str)` ‚Üí `CAST(str AS DECIMAL)` or `CAST(str AS SIGNED)`
- `LTRIM(str)` ‚Üí `LTRIM(str)`
- `RTRIM(str)` ‚Üí `RTRIM(str)`
- `TRIM(str)` ‚Üí `TRIM(str)`
- `UPPER(str)` ‚Üí `UPPER(str)`
- `LOWER(str)` ‚Üí `LOWER(str)`
- `INITCAP(str)` ‚Üí `CONCAT(UPPER(LEFT(str,1)), LOWER(SUBSTRING(str,2)))`
- **String Concatenation (ORACLE-COMPATIBLE)**:
  - Oracle: `str1 || str2` ‚Üí MySQL: `CONCAT(IFNULL(str1, ''), IFNULL(str2, ''))`
  - **Multiple concatenation**: `str1 || str2 || str3` ‚Üí `CONCAT(IFNULL(str1, ''), IFNULL(str2, ''), IFNULL(str3, ''))`
  - **With literals**: `'Hello ' || name || '!'` ‚Üí `CONCAT('Hello ', IFNULL(name, ''), '!')`
- **LENGTH with NULL (ORACLE-COMPATIBLE)**:
  - Oracle: `LENGTH(NULL)` ‚Üí `NULL`, `LENGTH('')` ‚Üí `NULL`
  - MySQL: `CASE WHEN (column IS NULL OR column = '') THEN NULL ELSE LENGTH(column) END`
  - **Note**: Oracle treats empty strings as NULL in LENGTH function

### Numeric Functions
**Note**: Most numeric functions have identical syntax in Oracle and MySQL
- `MOD(n, m)` ‚Üí `MOD(n, m)` (no conversion needed)
- `POWER(n, m)` ‚Üí `POW(n, m)` (function name change required)
- `SQRT(n)` ‚Üí `SQRT(n)` (no conversion needed)
- `ABS(n)` ‚Üí `ABS(n)` (no conversion needed)
- `CEIL(n)` ‚Üí `CEILING(n)` (function name change required)
- `FLOOR(n)` ‚Üí `FLOOR(n)` (no conversion needed)
- `ROUND(n, d)` ‚Üí `ROUND(n, d)` (no conversion needed)
- `TRUNC(n, d)` ‚Üí `TRUNCATE(n, d)` (function name change required)
- `SIGN(n)` ‚Üí `SIGN(n)` (no conversion needed)

### Conditional Functions
- `GREATEST(val1, val2, ...)` ‚Üí `GREATEST(val1, val2, ...)`
- `LEAST(val1, val2, ...)` ‚Üí `LEAST(val1, val2, ...)`
- `NULLIF(expr1, expr2)` ‚Üí `NULLIF(expr1, expr2)` (same syntax)

### Aggregate Functions with DISTINCT
- `COUNT(DISTINCT column)` ‚Üí `COUNT(DISTINCT column)` (same syntax)
- `SUM(DISTINCT column)` ‚Üí `SUM(DISTINCT column)` (same syntax)
- `AVG(DISTINCT column)` ‚Üí `AVG(DISTINCT column)` (same syntax)

### Additional Critical Oracle Functions
- `REPLACE(str, search, replace)` ‚Üí `REPLACE(str, search, replace)` (same syntax)
- `TRANSLATE(str, from_chars, to_chars)` ‚Üí Complex REPLACE chain or custom function
- `ASCII(char)` ‚Üí `ASCII(char)` (same syntax)
- `SOUNDEX(str)` ‚Üí `SOUNDEX(str)` (same syntax)
- `REVERSE(str)` ‚Üí `REVERSE(str)` (same syntax)
- `REPEAT(str, n)` ‚Üí `REPEAT(str, n)` (same syntax)
- `SPACE(n)` ‚Üí `SPACE(n)` (same syntax)
- `LEFT(str, len)` ‚Üí `LEFT(str, len)` (same syntax)

### Additional Oracle to MySQL Conversions
- `LISTAGG(column, delimiter)` ‚Üí `GROUP_CONCAT(column SEPARATOR delimiter)`
- `CHR(ASCII('A')+n)` ‚Üí `CHAR(ASCII('A')+n)`
- `v$session` ‚Üí `SHOW PROCESSLIST` or `information_schema.PROCESSLIST`
- **TO_DATE conversion**:
  - Date only: `TO_DATE('20250424', 'YYYYMMDD')` ‚Üí `STR_TO_DATE('20250424', '%Y%m%d')`
  - Date with time: `TO_DATE('2025-04-24 13:45:00', 'YYYY-MM-DD HH24:MI:SS')` ‚Üí `STR_TO_DATE('2025-04-24 13:45:00', '%Y-%m-%d %H:%i:%s')`
- **Date format patterns**:
  - Oracle `YYYY` ‚Üí MySQL `%Y`
  - Oracle `MM` ‚Üí MySQL `%m`
  - Oracle `DD` ‚Üí MySQL `%d`
  - Oracle `HH24` ‚Üí MySQL `%H`
  - Oracle `MI` ‚Üí MySQL `%i`
  - Oracle `SS` ‚Üí MySQL `%s`
- **Explicit type casting for comparisons**:
  - `SUBSTRING(date_column,1,8) = STR_TO_DATE('20250424', '%Y%m%d')`
- **INTERVAL for date calculations**:
  - `DATE_ADD(STR_TO_DATE(date, '%Y%m%d'), INTERVAL 3 DAY)`
- **Preserve special characters**: Maintain `&lt;` and `&gt;` in original SQL
- **Remove ORDER BY for aggregate functions without GROUP BY**:
  - `SELECT COUNT(empno) FROM emp ORDER BY reg_dttm` ‚Üí `SELECT COUNT(empno) FROM emp`
- **Oracle Hint Removal**:
  - Remove all Oracle optimizer hints from SQL
  - `SELECT /*+ FIRST_ROWS(10) */ * FROM table` ‚Üí `SELECT * FROM table`
  - `SELECT /*+ INDEX(t, idx_name) */ * FROM table t` ‚Üí `SELECT * FROM table t`
  - `SELECT /*+ USE_NL(a b) */ * FROM a, b` ‚Üí `SELECT * FROM a, b`
  - **Pattern**: Remove `/*+ ... */` comments entirely

### Oracle Date Literals
- `DATE '2023-01-01'` ‚Üí `'2023-01-01'`
- `TIMESTAMP '2023-01-01 12:00:00'` ‚Üí `'2023-01-01 12:00:00'`

### Oracle System Functions
- `USER` ‚Üí `USER()`
- `SYS_CONTEXT('USERENV', 'SESSION_USER')` ‚Üí `USER()`
- `USERENV('SESSIONID')` ‚Üí `CONNECTION_ID()`
- `SYS_GUID()` ‚Üí `UUID()`

### Advanced NULL Handling (ORACLE-COMPATIBLE)
- `NVL2(expr1, expr2, expr3)` ‚Üí `CASE WHEN (expr1 IS NOT NULL AND expr1 != '') THEN expr2 ELSE expr3 END`
- Mixed type COALESCE: `COALESCE(employee_id, 'N/A')` ‚Üí `CASE WHEN (employee_id IS NULL OR employee_id = '') THEN 'N/A' ELSE CAST(employee_id AS CHAR) END`
- Date COALESCE: `COALESCE(hire_date, '1900-01-01')` ‚Üí `CASE WHEN hire_date IS NULL THEN '1900-01-01' ELSE hire_date END`
- `USERENV('SESSIONID')` ‚Üí `CONNECTION_ID()`
- `SYS_GUID()` ‚Üí `gen_random_uuid()` (requires pgcrypto extension)

### Advanced NULL Handling
- `NVL2(expr1, expr2, expr3)` ‚Üí `CASE WHEN expr1 IS NOT NULL THEN expr2 ELSE expr3 END`
- Mixed type COALESCE: `COALESCE(employee_id, 'N/A')` ‚Üí `CASE WHEN employee_id IS NULL THEN 'N/A' ELSE CAST(employee_id AS CHAR) END`
- Date COALESCE: `COALESCE(hire_date, '1900-01-01')` ‚Üí `COALESCE(hire_date, CAST('1900-01-01' AS DATE))`

### IS NULL / IS NOT NULL Processing
- `column IS NULL` ‚Üí `column IS NULL` (same syntax, but behavior may differ)
- `column IS NOT NULL` ‚Üí `column IS NOT NULL` (same syntax)
- **Empty String vs NULL**:
  - Oracle: `'' IS NULL` returns TRUE
  - MySQL: `'' IS NULL` returns FALSE
  - **Conversion**: `column IS NULL` ‚Üí `(column IS NULL OR column = '')` (if Oracle empty string behavior needed)
- **NULL Concatenation**:
  - Oracle: `'Hello' || NULL` returns `'Hello'`
  - MySQL: `CONCAT('Hello', NULL)` returns `NULL`
  - **Conversion**: Use `CONCAT(IFNULL(str1, ''), IFNULL(str2, ''))` for Oracle behavior
- **NULL in Arithmetic**:
  - Both Oracle and MySQL: `5 + NULL` returns `NULL` (same behavior)
- **NULL Comparison**:
  - Both: `NULL = NULL` returns `NULL` (not TRUE)
  - Both: Use `IS NULL` or `IS NOT NULL` for NULL checks

### Stored Procedure Enhancement
- **MySQL Procedure Conversion**: Always use `CALL` format
- `{call PROC()}` ‚Üí `CALL PROC()`
- **Type Casting for Procedure Parameters**:
  - `#{param,mode=IN,jdbcType=DECIMAL}` ‚Üí `CAST(#{param,mode=IN,jdbcType=DECIMAL} AS numeric)`
  - `#{param,mode=IN,jdbcType=INTEGER}` ‚Üí `CAST(#{param,mode=IN,jdbcType=INTEGER} AS integer)`
  - `#{param,mode=IN,jdbcType=DATE}` ‚Üí `CAST(#{param,mode=IN,jdbcType=DATE} AS timestamp)`
  - `#{param,mode=IN,jdbcType=VARCHAR}` ‚Üí No CAST (keep as is)
  - OUT parameters: Keep original format without CAST

### DUAL Table Removal
- `SELECT 'Hello' FROM DUAL` ‚Üí `SELECT 'Hello'`
- `SELECT #{variable} FROM DUAL` ‚Üí `SELECT #{variable}`

### Package Handling (Convert to underscore naming)
- Convert Oracle package.procedure format to MySQL naming convention
- `PACKAGE_NAME.PROCEDURE_NAME` ‚Üí `PACKAGE_NAME_PROCEDURE_NAME`
- `PACKAGE_NAME.FUNCTION_NAME` ‚Üí `PACKAGE_NAME_FUNCTION_NAME`
- **Note**: Schema removal is handled in PHASE 1 - STRUCTURAL PROCESSING before MySQL conversion
- **Note**: MySQL doesn't support packages - use underscore naming convention to maintain logical grouping

### ResultMap Column Names
- Convert column attributes to lowercase in ResultMap tags
- `column="EMP_ID"` ‚Üí `column="emp_id"`
- Apply only to `<r>`, `<id>`, `<association>`, `<collection>` tags
## üîß MYSQL STORED PROCEDURE PROCESSING

### Identification and Preprocessing
- Scan for DECLARE sections in SQL content
- Identify variable declarations and initializations
- Preserve CDATA sections containing PL/SQL blocks
- **Priority**: Eliminate DECLARE blocks when possible, convert only when necessary

### Critical Requirements for MySQL Conversion
- **Eliminate rather than convert**: Most DECLARE blocks can be replaced with subqueries
- **User variables**: Use @variable syntax for simple cases
- **Stored procedures**: Only for complex logic that cannot be simplified
- **Never modify anything within #{...} brackets - treat as sacred tokens**
- **NEVER modify variable case**

### Conversion Strategies

#### **Strategy 1: Elimination (PREFERRED)**
```sql
-- Oracle PL/SQL
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM employees WHERE dept_id = #{deptId};
    IF v_count > 0 THEN
        DELETE FROM departments WHERE id = #{deptId};
    END IF;
END;

-- MySQL (Eliminate DECLARE)
DELETE FROM departments 
WHERE id = #{deptId} 
  AND EXISTS (SELECT 1 FROM employees WHERE dept_id = #{deptId})
```

#### **Strategy 2: User Variables (Simple Cases)**
```sql
-- Oracle PL/SQL
DECLARE
    v_max_salary NUMBER;
BEGIN
    SELECT MAX(salary) INTO v_max_salary FROM employees;
    UPDATE employees SET bonus = salary * 0.1 WHERE salary = v_max_salary;
END;

-- MySQL User Variables
SET @max_salary = (SELECT MAX(salary) FROM employees);
UPDATE employees SET bonus = salary * 0.1 WHERE salary = @max_salary;
```

#### **Strategy 3: Stored Procedure (Complex Cases Only)**
```sql
-- Oracle PL/SQL (Complex logic)
DECLARE
    v_emp_count NUMBER;
    v_dept_name VARCHAR2(100);
BEGIN
    SELECT COUNT(*), d.name INTO v_emp_count, v_dept_name
    FROM employees e, departments d 
    WHERE e.dept_id = d.id AND d.id = #{deptId};
    
    IF v_emp_count > 10 THEN
        INSERT INTO audit_log VALUES (v_dept_name, 'LARGE_DEPT', SYSDATE);
    END IF;
END;

-- MySQL Stored Procedure (Only if elimination not possible)
DELIMITER //
CREATE PROCEDURE process_department(IN dept_id INT)
BEGIN
    DECLARE v_emp_count INT;
    DECLARE v_dept_name VARCHAR(100);
    
    SELECT COUNT(*), d.name INTO v_emp_count, v_dept_name
    FROM employees e, departments d 
    WHERE e.dept_id = d.id AND d.id = dept_id;
    
    IF v_emp_count > 10 THEN
        INSERT INTO audit_log VALUES (v_dept_name, 'LARGE_DEPT', NOW());
    END IF;
END //
DELIMITER ;
```

### MySQL Variable Declaration Rules

#### **Data Type Mapping**
- `NUMBER` ‚Üí `DECIMAL` or `INT`
- `VARCHAR2(n)` ‚Üí `VARCHAR(n)`
- `DATE` ‚Üí `DATETIME`
- `TIMESTAMP` ‚Üí `TIMESTAMP`
- `CLOB` ‚Üí `LONGTEXT`
- `BLOB` ‚Üí `LONGBLOB`

#### **%TYPE References (Convert to Explicit Types)**
```sql
-- Oracle
DECLARE
    v_emp_id    employees.employee_id%TYPE;

-- MySQL (Convert to explicit type based on table definition)
DECLARE v_emp_id INT;
```

### Error Handling Conversion

#### **Oracle Exception Handling**
```sql
-- Oracle
BEGIN
    -- SQL statements
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        NULL;
    WHEN OTHERS THEN
        RAISE;
END;
```

#### **MySQL Error Handling**
```sql
-- MySQL
BEGIN
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET @dummy = 1;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    -- SQL statements
END;
```

#### Data Type Mapping
- `VARCHAR2(n)` ‚Üí `VARCHAR`
- `CHAR(n)` ‚Üí `VARCHAR`
- `NUMBER` ‚Üí `NUMERIC`
- `NUMBER(p)` ‚Üí `INTEGER` (p <= 10)
- `NUMBER(p,s)` ‚Üí `NUMERIC(p,s)`
- `DATE` ‚Üí `TIMESTAMP`
- `CLOB` ‚Üí `TEXT`
- `BLOB` ‚Üí `BYTEA`
- `BOOLEAN` ‚Üí `BOOLEAN`
- `RAW` ‚Üí `BYTEA`
- `LONG RAW` ‚Üí `BYTEA`
- `TIMESTAMP` ‚Üí `TIMESTAMP`
- `TIMESTAMP WITH TIME ZONE` ‚Üí `TIMESTAMP WITH TIME ZONE`

#### Special Cases
- Remove VARCHAR length specifications
- Detailed NUMBER handling:
  - Plain `NUMBER` ‚Üí `NUMERIC`
  - `NUMBER(p)` ‚Üí `INTEGER` (p ‚â§ 10)
  - `NUMBER(p,s)` ‚Üí `NUMERIC(p,s)`

### Variable Management

#### Initialization Rules
- **NO initializations in DECLARE section**
- **ALL initializations MUST move to BEGIN section**

#### Bind Variable Handling
- Maintain MyBatis bind variable syntax: `#{variable_name}`
- Move all bind variable assignments to BEGIN section
- For %TYPE variables, do not add type casts to bind variables
- For explicitly typed variables, add appropriate type casts

### Error Handling
- `EXCEPTION WHEN` ‚Üí `EXCEPTION WHEN`
- `NO_DATA_FOUND` ‚Üí `NO_DATA_FOUND`
- `TOO_MANY_ROWS` ‚Üí `TOO_MANY_ROWS`
- `OTHERS` ‚Üí `OTHERS`

### Implementation Example

```sql
-- Original Oracle Code
DECLARE
    V_EMP_ID    EMPLOYEES.EMPLOYEE_ID%TYPE := #{EMPID};
    V_NAME      VARCHAR2(100) := #{EMPNAME};
    V_SALARY    NUMBER(10,2) := #{EMPSALARY};
    V_DEPTNAME  DEPT.DEPTNAME%TYPE := NVL(#{DEPTNAME}, '');
BEGIN
    -- logic
END;

-- Correct MySQL Conversion
DO $$
DECLARE
    V_EMP_ID    employees.employee_id%TYPE;
    V_NAME      VARCHAR;
    V_SALARY    NUMERIC(10,2);
    V_DEPTNAME  dept.deptname%TYPE;
BEGIN
    V_EMP_ID := #{EMPID};
    V_NAME := #{EMPNAME};
    V_SALARY := #{EMPSALARY};
    V_DEPTNAME := COALESCE(#{DEPTNAME}, '');
    -- logic
END;
END //
DELIMITER ;
```
## üî¨ ADVANCED CONVERSIONS (MySQL Optimized)

### Hierarchical Queries (CONNECT BY)
Convert to recursive CTEs (MySQL 8.0+) or alternative approaches:

#### **MySQL 8.0+ Recursive CTE**
```sql
-- Oracle CONNECT BY (Simple hierarchy)
SELECT employee_id, manager_id, level
FROM employees 
START WITH manager_id IS NULL 
CONNECT BY PRIOR employee_id = manager_id;

-- MySQL 8.0+ Recursive CTE
WITH RECURSIVE emp_hierarchy AS (
    -- Anchor: root nodes
    SELECT employee_id, manager_id, 1 as level
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive: child nodes
    SELECT e.employee_id, e.manager_id, eh.level + 1
    FROM employees e
    JOIN emp_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT employee_id, manager_id, level FROM emp_hierarchy;
```

#### **Pre-MySQL 8.0 Alternative (Self-Join)**
```sql
-- For older MySQL versions, use multiple self-joins or application logic
SELECT e1.employee_id, e1.manager_id, 1 as level FROM employees e1 WHERE e1.manager_id IS NULL
UNION ALL
SELECT e2.employee_id, e2.manager_id, 2 as level FROM employees e2 
JOIN employees e1 ON e2.manager_id = e1.employee_id WHERE e1.manager_id IS NULL
-- Continue for required levels...
```

### ROWNUM Conversion Patterns

#### **Simple ROWNUM**
- `WHERE ROWNUM <= n` ‚Üí `LIMIT n`
- `WHERE ROWNUM = 1` ‚Üí `LIMIT 1`

#### **Complex ROWNUM (Pagination)**
```sql
-- Oracle nested ROWNUM
SELECT * FROM (
    SELECT ROWNUM as rn, a.* FROM (
        SELECT * FROM table ORDER BY column
    ) a WHERE ROWNUM <= 20
) WHERE rn > 10;

-- MySQL LIMIT OFFSET
SELECT * FROM table ORDER BY column LIMIT 10 OFFSET 10;
```

#### **ROWNUM with Window Functions (MySQL 8.0+)**
```sql
-- Oracle ROWNUM with complex conditions
SELECT * FROM (
    SELECT ROWNUM as rn, emp.* 
    FROM (SELECT * FROM employees ORDER BY salary DESC) emp
    WHERE ROWNUM <= 100
) WHERE rn BETWEEN 21 AND 40;

-- MySQL 8.0+ with ROW_NUMBER()
SELECT * FROM (
    SELECT ROW_NUMBER() OVER (ORDER BY salary DESC) as rn, emp.*
    FROM employees emp
) ranked WHERE rn BETWEEN 21 AND 40;
```

### MERGE Statement Conversion

#### **Oracle MERGE**
```sql
MERGE INTO target_table t
USING source_table s ON (t.id = s.id)
WHEN MATCHED THEN
    UPDATE SET t.name = s.name, t.updated_date = SYSDATE
WHEN NOT MATCHED THEN
    INSERT (id, name, created_date) VALUES (s.id, s.name, SYSDATE);
```

#### **MySQL Equivalent (INSERT ... ON DUPLICATE KEY UPDATE)**
```sql
INSERT INTO target_table (id, name, created_date, updated_date)
SELECT id, name, NOW(), NOW() FROM source_table
ON DUPLICATE KEY UPDATE 
    name = VALUES(name),
    updated_date = NOW();
```

### Window Functions (MySQL 8.0+)

#### **Oracle Analytical Functions**
```sql
-- Oracle
SELECT employee_id, salary,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank_in_dept,
       LAG(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as prev_salary
FROM employees;

-- MySQL 8.0+ (Same syntax)
SELECT employee_id, salary,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank_in_dept,
       LAG(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as prev_salary
FROM employees;
```

### JSON Functions (MySQL 5.7+)

#### **Oracle JSON vs MySQL JSON**
```sql
-- Oracle JSON_VALUE
SELECT JSON_VALUE(json_column, '$.name') FROM table_name;

-- MySQL JSON_EXTRACT
SELECT JSON_EXTRACT(json_column, '$.name') FROM table_name;
-- or
SELECT json_column->>'$.name' FROM table_name;
```

### Performance Optimization Patterns (MySQL 8.0+)

#### **Window Functions (Full Support)**
```sql
-- Oracle Analytical Functions ‚Üí MySQL 8.0+ (Same syntax)
SELECT employee_id, salary,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank_in_dept,
       RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank,
       DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as dense_rank,
       LAG(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as prev_salary,
       LEAD(salary, 1) OVER (PARTITION BY department_id ORDER BY salary DESC) as next_salary,
       FIRST_VALUE(salary) OVER (PARTITION BY department_id ORDER BY salary DESC) as max_salary,
       LAST_VALUE(salary) OVER (PARTITION BY department_id ORDER BY salary DESC 
                                RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as min_salary
FROM employees;
```

#### **CTE (Common Table Expressions)**
```sql
-- Oracle WITH clause ‚Üí MySQL 8.0+ WITH clause (Same syntax)
WITH dept_summary AS (
    SELECT department_id, AVG(salary) as avg_salary, COUNT(*) as emp_count
    FROM employees
    GROUP BY department_id
),
high_salary_depts AS (
    SELECT department_id FROM dept_summary WHERE avg_salary > 50000
)
SELECT e.employee_id, e.name, e.salary
FROM employees e
JOIN high_salary_depts hsd ON e.department_id = hsd.department_id;
```

#### **JSON Functions (MySQL 8.0+)**
```sql
-- Oracle JSON handling ‚Üí MySQL 8.0+ JSON functions
-- JSON_VALUE ‚Üí JSON_UNQUOTE(JSON_EXTRACT())
SELECT JSON_UNQUOTE(JSON_EXTRACT(json_column, '$.name')) as name,
       json_column->>'$.email' as email,
       JSON_OBJECT('id', employee_id, 'name', name, 'salary', salary) as emp_json
FROM employees;
```

#### **Regular Expressions (MySQL 8.0+)**
```sql
-- Oracle REGEXP functions ‚Üí MySQL 8.0+ REGEXP functions
SELECT employee_id,
       CASE WHEN email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' 
            THEN 'Valid' ELSE 'Invalid' END as email_status,
       REGEXP_REPLACE(phone, '[^0-9]', '') as clean_phone,
       REGEXP_SUBSTR(address, '[0-9]+') as street_number
FROM employees;
```

### Advanced Query Optimization

#### **Index Hints (MySQL 8.0+)**
```sql
-- Oracle hints (Remove) ‚Üí MySQL index hints
SELECT * FROM employees 
USE INDEX (idx_department_salary)
WHERE department_id = #{deptId} 
ORDER BY salary DESC;
```

### MyBatis + MySQL 8.0+ Optimization Patterns

#### **Dynamic SQL with MySQL Features**
```xml
<!-- Leverage MySQL 8.0+ window functions in MyBatis -->
<select id="getEmployeeRanking" resultType="EmployeeRank">
    SELECT employee_id, name, salary,
           ROW_NUMBER() OVER (
               <if test="partitionBy != null">
                   PARTITION BY ${partitionBy}
               </if>
               ORDER BY 
               <choose>
                   <when test="orderBy == 'salary'">salary DESC</when>
                   <when test="orderBy == 'hire_date'">hire_date DESC</when>
                   <otherwise>employee_id</otherwise>
               </choose>
           ) as ranking
    FROM employees
    <where>
        <if test="departmentId != null">
            AND department_id = #{departmentId}
        </if>
        <if test="minSalary != null">
            AND salary >= #{minSalary}
        </if>
    </where>
</select>
```

#### **Batch Operations with MySQL**
```xml
<!-- MySQL batch insert with ON DUPLICATE KEY UPDATE -->
<insert id="batchUpsertEmployees" parameterType="list">
    INSERT INTO employees (employee_id, name, email, salary, department_id)
    VALUES
    <foreach collection="list" item="emp" separator=",">
        (#{emp.employeeId}, #{emp.name}, #{emp.email}, #{emp.salary}, #{emp.departmentId})
    </foreach>
    ON DUPLICATE KEY UPDATE
        name = VALUES(name),
        email = VALUES(email),
        salary = VALUES(salary),
        department_id = VALUES(department_id),
        updated_date = NOW()
</insert>
```

#### **JSON Column Handling**
```xml
<!-- MySQL JSON column operations -->
<select id="searchEmployeesBySkills" resultType="Employee">
    SELECT employee_id, name, 
           JSON_UNQUOTE(JSON_EXTRACT(skills_json, '$.programming')) as programming_skills
    FROM employees
    WHERE JSON_CONTAINS(skills_json, JSON_OBJECT('level', #{skillLevel}))
       OR JSON_EXTRACT(skills_json, '$.years_experience') >= #{minExperience}
</select>
```

#### **Recursive CTE in MyBatis**
```xml
<!-- Hierarchical data with MySQL 8.0+ recursive CTE -->
<select id="getEmployeeHierarchy" resultType="EmployeeHierarchy">
    WITH RECURSIVE emp_hierarchy AS (
        -- Root level employees
        SELECT employee_id, name, manager_id, 1 as level,
               CAST(name AS CHAR(1000)) as path
        FROM employees 
        WHERE manager_id IS NULL
        
        UNION ALL
        
        -- Child employees
        SELECT e.employee_id, e.name, e.manager_id, eh.level + 1,
               CONCAT(eh.path, ' -> ', e.name) as path
        FROM employees e
        JOIN emp_hierarchy eh ON e.manager_id = eh.employee_id
        WHERE eh.level < #{maxLevel}
    )
    SELECT employee_id, name, manager_id, level, path
    FROM emp_hierarchy
    ORDER BY level, name
</select>
```

### MySQL 8.0+ Performance Best Practices

#### **Optimized Pagination**
```xml
<!-- Use LIMIT OFFSET with covering index -->
<select id="getEmployeesPaginated" resultType="Employee">
    SELECT e.employee_id, e.name, e.salary, e.department_id
    FROM employees e
    <where>
        <if test="departmentId != null">
            AND e.department_id = #{departmentId}
        </if>
        <if test="lastEmployeeId != null">
            AND e.employee_id > #{lastEmployeeId}
        </if>
    </where>
    ORDER BY e.employee_id
    LIMIT #{pageSize}
</select>
```

#### **Efficient Counting**
```xml
<!-- Use window functions for count with data -->
<select id="getEmployeesWithCount" resultType="EmployeeWithCount">
    SELECT employee_id, name, salary,
           COUNT(*) OVER() as total_count
    FROM employees
    <where>
        <if test="searchTerm != null">
            AND (name LIKE CONCAT('%', #{searchTerm}, '%') 
                 OR email LIKE CONCAT('%', #{searchTerm}, '%'))
        </if>
    </where>
    ORDER BY name
    LIMIT #{pageSize} OFFSET #{offset}
</select>
```

#### **Index Hints Conversion**
```sql
-- Oracle Hints (Remove)
SELECT /*+ INDEX(emp, emp_idx_name) */ * FROM employees emp;

-- MySQL Index Hints
SELECT * FROM employees USE INDEX (emp_idx_name);
```

#### **Optimizer Hints**
```sql
-- Oracle (Remove all optimizer hints)
SELECT /*+ FIRST_ROWS(10) */ * FROM table;

-- MySQL (Use appropriate syntax or remove)
SELECT * FROM table;
```

-- MySQL LIMIT/OFFSET
SELECT * FROM table 
ORDER BY column 
LIMIT 10 OFFSET 10;
```

#### ROWNUM in Subqueries
- Convert to `ROW_NUMBER() OVER()` when ROWNUM is used in analytical context
- Use `LIMIT` when ROWNUM is used for simple row limiting

### MERGE Statements
Convert to INSERT ... ON CONFLICT:
```sql
-- Oracle MERGE
MERGE INTO target USING source ON (condition)
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT ...

-- MySQL
INSERT INTO target SELECT ... FROM source
ON CONFLICT (key) DO UPDATE SET ...
```

### Regular Expressions
- `REGEXP_LIKE(source, pattern)` ‚Üí `source REGEXP pattern`
- `REGEXP_REPLACE(source, pattern, replacement)` ‚Üí `REGEXP_REPLACE(source, pattern, replacement)`
- `REGEXP_SUBSTR(source, pattern)` ‚Üí `REGEXP_SUBSTR(source, pattern)` (MySQL 8.0+)
- `REGEXP_INSTR(source, pattern)` ‚Üí Custom function using REGEXP and LOCATE

## üéØ EXPERT-LEVEL CONVERSION GUIDANCE

### Rule Application Priority (STRICT HIERARCHY)
**Priority 1 (HIGHEST)**: Explicit rules documented in this file
**Priority 2 (MEDIUM)**: Database expert knowledge for undocumented Oracle constructs  
**Priority 3 (LOWEST)**: Conservative fallback (preserve original with comments)

### For Oracle Constructs Not Explicitly Listed
**ONLY apply expert knowledge when Priority 1 rules don't exist**

When encountering Oracle SQL constructs, functions, or syntax patterns that are not explicitly documented in the above rules:

#### **Step 1: Check Explicit Rules First**
- Scan all documented conversion rules in this file
- If explicit rule exists ‚Üí Apply it (Priority 1)
- If no explicit rule exists ‚Üí Proceed to Step 2

#### **Step 2: Apply Database Expert Knowledge** (Priority 2)
Apply **database expert knowledge** to provide appropriate MySQL equivalents:

#### **Conversion Principles:**
1. **Semantic Equivalence**: Ensure the MySQL conversion maintains the same logical behavior as the original Oracle construct
2. **Performance Consideration**: Choose MySQL alternatives that provide similar or better performance characteristics
3. **Standards Compliance**: Prefer ANSI SQL standard approaches when available in MySQL
4. **MySQL Best Practices**: Utilize MySQL-specific features when they provide superior functionality

#### **Common Expert Conversion Patterns:**

**Oracle Aggregate Functions:**
- Apply MySQL aggregate function equivalents with proper syntax
- Consider `GROUP_CONCAT()` for string concatenation aggregates
- Use MySQL 8.0+ window functions for advanced aggregation

**Oracle Analytical Functions:**
- Most Oracle window functions have direct MySQL 8.0+ equivalents
- Maintain `OVER()` clause syntax and partitioning logic
- Convert Oracle-specific analytical functions to MySQL alternatives

**Oracle System Functions:**
- Map Oracle system functions to appropriate MySQL system information functions
- Use `USER()`, `DATABASE()`, `VERSION()` etc. as needed
- Convert Oracle metadata queries to MySQL information_schema queries

**Oracle Data Type Functions:**
- Convert Oracle type conversion functions to MySQL casting syntax
- Use `CAST(value AS type)` as appropriate
- Handle Oracle-specific data types with MySQL equivalents

**Oracle PL/SQL Constructs:**
- Convert Oracle PL/SQL blocks to MySQL stored procedure syntax
- Adapt Oracle exception handling to MySQL exception syntax
- Transform Oracle cursor operations to MySQL cursor equivalents

#### **Documentation Requirement:**
When applying expert-level conversions, add comments documenting the transformation:
```xml
<!-- YYYY-MM-DD Amazon Q Developer : Expert conversion - Oracle [construct] to MySQL [equivalent] -->
```

#### **Fallback Strategy:**
If no suitable MySQL equivalent exists:
1. **Document the limitation** with detailed comments
2. **Suggest alternative approaches** using MySQL features
3. **Maintain functional equivalence** even if syntax differs significantly
## ‚öôÔ∏è PROCESSING INSTRUCTIONS

### Step-by-Step Process
1. **Parse Input XML**: Extract ALL SQL content while preserving XML structure
2. **Apply Conversion Rules**: Execute all MySQL transformation rules
3. **Process PL/SQL DECLARE**: Handle DECLARE sections with MySQL conversion strategies
4. **Validate Results**: Ensure XML structure and MyBatis functionality preserved

### Comment Requirements

#### Comment Location
- Inside `<mapper>` tag
- Above SQL definition tags

#### Comment Format
```xml
<!-- YYYY-MM-DD Amazon Q Developer : description -->

Example:
<mapper namespace="AuthListDAO">
    <!-- 2025-04-27 Amazon Q Developer : Converted date formatting -->
    <sql id="selectAuthListQuery">
```

### Logging Requirements
- "Applied MySQL conversion: [function_name] ‚Üí [mysql_equivalent]"
- "Processed PL/SQL block: [conversion_strategy]"
- "Converted sequence: [seq_name] ‚Üí AUTO_INCREMENT"

### Final Error Checks

#### Structure Checks
- **XML tag structure damage**: Verify all opening/closing tags match
- **CDATA section integrity**: Ensure `<![CDATA[` and `]]>` pairs are intact
- **Dynamic query tags**: Verify `<if>`, `<choose>`, `<foreach>` tags are preserved
- **Attribute preservation**: Maintain all XML attributes (id, parameterType, resultType, etc.)

#### Functional Checks
- **Dynamic query tags operation**: Ensure flow control tags work correctly
- **Variable binding syntax accuracy**: Verify `#{variable}` and `${variable}` patterns are intact
- **ResultMap integrity**: Check that resultMap references and column mappings are valid
- **Parameter mapping**: Ensure parameterMap and parameter tags function correctly

#### SQL Syntax Validation
- **MySQL compatibility**: Verify converted SQL is valid MySQL syntax
- **Bind variable preservation**: Ensure MyBatis bind variables are not corrupted
- **CDATA SQL conversion**: Confirm SQL within CDATA sections is properly converted

## üöÄ PERFORMANCE CONSIDERATIONS

- Use MySQL 8.0+ features for optimal performance
- Leverage window functions instead of complex subqueries
- Apply efficient pagination with LIMIT OFFSET
- Use AUTO_INCREMENT instead of sequences for better performance

## üêõ COMMON ERROR PATTERNS TO FIX

- `Truncated incorrect INTEGER value` ‚Üí Add `CAST(parameter AS SIGNED)` 
- `Incorrect datetime value` ‚Üí Add `CAST(parameter AS DATETIME)`
- `invalid input syntax for type numeric` ‚Üí Add null/empty checks before casting
- **NULL-related issues**:
  - Unexpected NULL results in string concatenation ‚Üí Use `CONCAT()` or `COALESCE()`
  - Empty string vs NULL confusion ‚Üí Check Oracle vs MySQL empty string behavior
  - `LENGTH('')` returning different values ‚Üí Be aware of Oracle vs MySQL differences

# PROCESSING ENFORCEMENT

VIOLATION DETECTION: If you think about "batch", "multiple files", "efficient processing", "systematic", "remaining", "bulk", "similar", "pattern", "streamline", "optimize" ‚Üí STOP and process ONE file only.

CORRECTION: If you catch yourself trying to process multiple files, acknowledge it and focus on the current single file only.

# PROCESSING NOTE:
This file provides complete Oracle to MySQL SQL conversion guidelines with structured task progression.
All rules are specifically designed for MySQL as the target database.
