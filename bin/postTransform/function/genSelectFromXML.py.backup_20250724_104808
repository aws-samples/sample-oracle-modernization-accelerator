#!/usr/bin/env python3
"""
XML íŒŒì¼ì—ì„œ í•¨ìˆ˜ ì¶”ì¶œ ë° ê²€ì¦ í”„ë¡œê·¸ë¨ v1.6
- 1630 ì˜¤ë¥˜ í•´ê²° (í•¨ìˆ˜ ê³µë°± ë¬¸ì œ)
- ìœˆë„ìš° í•¨ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ê°œì„ 

Version: 1.6
Author: Amazon Q Developer  
Date: 2025-07-19

*** ì¤‘ìš”: ì´ í”„ë¡œê·¸ë¨ì˜ ëª©ì  ***
ì´ í”„ë¡œê·¸ë¨ì€ Transform XMLì—ì„œ ì¶”ì¶œí•œ í•¨ìˆ˜ë“¤ì˜ MySQL ë¬¸ë²• ê²€ì‚¬ê°€ ëª©ì ì…ë‹ˆë‹¤.
ì‹¤ì œ í…Œì´ë¸”ëª…/ì»¬ëŸ¼ëª…ì„ '1'ë¡œ ì¹˜í™˜í•˜ì—¬ í•¨ìˆ˜ ë¬¸ë²•ë§Œ ê²€ì¦í•˜ë¯€ë¡œ,
í…Œì´ë¸”/ì»¬ëŸ¼ ì¡´ì¬ ì˜¤ë¥˜ëŠ” ì •ìƒì ì¸ ë™ì‘ì…ë‹ˆë‹¤.

ì£¼ìš” ê²€ì¦ ëŒ€ìƒ:
- í•¨ìˆ˜ ë¬¸ë²• ì˜¤ë¥˜ (1064 ì˜¤ë¥˜)
- GROUPING í•¨ìˆ˜ ì‚¬ìš©ë²• (1210 ì˜¤ë¥˜) 
- ì§‘ê³„ í•¨ìˆ˜ ì‚¬ìš©ë²• (1111 ì˜¤ë¥˜)
- í•¨ìˆ˜ íŒŒë¼ë¯¸í„° ê°œìˆ˜ (1582 ì˜¤ë¥˜)

Changelog:
- v1.6: 1630 ì˜¤ë¥˜ í•´ê²°, ìœˆë„ìš° í•¨ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ê°œì„ 
- v1.5: PARTITION BY ë³´í˜¸, MyBatis ${} ë³€ìˆ˜ ì²˜ë¦¬ ì¶”ê°€
- v1.4: CAST í•¨ìˆ˜ì™€ ìœˆë„ìš° í•¨ìˆ˜ íŠ¹ë³„ ì²˜ë¦¬ ì¶”ê°€
- v1.3: MyBatis íŒŒë¼ë¯¸í„° ì²˜ë¦¬ ì¶”ê°€
- v1.2: SQL íŒŒì„œ ê¸°ë°˜ìœ¼ë¡œ ì „ë©´ ê°œí¸
"""

import re
import sys
import os
import json
import logging
import mysql.connector
from pathlib import Path
from datetime import datetime

# ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì˜ ë””ë ‰í† ë¦¬ë¥¼ Python ê²½ë¡œì— ì¶”ê°€
script_dir = os.path.dirname(os.path.abspath(__file__))
if script_dir not in sys.path:
    sys.path.insert(0, script_dir)

# SQL íŒŒì„œ import
from sql_function_parser import SQLFunctionParser

class FunctionValidator:
    def __init__(self, debug=False):
        self.debug = True  # ì„ì‹œë¡œ ë””ë²„ê·¸ ëª¨ë“œ í™œì„±í™”
        self.target_dbms = os.getenv('TARGET_DBMS_TYPE', 'mysql').lower()
        
        # í™˜ê²½ë³€ìˆ˜ì—ì„œ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
        self.app_logs_folder = os.getenv('APP_LOGS_FOLDER', '/tmp')
        self.app_transform_folder = os.getenv('APP_TRANSFORM_FOLDER', '/tmp')
        
        # ë¡œê·¸ ë””ë ‰í† ë¦¬ ìƒì„±
        self.post_transform_log_dir = os.path.join(self.app_logs_folder, 'postTransform')
        os.makedirs(self.post_transform_log_dir, exist_ok=True)
        os.makedirs(self.app_transform_folder, exist_ok=True)
        
        # SQL íŒŒì„œ ì´ˆê¸°í™”
        self.parser = SQLFunctionParser()
        
        # MyBatis íŒŒë¼ë¯¸í„° ì €ì¥ìš© ë³€ìˆ˜ ì´ˆê¸°í™”
        self.mybatis_params = []
        self.mybatis_vars = []
        
        # ëª¨ë“  í•¨ìˆ˜ëª… í†µí•© (MySQL, Oracle, PostgreSQL)
        self.all_functions = {
            # ë¬¸ìì—´ í•¨ìˆ˜ë“¤
            'CONCAT', 'SUBSTRING', 'SUBSTR', 'UPPER', 'LOWER', 'TRIM', 'LTRIM', 'RTRIM',
            'REPLACE', 'LENGTH', 'CHAR_LENGTH', 'LEFT', 'RIGHT', 'REVERSE',
            'LOCATE', 'INSTR', 'POSITION', 'LPAD', 'RPAD', 'REPEAT', 'SPACE',
            'INITCAP', 'TRANSLATE', 'ASCII', 'CHR', 'SOUNDEX', 'REGEXP_REPLACE',
            'REGEXP_SUBSTR', 'REGEXP_INSTR', 'REGEXP_COUNT',
            'SPLIT_PART', 'STRING_AGG', 'ARRAY_TO_STRING', 'STRING_TO_ARRAY',
            'BTRIM', 'OVERLAY', 'STRPOS', 'FORMAT', 'SUBSTRING_INDEX',
            
            # ìˆ«ì í•¨ìˆ˜ë“¤
            'SUM', 'COUNT', 'AVG', 'MAX', 'MIN', 'ROUND', 'CEIL', 'CEILING', 'FLOOR',
            'GROUP_CONCAT',
            'ABS', 'MOD', 'POWER', 'SQRT', 'SIGN', 'GREATEST', 'LEAST',
            'TRUNC', 'BITAND', 'EXP', 'LN', 'LOG', 'SIN', 'COS', 'TAN',
            'RANDOM', 'WIDTH_BUCKET', 'DEGREES', 'RADIANS',
            'ROW_NUMBER', 'RANK', 'DENSE_RANK', 'NTILE', 'PERCENT_RANK',
            'CUME_DIST', 'LEAD', 'LAG', 'FIRST_VALUE', 'LAST_VALUE',
            'RATIO_TO_REPORT', 'GROUPING',
            
            # ë‚ ì§œ/ì‹œê°„ í•¨ìˆ˜ë“¤
            'DATE_FORMAT', 'STR_TO_DATE', 'DATE_ADD', 'DATE_SUB', 'DATEDIFF',
            'YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'DAYOFWEEK',
            'UNIX_TIMESTAMP', 'FROM_UNIXTIME', 'TIME_FORMAT', 'NOW', 'CURDATE',
            'CURTIME', 'CURRENT_TIMESTAMP', 'CURRENT_DATE', 'CURRENT_TIME',
            'SYSDATE', 'SYSTIMESTAMP', 'TO_DATE', 'TO_CHAR', 'ADD_MONTHS',
            'MONTHS_BETWEEN', 'NEXT_DAY', 'LAST_DAY', 'EXTRACT',
            'DATE_TRUNC', 'AGE', 'JUSTIFY_DAYS', 'JUSTIFY_HOURS', 'JUSTIFY_INTERVAL',
            'CLOCK_TIMESTAMP', 'STATEMENT_TIMESTAMP', 'TRANSACTION_TIMESTAMP',
            
            # NULL ì²˜ë¦¬ í•¨ìˆ˜ë“¤
            'IFNULL', 'ISNULL', 'COALESCE', 'NULLIF', 'NVL', 'NVL2', 'LNNVL',
            
            # ë³€í™˜ í•¨ìˆ˜ë“¤
            'CAST', 'CONVERT', 'BINARY', 'CHAR', 'SIGNED', 'UNSIGNED',
            'TO_NUMBER', 'TO_TIMESTAMP'
        }
        
        # MySQL ì˜ˆì•½ì–´ ë³´í˜¸ ë¦¬ìŠ¤íŠ¸ (PARTITION, GROUPING, ë°ì´í„° íƒ€ì… ì¶”ê°€)
        self.mysql_reserved_words = {
            'INTERVAL', 'SELECT', 'FROM', 'WHERE', 'GROUP', 'ORDER', 'BY', 'HAVING',
            'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'DROP', 'ALTER', 'TABLE',
            'INDEX', 'VIEW', 'DATABASE', 'SCHEMA', 'UNION', 'JOIN', 'INNER', 'LEFT',
            'RIGHT', 'OUTER', 'ON', 'AS', 'AND', 'OR', 'NOT', 'IN', 'EXISTS',
            'BETWEEN', 'LIKE', 'REGEXP', 'IS', 'NULL', 'TRUE', 'FALSE', 'DISTINCT',
            'ALL', 'ANY', 'SOME', 'CASE', 'WHEN', 'THEN', 'ELSE', 'END',
            'IF', 'WHILE', 'FOR', 'LOOP', 'REPEAT', 'UNTIL', 'DECLARE',
            'SET', 'CALL', 'PROCEDURE', 'FUNCTION', 'TRIGGER', 'EVENT',
            'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MONTH', 'YEAR', 'WEEK',
            'PARTITION', 'GROUPING', 'OVER', 'SEPARATOR', 'TRAILING', 'LEADING', 'BOTH',
            'LIMIT', 'OFFSET',  # LIMITê³¼ OFFSET ì¶”ê°€
            # MySQL ë°ì´í„° íƒ€ì…ë“¤
            'CHAR', 'VARCHAR', 'TEXT', 'TINYTEXT', 'MEDIUMTEXT', 'LONGTEXT',
            'BINARY', 'VARBINARY', 'BLOB', 'TINYBLOB', 'MEDIUMBLOB', 'LONGBLOB',
            'INT', 'INTEGER', 'TINYINT', 'SMALLINT', 'MEDIUMINT', 'BIGINT',
            'DECIMAL', 'NUMERIC', 'FLOAT', 'DOUBLE', 'REAL', 'BIT',
            'DATE', 'TIME', 'DATETIME', 'TIMESTAMP', 'YEAR',
            'SIGNED', 'UNSIGNED'
        }
    
    def extract_xml_content(self, xml_file_path):
        """XML íŒŒì¼ì—ì„œ ì „ì²´ ë‚´ìš© ì¶”ì¶œ (íƒœê·¸ ì œê±° ì—†ì´)"""
        try:
            with open(xml_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            return content.strip()
            
        except Exception as e:
            return f"íŒŒì¼ ì½ê¸° ì˜¤ë¥˜: {e}"
    
    def clean_xml_content(self, xml_content):
        """XML ë‚´ìš©ì—ì„œ ë™ì  íƒœê·¸ë“¤ ì œê±° (í•¨ìˆ˜ ì¶”ì¶œ í›„ì— ì‚¬ìš©)"""
        # XML ì£¼ì„ ì œê±° (í•¨ìˆ˜ ì¶”ì¶œ ì „ì— ë¨¼ì € ì œê±°)
        content = re.sub(r'<!--.*?-->', '', xml_content, flags=re.DOTALL)
        
        # CDATA íƒœê·¸ ì œê±°
        content = re.sub(r'<!\[CDATA\[(.*?)\]\]>', r'\1', content, flags=re.DOTALL)
        
        # ë™ì  íƒœê·¸ë“¤ ì œê±°
        dynamic_tags = [
            r'<if[^>]*>.*?</if>', r'<choose[^>]*>.*?</choose>',
            r'<when[^>]*>.*?</when>', r'<otherwise[^>]*>.*?</otherwise>',
            r'<where[^>]*>.*?</where>', r'<set[^>]*>.*?</set>',
            r'<trim[^>]*>.*?</trim>', r'<foreach[^>]*>.*?</foreach>',
            r'<include[^>]*/>',
        ]
        
        for tag_pattern in dynamic_tags:
            content = re.sub(tag_pattern, '', content, flags=re.DOTALL | re.IGNORECASE)
        
        return content.strip()
    
    def extract_functions_from_xml(self, xml_content):
        """SQL íŒŒì„œë¥¼ ì‚¬ìš©í•´ì„œ XML ë‚´ìš©ì—ì„œ í•¨ìˆ˜ë“¤ì„ ì¶”ì¶œ"""
        
        # ë¨¼ì € XML íƒœê·¸ë¥¼ ì œê±°í•œ í›„ í•¨ìˆ˜ ì¶”ì¶œ
        cleaned_content = self.clean_xml_content_for_parsing(xml_content)
        
        # íŒŒì„œì— ì •ë¦¬ëœ í…ìŠ¤íŠ¸ ì„¤ì •
        self.parser.set_original_text(cleaned_content)
        
        # íŒŒì„œë¡œ í•¨ìˆ˜ ì¶”ì¶œ
        functions = self.parser.parse(cleaned_content)
        
        # í•¨ìˆ˜ ì¶”ì¶œ ì§í›„ MyBatis ë°”ì¸ë”© ë³€ìˆ˜ ì²˜ë¦¬ (ê°œì„ ëœ ë²„ì „)
        processed_functions = []
        for func in functions:
            # MyBatis ë°”ì¸ë”© ë³€ìˆ˜ ì²˜ë¦¬ ê°œì„ : jdbcType ì†ì„±ì„ í¬í•¨í•œ ì „ì²´ íŒ¨í„´ ì²˜ë¦¬
            # #{paramName,jdbcType=VARCHAR} â†’ 1
            # ${paramName,jdbcType=VARCHAR} â†’ 1
            processed_func = re.sub(r'#\{[^}]*\}', '1', func)
            processed_func = re.sub(r'\$\{[^}]*\}', '1', processed_func)
            
            # ì¶”ê°€ ì •ë¦¬: ë°”ì¸ë”© ë³€ìˆ˜ ì²˜ë¦¬ í›„ ë‚¨ì€ jdbcType ê´€ë ¨ íŒ¨í„´ ì œê±°
            # ", jdbcType = VARCHAR" íŒ¨í„´ ì œê±°
            processed_func = re.sub(r',\s*jdbcType\s*=\s*\w+', '', processed_func, flags=re.IGNORECASE)
            # "1, 1 = VARCHAR" â†’ "1" íŒ¨í„´ ìˆ˜ì •
            processed_func = re.sub(r'1,\s*1\s*=\s*\w+', '1', processed_func, flags=re.IGNORECASE)
            
            # í…Œì´ë¸”ë³„ì¹­.ì»¬ëŸ¼ëª… íŒ¨í„´ì„ ë¯¸ë¦¬ ì²˜ë¦¬ (íŒŒì„œ ì²˜ë¦¬ ì „ì—)
            # ì´ë ‡ê²Œ í•˜ë©´ íŒŒì„œê°€ í…Œì´ë¸”ë³„ì¹­ê³¼ ì»¬ëŸ¼ëª…ì„ ë”°ë¡œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
            processed_func = re.sub(r'\b[A-Za-z][A-Za-z0-9_]*\.[A-Za-z0-9_]+\b', '1', processed_func, flags=re.IGNORECASE)
            
            # ê³µë°±ì´ ìˆëŠ” í…Œì´ë¸”ë³„ì¹­. ì»¬ëŸ¼ëª… íŒ¨í„´ë„ ì²˜ë¦¬ (C. NO â†’ 1)
            processed_func = re.sub(r'\b[A-Za-z][A-Za-z0-9_]*\.\s+[A-Za-z0-9_]+\b', '1', processed_func, flags=re.IGNORECASE)
            
            processed_functions.append(processed_func)
        
        functions = processed_functions
        
        if self.debug:
            print("ğŸ”§ MyBatis ë°”ì¸ë”© ë³€ìˆ˜ ì²˜ë¦¬ ì™„ë£Œ: #{...} â†’ 1, ${...} â†’ 1")
        
        # ì¶”ì¶œëœ í•¨ìˆ˜ë“¤ì—ì„œ ì¶”ê°€ ì •ë¦¬ (í›„ì²˜ë¦¬)
        cleaned_functions = []
        for func in functions:
            cleaned_func = self.post_process_extracted_function(func)
            if cleaned_func and cleaned_func.strip():
                cleaned_functions.append(cleaned_func)
        
        return cleaned_functions
    
    def clean_xml_content_for_parsing(self, xml_content):
        """í•¨ìˆ˜ ì¶”ì¶œì„ ìœ„í•œ XML íƒœê·¸ ì œê±° (ë¹„êµ ì—°ì‚°ì ë³´í˜¸)"""
        # XML ì£¼ì„ ì œê±°
        content = re.sub(r'<!--.*?-->', '', xml_content, flags=re.DOTALL)
        
        # CDATA íƒœê·¸ ì œê±°
        content = re.sub(r'<!\[CDATA\[(.*?)\]\]>', r'\1', content, flags=re.DOTALL)
        
        # ë™ì  íƒœê·¸ë“¤ ì œê±° - ë” ì •í™•í•œ íŒ¨í„´ ì‚¬ìš©
        # íƒœê·¸ëŠ” ë°˜ë“œì‹œ <íƒœê·¸ëª…ìœ¼ë¡œ ì‹œì‘í•´ì•¼ í•¨ (ê³µë°±ì´ë‚˜ ìˆ«ìë¡œ ì‹œì‘í•˜ëŠ” < ëŠ” ì œì™¸)
        dynamic_tags = [
            r'<if\s[^>]*>.*?</if\s*>', r'<choose\s[^>]*>.*?</choose\s*>',
            r'<when\s[^>]*>.*?</when\s*>', r'<otherwise\s[^>]*>.*?</otherwise\s*>',
            r'<where\s[^>]*>.*?</where\s*>', r'<set\s[^>]*>.*?</set\s*>',
            r'<trim\s[^>]*>.*?</trim\s*>', r'<foreach\s[^>]*>.*?</foreach\s*>',
            r'<include\s[^>]*/>', 
            # ì†ì„±ì´ ì—†ëŠ” íƒœê·¸ë“¤ë„ ì²˜ë¦¬
            r'<if>.*?</if>', r'<choose>.*?</choose>',
            r'<when>.*?</when>', r'<otherwise>.*?</otherwise>',
            r'<where>.*?</where>', r'<set>.*?</set>',
            r'<trim>.*?</trim>', r'<foreach>.*?</foreach>',
        ]
        
        for tag_pattern in dynamic_tags:
            content = re.sub(tag_pattern, '', content, flags=re.DOTALL | re.IGNORECASE)
        
        # ì¶”ê°€: ë‚¨ì€ XML íƒœê·¸ë“¤ ì œê±° (ê³µë°±ì´ ìˆëŠ” íƒœê·¸ í¬í•¨)
        # </ if >, </ when > ë“±ì˜ íŒ¨í„´ ì²˜ë¦¬
        content = re.sub(r'<\s*/\s*\w+\s*>', '', content, flags=re.IGNORECASE)
        content = re.sub(r'<\s*\w+\s*[^>]*>', '', content, flags=re.IGNORECASE)
        
        if self.debug:
            print(f"ğŸ”§ XML íƒœê·¸ ì œê±° ì™„ë£Œ")
        
        return content.strip()
    
    def post_process_extracted_function(self, function_text):
        """ì¶”ì¶œëœ í•¨ìˆ˜ì˜ í›„ì²˜ë¦¬ (ê¸°ì¡´ remove_xml_tags_from_function ë¡œì§ í™œìš©)"""
        if not function_text:
            return function_text
            
        result = function_text
        
        # SQL ì£¼ì„ ì œê±° (-- ì£¼ì„) - í•¨ìˆ˜ë³„ë¡œ ê°œë³„ ì²˜ë¦¬
        result = re.sub(r'--[^\r\n]*', ' ', result)
        
        # í˜¹ì‹œ ë‚¨ì€ XML íƒœê·¸ ì œê±° (ë¹„êµ ì—°ì‚°ì ë³´í˜¸)
        # XML íƒœê·¸ëŠ” <íƒœê·¸ëª…ìœ¼ë¡œ ì‹œì‘í•´ì•¼ í•¨ (< ë’¤ì— ê³µë°±ì´ë‚˜ ìˆ«ìê°€ ì˜¤ë©´ ë¹„êµ ì—°ì‚°ì)
        result = re.sub(r'<([a-zA-Z][^>]*)>', '', result, flags=re.IGNORECASE)
        
        # AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´ ìˆ˜ì •
        result = self.fix_missing_and_operators(result)
        
        # ë™ì  íƒœê·¸ ì œê±°ë¡œ ì¸í•œ CASE WHEN THEN íŒ¨í„´ ìˆ˜ì •
        # CASE WHEN THEN â†’ CASE WHEN 1=1 THEN
        if re.search(r'CASE\s+WHEN\s+THEN', result, re.IGNORECASE):
            result = re.sub(r'CASE\s+WHEN\s+THEN', 'CASE WHEN 1=1 THEN', result, flags=re.IGNORECASE)
            if self.debug:
                print(f"ğŸ”§ CASE WHEN THEN â†’ CASE WHEN 1=1 THEN ìˆ˜ì •: {result}")
        
        # ì—¬ëŸ¬ ê³µë°±ì„ í•˜ë‚˜ë¡œ ì •ë¦¬
        result = re.sub(r'\s+', ' ', result)
        
        return result.strip()
    
    def remove_xml_tags_from_function(self, function_text):
        """ê°œë³„ í•¨ìˆ˜ì—ì„œ XML íƒœê·¸ ì œê±° ë° AND ì—°ì‚°ì ëˆ„ë½ ìˆ˜ì •"""
        if not function_text:
            return function_text
            
        result = function_text
        
        # XML ì£¼ì„ ì œê±°
        result = re.sub(r'<!--.*?-->', '', result, flags=re.DOTALL)
        
        # SQL ì£¼ì„ ì œê±° (-- ì£¼ì„)
        result = re.sub(r'--[^\r\n]*', ' ', result)
        
        # CDATA íƒœê·¸ ì œê±°
        result = re.sub(r'<!\[CDATA\[(.*?)\]\]>', r'\1', result, flags=re.DOTALL)
        
        # ìƒí˜¸ ë°°íƒ€ì  ì¡°ê±´ë¬¸ íŒ¨í„´ ì²˜ë¦¬
        result = self.handle_mutually_exclusive_conditions(result)
        
        # ë‚˜ë¨¸ì§€ ë™ì  íƒœê·¸ë“¤ ì œê±° (íƒœê·¸ë§Œ ì œê±°í•˜ê³  ë‚´ìš©ì€ ìœ ì§€)
        result = re.sub(r'<if[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</if>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<choose[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</choose>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<when[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</when>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<otherwise[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</otherwise>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<where[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</where>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<set[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</set>', '', result, flags=re.IGNORECASE)
        # MyBatis <trim> íƒœê·¸ë§Œ ì œê±° (SQL TRIM í•¨ìˆ˜ëŠ” ë³´ì¡´)
        # MyBatis trim íƒœê·¸ëŠ” prefix, suffix, prefixOverrides, suffixOverrides ì†ì„±ì„ ê°€ì§
        result = re.sub(r'<trim\s+[^>]*(?:prefix|suffix|prefixOverrides|suffixOverrides)[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</trim>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<foreach[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</foreach>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<include[^>]*/?>', '', result, flags=re.IGNORECASE)
        
        # AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´ ìˆ˜ì •
        result = self.fix_missing_and_operators(result)
        
        # ì—¬ëŸ¬ ê³µë°±ì„ í•˜ë‚˜ë¡œ ì •ë¦¬
        result = re.sub(r'\s+', ' ', result)
        
        return result.strip()
    
    def fix_missing_and_operators(self, text):
        """AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´ ìˆ˜ì •"""
        result = text
        
        # íŒ¨í„´ 1: = 'Y' IFNULL(...) = '1' THEN â†’ = 'Y' AND IFNULL(...) = '1' THEN
        pattern1 = r"=\s*'Y'\s+(IFNULL\([^)]+\)[^=]*=\s*'[^']+'\s+THEN)"
        replacement1 = r"= 'Y' AND \1"
        
        if re.search(pattern1, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´1 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern1, replacement1, result, flags=re.IGNORECASE)
        
        # íŒ¨í„´ 2: = 'SELK138AX' 1 = 1 â†’ = 'SELK138AX' AND 1 = 1
        pattern2 = r"=\s*'([^']+)'\s+(\d+\s*=\s*\d+)"
        replacement2 = r"= '\1' AND \2"
        
        if re.search(pattern2, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´2 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern2, replacement2, result, flags=re.IGNORECASE)
        
        # íŒ¨í„´ 3: IFNULL( 1,0) 1 END â†’ IFNULL( 1,0) ELSE 1 END
        pattern3 = r"IFNULL\s*\(\s*[^,]+,\s*[^)]+\)\s+(\d+\s+END)"
        replacement3 = r"IFNULL( 1,0) ELSE \1"
        
        if re.search(pattern3, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´3 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern3, replacement3, result, flags=re.IGNORECASE)
        
        # íŒ¨í„´ 4: 1 <> 0 1 > 0 â†’ 1 <> 0 AND 1 > 0
        pattern4 = r"(\d+\s*<>\s*\d+)\s+(\d+\s*>\s*\d+)"
        replacement4 = r"\1 AND \2"
        
        if re.search(pattern4, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´4 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern4, replacement4, result, flags=re.IGNORECASE)
        
        # íŒ¨í„´ 5: THEN IFNULL( 1,0) 1 END â†’ THEN IFNULL( 1,0) AND 1 END
        pattern5 = r"THEN\s+IFNULL\s*\(\s*[^,]+,\s*[^)]+\)\s+(\d+\s+END)"
        replacement5 = r"THEN IFNULL( 1,0) AND \1"
        
        if re.search(pattern5, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´5 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern5, replacement5, result, flags=re.IGNORECASE)
        
        # íŒ¨í„´ 7: THEN IFNULL(...) 1 END â†’ THEN 1 ELSE 1 END (ë³µì¡í•œ CASE ë¬¸ ê°„ì†Œí™”)
        pattern7 = r"THEN\s+IFNULL\s*\([^)]+\)\s+(\d+)\s+END"
        replacement7 = r"THEN 1 ELSE 1 END"
        
        if re.search(pattern7, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´7 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern7, replacement7, result, flags=re.IGNORECASE)
        
        return result
    
    def handle_mutually_exclusive_conditions(self, text):
        """ìƒí˜¸ ë°°íƒ€ì  ì¡°ê±´ë¬¸ ì²˜ë¦¬ - ì²« ë²ˆì§¸ ì¡°ê±´ë§Œ ì„ íƒ"""
        
        # ìƒí˜¸ ë°°íƒ€ì  íŒ¨í„´ë“¤ ì •ì˜
        mutually_exclusive_patterns = [
            # íŒ¨í„´ 1: onefarebasis null ì²´í¬
            {
                'pattern': r'<if\s+test="[^"]*onefarebasis[^"]*!=\s*\'\'[^"]*"[^>]*>(.*?)</if>\s*<if\s+test="[^"]*onefarebasis[^"]*==\s*\'\'[^"]*"[^>]*>(.*?)</if>',
                'replacement': r'\1'  # ì²« ë²ˆì§¸ ì¡°ê±´ë§Œ ì„ íƒ
            },
            # íŒ¨í„´ 2: ì¼ë°˜ì ì¸ null/not null ì²´í¬
            {
                'pattern': r'<if\s+test="[^"]*!=\s*null[^"]*"[^>]*>(.*?)</if>\s*<if\s+test="[^"]*==\s*null[^"]*"[^>]*>(.*?)</if>',
                'replacement': r'\1'  # ì²« ë²ˆì§¸ ì¡°ê±´ë§Œ ì„ íƒ
            },
            # íŒ¨í„´ 3: empty/not empty ì²´í¬
            {
                'pattern': r'<if\s+test="[^"]*!=\s*\'\'[^"]*"[^>]*>(.*?)</if>\s*<if\s+test="[^"]*==\s*\'\'[^"]*"[^>]*>(.*?)</if>',
                'replacement': r'\1'  # ì²« ë²ˆì§¸ ì¡°ê±´ë§Œ ì„ íƒ
            }
        ]
        
        result = text
        
        for pattern_info in mutually_exclusive_patterns:
            pattern = pattern_info['pattern']
            replacement = pattern_info['replacement']
            
            # ìƒí˜¸ ë°°íƒ€ì  íŒ¨í„´ ì°¾ê¸° ë° ì²« ë²ˆì§¸ ì¡°ê±´ë§Œ ì„ íƒ
            matches = re.findall(pattern, result, flags=re.DOTALL | re.IGNORECASE)
            if matches:
                if self.debug:
                    print(f"ğŸ” ìƒí˜¸ ë°°íƒ€ì  ì¡°ê±´ë¬¸ ë°œê²¬: {len(matches)}ê°œ")
                    for i, match in enumerate(matches):
                        print(f"  ì¡°ê±´ {i+1}-1: {match[0][:100]}...")
                        if len(match) > 1:
                            print(f"  ì¡°ê±´ {i+1}-2: {match[1][:100]}...")
                
                result = re.sub(pattern, replacement, result, flags=re.DOTALL | re.IGNORECASE)
        
        return result
    
    def protect_string_literals(self, text):
        """ë¬¸ìì—´ ë¦¬í„°ëŸ´ì„ ì„ì‹œ í† í°ìœ¼ë¡œ ë³´í˜¸"""
        self.string_map = {}
        result = text
        
        # í°ë”°ì˜´í‘œ ë¬¸ìì—´ ë³´í˜¸ "text"
        string_count = 0
        while True:
            match = re.search(r'"[^"]*"', result)
            if not match:
                break
            token = f"__DSTRING_{string_count}__"
            original = match.group(0)
            self.string_map[token] = original
            result = result.replace(original, token, 1)
            string_count += 1
        
        # ì‘ì€ë”°ì˜´í‘œ ë¬¸ìì—´ ë³´í˜¸ 'text'
        while True:
            match = re.search(r"'[^']*'", result)
            if not match:
                break
            token = f"__SSTRING_{string_count}__"
            original = match.group(0)
            self.string_map[token] = original
            result = result.replace(original, token, 1)
            string_count += 1
        
        return result
    
    def restore_string_literals(self, text):
        """ë³´í˜¸ëœ ë¬¸ìì—´ ë¦¬í„°ëŸ´ì„ ë³µì›"""
        result = text
        for token, original in self.string_map.items():
            result = result.replace(token, original)
        return result
    
    def analyze_nested_functions(self, func_text):
        """sqlparseë¥¼ ì‚¬ìš©í•˜ì—¬ ì¤‘ì²© í•¨ìˆ˜ ë¶„ì„"""
        try:
            import sqlparse
            from sqlparse.sql import Function, Parenthesis
            
            parsed = sqlparse.parse(func_text)[0]
            
            def find_functions(token, depth=0):
                functions = []
                if isinstance(token, Function):
                    func_info = {
                        'name': token.get_name(),
                        'depth': depth,
                        'full_text': str(token).strip()
                    }
                    functions.append(func_info)
                    
                    # í•¨ìˆ˜ ë‚´ë¶€ì˜ ì¤‘ì²© í•¨ìˆ˜ ì°¾ê¸°
                    for sub_token in token.tokens:
                        functions.extend(find_functions(sub_token, depth + 1))
                
                elif hasattr(token, 'tokens'):
                    for sub_token in token.tokens:
                        functions.extend(find_functions(sub_token, depth))
                
                return functions
            
            nested_funcs = find_functions(parsed)
            
            if self.debug and nested_funcs:
                print(f"ğŸ” ì¤‘ì²© í•¨ìˆ˜ ë¶„ì„:")
                for func in nested_funcs:
                    indent = "  " * func['depth']
                    print(f"    {indent}â””â”€ {func['name']} (depth: {func['depth']})")
            
            return nested_funcs
            
        except Exception as e:
            if self.debug:
                print(f"ğŸ” ì¤‘ì²© í•¨ìˆ˜ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return []

    def process_cast_functions_with_parser(self, sql_text):
        """ê°œì„ ëœ CAST í•¨ìˆ˜ AS ì ˆ ë³´í˜¸ - ë‹¨ìˆœí™”ëœ ì ‘ê·¼"""
        
        def find_cast_end(text, start_pos):
            """CAST í•¨ìˆ˜ì˜ ë ìœ„ì¹˜ë¥¼ ê´„í˜¸ ê· í˜•ìœ¼ë¡œ ì°¾ê¸°"""
            paren_count = 0
            for i, char in enumerate(text[start_pos:], start_pos):
                if char == '(':
                    paren_count += 1
                elif char == ')':
                    paren_count -= 1
                    if paren_count == 0:
                        return i + 1
            return -1
        
        result = sql_text
        pos = 0
        
        while True:
            # CAST( íŒ¨í„´ ì°¾ê¸°
            match = re.search(r'CAST\s*\(', result[pos:], re.IGNORECASE)
            if not match:
                break
            
            cast_start = pos + match.start()
            paren_start = pos + match.end() - 1  # '(' ìœ„ì¹˜
            
            # ê´„í˜¸ ê· í˜•ìœ¼ë¡œ CAST í•¨ìˆ˜ ë ì°¾ê¸°
            cast_end = find_cast_end(result, paren_start)
            if cast_end == -1:
                pos = cast_start + 1
                continue
            
            full_cast = result[cast_start:cast_end]
            
            if self.debug:
                print(f"ğŸ” CAST í•¨ìˆ˜ ë°œê²¬: {full_cast[:50]}...")
            
            # AS ì ˆì´ ì´ë¯¸ ìˆëŠ”ì§€ í™•ì¸
            if ' AS ' in full_cast.upper():
                if self.debug:
                    print(f"âœ… AS ì ˆì´ ì´ë¯¸ ìˆìŒ")
                pos = cast_end
                continue
            
            # AS ì ˆì´ ì—†ëŠ” ê²½ìš° ì¶”ê°€
            cast_content = full_cast[5:-1]  # 'CAST(' ì™€ ')' ì œê±°
            fixed_cast = f"CAST({cast_content} AS CHAR)"
            
            if self.debug:
                print(f"ğŸ”§ AS ì ˆ ì¶”ê°€: {fixed_cast[:50]}...")
            
            # êµì²´
            result = result[:cast_start] + fixed_cast + result[cast_end:]
            pos = cast_start + len(fixed_cast)
        
        if self.debug and result != sql_text:
            print(f"ğŸ” CAST í•¨ìˆ˜ AS ì ˆ ë³´í˜¸ ì™„ë£Œ")
        
        return result
    
    def _fix_cast_function(self, cast_token):
        """ê°œë³„ CAST í•¨ìˆ˜ í† í° ìˆ˜ì •"""
        cast_str = str(cast_token)
        cast_upper = cast_str.upper()
        
        # CAST í•¨ìˆ˜ ë‚´ìš© ë¶„ì„
        if ' AS ' not in cast_upper:
            # AS ì ˆì´ ì—†ëŠ” ê²½ìš° - CAST(value) â†’ CAST(value AS CHAR)
            # ê´„í˜¸ ë§¤ì¹­ì„ í†µí•œ ë‚´ìš© ì¶”ì¶œ
            content = self._extract_cast_content(cast_str)
            if content:
                return f'CAST({content} AS CHAR)'
        
        elif 'AS DECIMAL' in cast_upper:
            # DECIMALì€ MySQLì—ì„œ ì™„ì „íˆ ì§€ì›í•˜ë¯€ë¡œ ê·¸ëŒ€ë¡œ ìœ ì§€ (precision, scale í¬í•¨)
            return cast_str
        
        elif 'AS SIGNED' in cast_upper or 'AS UNSIGNED' in cast_upper:
            # SIGNED/UNSIGNEDëŠ” MySQLì—ì„œ ì§€ì›í•˜ë¯€ë¡œ ê·¸ëŒ€ë¡œ ìœ ì§€
            return cast_str
        
        elif re.search(r'AS\s+\d+', cast_str, re.IGNORECASE):
            # AS ìˆ«ì â†’ AS CHAR
            return re.sub(r'AS\s+\d+', 'AS CHAR', cast_str, flags=re.IGNORECASE)
        
        return cast_str
    
    def _extract_cast_content(self, cast_str):
        """CAST í•¨ìˆ˜ì—ì„œ ê´„í˜¸ ë§¤ì¹­ì„ í†µí•´ ë‚´ìš© ì¶”ì¶œ"""
        import re
        match = re.search(r'CAST\s*\(', cast_str, re.IGNORECASE)
        if not match:
            return None
            
        start_pos = match.end() - 1  # '(' ìœ„ì¹˜
        paren_count = 0
        content_start = start_pos + 1
        
        for i, char in enumerate(cast_str[start_pos:], start_pos):
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count == 0:
                    # ë§¤ì¹­ë˜ëŠ” ')' ì°¾ìŒ
                    content = cast_str[content_start:i].strip()
                    return content
        
        return None
    
    def _find_cast_end(self, cast_str):
        """CAST í•¨ìˆ˜ì˜ ë ìœ„ì¹˜ë¥¼ ì°¾ìŒ"""
        if not cast_str.upper().startswith('CAST('):
            return -1
            
        paren_count = 0
        start_pos = 4  # 'CAST' ë‹¤ìŒë¶€í„°
        
        for i, char in enumerate(cast_str[start_pos:], start_pos):
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count == 0:
                    return i + 1  # ')' ë‹¤ìŒ ìœ„ì¹˜
        
        return len(cast_str)  # ë§¤ì¹­ë˜ëŠ” ')' ì—†ìœ¼ë©´ ì „ì²´ ê¸¸ì´
    
    def remove_as_aliases_with_parser(self, sql_text):
        """sqlparseë¥¼ ì‚¬ìš©í•˜ì—¬ AS ë³„ì¹­ì„ ì•ˆì „í•˜ê²Œ ì œê±°"""
        try:
            # ë¨¼ì € CAST í•¨ìˆ˜ë“¤ì„ ë³´í˜¸
            protected_casts = []
            temp_sql = sql_text
            
            # CAST í•¨ìˆ˜ë¥¼ ì°¾ì•„ì„œ ë³´í˜¸
            cast_pattern = r'CAST\s*\('
            pos = 0
            while True:
                match = re.search(cast_pattern, temp_sql[pos:], re.IGNORECASE)
                if not match:
                    break
                
                actual_pos = pos + match.start()
                cast_content = self._extract_cast_with_position(temp_sql, actual_pos)
                if cast_content:
                    full_cast, end_pos = cast_content
                    placeholder = f'__PROTECTED_CAST_{len(protected_casts)}__'
                    protected_casts.append((placeholder, full_cast))
                    temp_sql = temp_sql[:actual_pos] + placeholder + temp_sql[actual_pos + end_pos:]
                    pos = actual_pos + len(placeholder)
                else:
                    pos = actual_pos + 1
            
            # ì´ì œ ì¼ë°˜ AS ë³„ì¹­ ì œê±° (CASTëŠ” ë³´í˜¸ë¨)
            # í•˜ì§€ë§Œ í•¨ìˆ˜ì˜ íŒŒë¼ë¯¸í„° ë‚´ë¶€ëŠ” ë³´í˜¸í•´ì•¼ í•¨
            # ), 0) AS alias íŒ¨í„´ì—ì„œ ), 0) ë¶€ë¶„ì„ ë³´í˜¸
            temp_sql = re.sub(r'\)\s*,\s*([^)]+)\)\s+AS\s+[A-Za-z_][A-Za-z0-9_]*\b', r'), \1)', temp_sql, flags=re.IGNORECASE)
            
            # ì¼ë°˜ì ì¸ AS ë³„ì¹­ ì œê±°
            temp_sql = re.sub(r'\)\s+AS\s+[A-Za-z_][A-Za-z0-9_]*\b(?!\s*\))', ')', temp_sql, flags=re.IGNORECASE)
            temp_sql = re.sub(r'END\s+AS\s+[A-Za-z_][A-Za-z0-9_]*\b', 'END', temp_sql, flags=re.IGNORECASE)
            
            # ë³´í˜¸ëœ CAST í•¨ìˆ˜ë“¤ ë³µì›
            for placeholder, original in protected_casts:
                temp_sql = temp_sql.replace(placeholder, original)
            
            if self.debug:
                print(f"ğŸ” sqlparse ê¸°ë°˜ AS ë³„ì¹­ ì œê±° í›„: {temp_sql}")
            
            return temp_sql
            
        except Exception as e:
            if self.debug:
                print(f"ğŸ” sqlparse AS ë³„ì¹­ ì œê±° ì˜¤ë¥˜: {e}, ì •ê·œì‹ ì‚¬ìš©")
            # ê¸°ì¡´ ì •ê·œì‹ ë°©ì‹ìœ¼ë¡œ fallback
            result = re.sub(r'\)\s+AS\s+[A-Za-z_][A-Za-z0-9_]*\b(?!\s*\))', ')', sql_text, flags=re.IGNORECASE)
            result = re.sub(r'END\s+AS\s+[A-Za-z_][A-Za-z0-9_]*\b', 'END', result, flags=re.IGNORECASE)
            return result
    
    def _extract_cast_with_position(self, sql_text, start_pos):
        """ì§€ì •ëœ ìœ„ì¹˜ì—ì„œ CAST í•¨ìˆ˜ ì „ì²´ë¥¼ ì¶”ì¶œ"""
        if not sql_text[start_pos:].upper().startswith('CAST'):
            return None
            
        # CAST( ì°¾ê¸°
        match = re.search(r'CAST\s*\(', sql_text[start_pos:], re.IGNORECASE)
        if not match:
            return None
            
        paren_start = start_pos + match.end() - 1  # '(' ìœ„ì¹˜
        paren_count = 0
        
        for i, char in enumerate(sql_text[paren_start:], paren_start):
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count == 0:
                    # ë§¤ì¹­ë˜ëŠ” ')' ì°¾ìŒ
                    full_cast = sql_text[start_pos:i+1]
                    return full_cast, i + 1 - start_pos
        
        return None

    def _find_balanced_parentheses(self, text, start_pos):
        """ê´„í˜¸ ê· í˜•ì„ ê³ ë ¤í•˜ì—¬ ì„œë¸Œì¿¼ë¦¬ ë ìœ„ì¹˜ ì°¾ê¸°"""
        count = 0
        i = start_pos
        while i < len(text):
            if text[i] == '(':
                count += 1
            elif text[i] == ')':
                count -= 1
                if count == 0:
                    return i
            i += 1
        return -1

    def _extract_subqueries_balanced(self, sql):
        """ê´„í˜¸ ê· í˜•ì„ ê³ ë ¤í•œ ì„œë¸Œì¿¼ë¦¬ ì¶”ì¶œ"""
        subqueries = []
        i = 0
        
        while i < len(sql):
            # SELECT íŒ¨í„´ ì°¾ê¸° (ëŒ€ì†Œë¬¸ì ë¬´ê´€)
            match = re.search(r'\(\s*SELECT\s+', sql[i:], re.IGNORECASE)
            if not match:
                break
                
            start_pos = i + match.start()
            select_pos = i + match.end() - 1  # SELECT ë ìœ„ì¹˜
            
            # ê´„í˜¸ ê· í˜• ì°¾ê¸°
            end_pos = self._find_balanced_parentheses(sql, start_pos)
            if end_pos != -1:
                subquery = sql[start_pos:end_pos + 1]
                subqueries.append(subquery)
                i = end_pos + 1
            else:
                i = select_pos + 1
        
        return subqueries

    def _find_cast_end(self, cast_str):
        """CAST í•¨ìˆ˜ì˜ ë ìœ„ì¹˜ë¥¼ ì°¾ìŒ"""
        import re
        match = re.search(r'CAST\s*\(', cast_str, re.IGNORECASE)
        if not match:
            return -1
            
        start_pos = match.end() - 1  # '(' ìœ„ì¹˜
        paren_count = 0
        
        for i, char in enumerate(cast_str[start_pos:], start_pos):
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count == 0:
                    # ë§¤ì¹­ë˜ëŠ” ')' ì°¾ìŒ
                    return i + 1
        
        return -1
        """CAST í•¨ìˆ˜ì—ì„œ ê´„í˜¸ ë§¤ì¹­ì„ í†µí•´ ë‚´ìš© ì¶”ì¶œ"""
        import re
        match = re.search(r'CAST\s*\(', cast_str, re.IGNORECASE)
        if not match:
            return None
            
        start_pos = match.end() - 1  # '(' ìœ„ì¹˜
        paren_count = 0
        content_start = start_pos + 1
        
        for i, char in enumerate(cast_str[start_pos:], start_pos):
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count == 0:
                    # ë§¤ì¹­ë˜ëŠ” ')' ì°¾ìŒ
                    content = cast_str[content_start:i].strip()
                    return content
        
        return None

    def transform_function(self, func):
        """í•¨ìˆ˜ë¥¼ ê²€ì¦ ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜ (v1.6 ìœˆë„ìš° í•¨ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ê°œì„ )"""
        result = func
        
        if self.debug:
            print(f"ğŸ” ì›ë³¸ í•¨ìˆ˜: {func}")
        
        # 0-0. ì¤‘ì²© í•¨ìˆ˜ ë¶„ì„ (ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ)
        if self.debug:
            self.analyze_nested_functions(func)
        
        # 0-1. ìˆ«ì AS CHAR(255) íŒ¨í„´ì„ ìˆ«ìë§Œ ë‚¨ê¸°ë„ë¡ ì „ì²˜ë¦¬
        result = re.sub(r"(\d+)\s+AS\s+CHAR\(\d+\)", r"\1", result, flags=re.IGNORECASE)
        result = re.sub(r"'(\d+)'\s+AS\s+CHAR\(\d+\)", r"'\1'", result, flags=re.IGNORECASE)
        
        # 0-1. TRIM í•¨ìˆ˜ ë³´í˜¸
        trim_placeholders = {}
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ í”Œë ˆì´ìŠ¤í™€ë”ë¥¼ ê³ ë ¤í•œ íŒ¨í„´
        trim_pattern = r'TRIM\s*\(\s*(LEADING|TRAILING|BOTH)\s+([^)]+?)\s+FROM\s+([^)]+?)\s*\)'
        trim_matches = list(re.finditer(trim_pattern, result, flags=re.IGNORECASE | re.DOTALL))
        for i, match in enumerate(trim_matches):
            placeholder = f'__TRIM_FUNCTION_{i}__'
            trim_placeholders[placeholder] = match.group(0)
            result = result.replace(match.group(0), placeholder, 1)
        
        if self.debug and trim_placeholders:
            print(f"ğŸ”§ TRIM í•¨ìˆ˜ ë³´í˜¸: {len(trim_placeholders)}ê°œ")
            for placeholder, original in trim_placeholders.items():
                print(f"  {placeholder}: {original[:100]}...")
        
        # 0-2. TRIM í•¨ìˆ˜ ë³µì›
        for placeholder, original in trim_placeholders.items():
            result = result.replace(placeholder, original)
        
        if self.debug and trim_placeholders:
            print(f"ğŸ”§ TRIM í•¨ìˆ˜ ë³µì›: {len(trim_placeholders)}ê°œ")
        
        # 0-3. TRIM í•¨ìˆ˜ ë³µì›
        for placeholder, original in trim_placeholders.items():
            result = result.replace(placeholder, original)
        
        if self.debug and trim_placeholders:
            print(f"ğŸ”§ TRIM í•¨ìˆ˜ ë³µì›: {len(trim_placeholders)}ê°œ")
        
        # ë³µì¡í•œ í•¨ìˆ˜ í•„í„°ë§ ë¡œì§ ì‚­ì œ - ëª¨ë“  í•¨ìˆ˜ë¥¼ í…ŒìŠ¤íŠ¸ ëŒ€ìƒìœ¼ë¡œ í¬í•¨
        
        # 0. CAST í•¨ìˆ˜ ì²˜ë¦¬ (ê°€ì¥ ë¨¼ì €) - sqlparse ê¸°ë°˜ìœ¼ë¡œ ì •í™•í•œ êµ¬ì¡° íŒŒì•…
        result = self.process_cast_functions_with_parser(result)
        
        if self.debug:
            print(f"ğŸ” CAST í•¨ìˆ˜ ì²˜ë¦¬ í›„: {result}")
        
        # 1. AS ë³„ì¹­ ì œê±° - sqlparse ê¸°ë°˜ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
        result = self.remove_as_aliases_with_parser(result)
        
        # 2. ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸
        result = self.protect_string_literals(result)
        
        # 3. MyBatis íŒŒë¼ë¯¸í„° ì²˜ë¦¬ #{...} â†’ 1, ${...} â†’ 1 (ì¶”ê°€ ë³´í˜¸)
        result = re.sub(r'#\{[^}]*\}', '1', result)
        result = re.sub(r'\$\{[^}]*\}', '1', result)
        
    def transform_function_for_testing_with_parser(self, func):
        """íŒŒì„œ ê¸°ë°˜ìœ¼ë¡œ í•¨ìˆ˜ë¥¼ ì™„ì „íˆ ì²˜ë¦¬"""
        try:
            import sqlparse
            from sqlparse.sql import Statement, Function, Parenthesis, IdentifierList, Identifier
            from sqlparse.tokens import Keyword, Name, String, Number
            
            if self.debug:
                print(f"ğŸ” ì›ë³¸ í•¨ìˆ˜: {func}")
            
            # 1. íŒŒì„œë¡œ êµ¬ì¡° íŒŒì•…
            parsed = sqlparse.parse(func)[0]
            
            # 2. ì¤‘ì²© í•¨ìˆ˜ ë¶„ì„
            nested_funcs = self.analyze_nested_functions(func)
            if nested_funcs and self.debug:
                func_info = [f"{f['name']}(depth:{f['depth']})" for f in nested_funcs]
                print(f"ğŸ” íŒŒì„œ ê¸°ë°˜ ì²˜ë¦¬ ìˆœì„œ: {func_info}")
            
            def process_token_recursively(token):
                """í† í°ì„ ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬ (ì•ˆìª½ë¶€í„°)"""
                
                # ì„œë¸Œì¿¼ë¦¬ ì²˜ë¦¬: (SELECT ... FROM ...) â†’ (SELECT 1)
                if isinstance(token, Parenthesis):
                    inner_text = str(token).strip()
                    if inner_text.upper().startswith('(SELECT') or inner_text.upper().startswith('( SELECT'):
                        # FROM ì´í›„ ì œê±°í•˜ê³  SELECT 1ë¡œ ë³€ê²½
                        return '(SELECT 1)'
                
                # í•¨ìˆ˜ ì²˜ë¦¬ - í•¨ìˆ˜ëª…ì€ ë³´í˜¸, ë‚´ë¶€ íŒŒë¼ë¯¸í„°ë§Œ ì¬ê·€ ì²˜ë¦¬
                elif isinstance(token, Function):
                    func_name = str(token.get_name()).upper()
                    if func_name in self.mysql_reserved_words or func_name in self.all_functions:
                        # í•¨ìˆ˜ëª…ì€ ë³´í˜¸, ë‚´ë¶€ íŒŒë¼ë¯¸í„°ë§Œ ì²˜ë¦¬
                        processed_params = []
                        for sub_token in token.tokens:
                            processed_params.append(process_token_recursively(sub_token))
                        return ''.join(processed_params)
                
                # ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸
                elif token.ttype is String.Single or token.ttype is String.Symbol:
                    return str(token)  # ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸
                
                # ìˆ«ì ë¦¬í„°ëŸ´ ë³´í˜¸  
                elif token.ttype is Number.Integer or token.ttype is Number.Float:
                    return str(token)  # ìˆ«ì ë¦¬í„°ëŸ´ ë³´í˜¸
                
                # ì˜ˆì•½ì–´ ë³´í˜¸ (CASE, WHEN, THEN, ELSE, END í¬í•¨)
                elif token.ttype is Keyword:
                    keyword = str(token).upper()
                    if keyword in self.mysql_reserved_words:
                        return str(token)  # ì˜ˆì•½ì–´ ë³´í˜¸
                
                # ì‹ë³„ì (ì»¬ëŸ¼ëª…, í…Œì´ë¸”ëª…) â†’ 1ë¡œ ì¹˜í™˜ (ì•ˆìª½ë¶€í„°)
                elif isinstance(token, Identifier) or token.ttype is Name:
                    name = str(token).upper()
                    # CASE ë¬¸ í‚¤ì›Œë“œëŠ” ë³´í˜¸
                    if name in ['CASE', 'WHEN', 'THEN', 'ELSE', 'END']:
                        return str(token)
                    elif name not in self.mysql_reserved_words and name not in self.all_functions:
                        # í…Œì´ë¸”ë³„ì¹­.ì»¬ëŸ¼ëª… íŒ¨í„´ ì²˜ë¦¬ (ê³µë°± í¬í•¨)
                        token_str = str(token)
                        if '.' in token_str:
                            # í…Œì´ë¸”ë³„ì¹­. ì»¬ëŸ¼ëª… (ê³µë°± í¬í•¨) â†’ 1
                            if re.match(r'^[A-Za-z][A-Za-z0-9_]*\.\s*[A-Za-z0-9_]+$', token_str):
                                return '1'
                        return '1'  # ì»¬ëŸ¼ëª…/í…Œì´ë¸”ëª… ì¹˜í™˜
                
                # í•˜ìœ„ í† í°ì´ ìˆëŠ” ê²½ìš° ì¬ê·€ ì²˜ë¦¬ (ì•ˆìª½ë¶€í„°)
                elif hasattr(token, 'tokens'):
                    # CASE ë¬¸ì¸ì§€ í™•ì¸
                    token_str = str(token).upper().strip()
                    if token_str.startswith('CASE'):
                        # CASE ë¬¸ì€ ë‚´ë¶€ êµ¬ì¡°ë¥¼ ë³´ì¡´í•˜ë©´ì„œ ì²˜ë¦¬
                        processed_tokens = []
                        for sub_token in token.tokens:
                            processed_tokens.append(process_token_recursively(sub_token))
                        return ''.join(processed_tokens)
                    else:
                        # ì¼ë°˜ì ì¸ ê²½ìš°
                        processed_tokens = []
                        for sub_token in token.tokens:
                            processed_tokens.append(process_token_recursively(sub_token))
                        return ''.join(processed_tokens)
                
                # ê¸°ë³¸: í† í° ê·¸ëŒ€ë¡œ ë°˜í™˜
                return str(token)
            
            # 3. íŒŒì„œë¡œ ì „ì²´ ì²˜ë¦¬
            result = process_token_recursively(parsed)
            
            if self.debug:
                print(f"ğŸ” íŒŒì„œ ì²˜ë¦¬ ê²°ê³¼: {result}")
            
            return result
            
        except Exception as e:
            if self.debug:
                print(f"ğŸ” íŒŒì„œ ì²˜ë¦¬ ì˜¤ë¥˜: {e}, ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©")
            return self.transform_function_for_testing(func)
        
        # 5. IN 1 â†’ IN (1, 2, 3)
        result = re.sub(r'IN\s+1\b', 'IN (1, 2, 3)', result, flags=re.IGNORECASE)
        
        # 6. í…Œì´ë¸”.ì»¬ëŸ¼ â†’ 1 (ëŒ€ë¬¸ì/ì†Œë¬¸ì ì»¬ëŸ¼ëª… ëª¨ë‘ í¬í•¨)
        result = re.sub(r'\b[A-Z][A-Z0-9_]*\.[a-z_][a-z0-9_]*\b', '1', result)
        result = re.sub(r'\b[A-Z][A-Z0-9_]*\.[A-Z_][A-Z0-9_]*\b', '1', result)
        result = re.sub(r'\b[a-z_][a-z0-9_]*\.[a-z_][a-z0-9_]*\b', '1', result)
        result = re.sub(r'\b[a-z_][a-z0-9_]*\.[A-Z_][A-Z0-9_]*\b', '1', result)
        # í˜¼í•© ì¼€ì´ìŠ¤ ì»¬ëŸ¼ëª… ì²˜ë¦¬ (ì˜ˆ: rsv_SALE_AMT)
        result = re.sub(r'\b[a-z_][a-z0-9_]*\.[a-z_][a-zA-Z0-9_]*\b', '1', result)
        
        # 7. ëŒ€ë¬¸ì ì»¬ëŸ¼ëª… â†’ 1 (í•¨ìˆ˜ëª…ê³¼ ì˜ˆì•½ì–´ ì œì™¸) - ì˜ˆì•½ì–´ ë³´í˜¸ ê°•í™”
        for word in re.findall(r'\b[A-Z][A-Z0-9_]+\b', result):
            if word not in self.all_functions and word.upper() not in self.mysql_reserved_words:
                if not re.search(rf'\b{word}\s*\(', result):
                    # ì˜ˆì•½ì–´ê°€ ì•„ë‹Œ ê²½ìš°ë§Œ ì¹˜í™˜
                    result = re.sub(rf'\b{word}\b(?!\s*\()', '1', result)
        
        # 8. ì»¬ëŸ¼ëª… â†’ 1 (í•¨ìˆ˜ëª…ê³¼ ì˜ˆì•½ì–´ ì œì™¸, ëŒ€ì†Œë¬¸ì ëª¨ë‘ í¬í•¨)
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸
        string_literals = []
        def protect_string(match):
            string_literals.append(match.group(0))
            return f"__STRING_LITERAL_{len(string_literals)-1}__"
        
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ì„ ì„ì‹œ í† í°ìœ¼ë¡œ ì¹˜í™˜ (ë¹ˆ ë¬¸ìì—´ í¬í•¨)
        result = re.sub(r"'[^']*'", protect_string, result)
        
        if self.debug and string_literals:
            print(f"ğŸ”§ ê°œë³„ í•¨ìˆ˜ ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸: {len(string_literals)}ê°œ")
            for i, literal in enumerate(string_literals):
                print(f"  {i}: {literal}")
            print(f"ë³´í˜¸ í›„: {result}")
        elif self.debug:
            print(f"ğŸ”§ ê°œë³„ í•¨ìˆ˜ ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸: 0ê°œ (ì›ë³¸: {result[:100]}...)")
        
        words = re.findall(r'\b[A-Za-z_][A-Za-z0-9_]*\b', result)
        for word in words:
            if word.upper() not in self.all_functions and word.upper() not in self.mysql_reserved_words:
                if not re.search(rf'\b{word}\s*\(', result):
                    # ì„ì‹œ í† í°ì´ ì•„ë‹Œ ê²½ìš°ë§Œ ì¹˜í™˜ (__STRING_LITERAL_, __SSTRING_ í† í° ë³´í˜¸)
                    if (not word.startswith('__STRING_LITERAL_') and 
                        not word.startswith('__SSTRING_')):
                        # ì˜ˆì•½ì–´ ë³´í˜¸ë¥¼ ê³ ë ¤í•œ ì•ˆì „í•œ ì»¬ëŸ¼ëª… ì¹˜í™˜
                        pattern = rf'\b{re.escape(word)}\b(?!\s*\()'
                        def replace_with_space_preservation(match):
                            return '1'
                        result = re.sub(pattern, replace_with_space_preservation, result)
        
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³µì›
        for i, literal in enumerate(string_literals):
            result = result.replace(f"__STRING_LITERAL_{i}__", literal)
        
        if self.debug:
            print(f"ğŸ” ì»¬ëŸ¼ëª… ì¹˜í™˜ í›„: {result}")
        
        # íŠ¹ë³„ í•¨ìˆ˜ ì²˜ë¦¬ (CAST, ìœˆë„ìš° í•¨ìˆ˜, Oracle í•¨ìˆ˜) - ì„ì‹œ ë¹„í™œì„±í™”
        # result = self.parser.fix_special_functions(result)
        
        # CAST í•¨ìˆ˜ ì²˜ë¦¬ëŠ” ì´ë¯¸ ì•ì—ì„œ ì™„ë£Œë¨
        
        if self.debug:
            print(f"ğŸ” íŠ¹ë³„ í•¨ìˆ˜ ì²˜ë¦¬ í›„: {result}")
        
        # 8.5. ìœˆë„ìš° í•¨ìˆ˜ ìœ„ì¹˜ í‘œì‹œ ë¬¸ì œ í•´ê²° (3592 ì˜¤ë¥˜ ë°©ì§€)
        # PARTITION BY (SELECT NULL), 1 â†’ PARTITION BY (SELECT NULL), (SELECT NULL)
        # ORDER BY (SELECT NULL), 1 â†’ ORDER BY (SELECT NULL), (SELECT NULL)
        result = re.sub(r'(PARTITION\s+BY\s+\([^)]+\)),\s*1\b', r'\1, (SELECT NULL)', result, flags=re.IGNORECASE)
        result = re.sub(r'(ORDER\s+BY\s+\([^)]+\)),\s*1\b', r'\1, (SELECT NULL)', result, flags=re.IGNORECASE)
        
        # 9. ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³µì› (ê°€ì¥ ë‚˜ì¤‘)
        result = self.restore_string_literals(result)
        
        if self.debug:
            print(f"ğŸ” ìµœì¢… ê²°ê³¼: {result}")
            print()
        
        return result.strip()
    
    def get_mysql_connection(self):
        """MySQL ì—°ê²° ìƒì„±"""
        try:
            connection = mysql.connector.connect(
                host=os.getenv('MYSQL_HOST', 'localhost'),
                port=int(os.getenv('MYSQL_PORT', '3306')),
                user=os.getenv('MYSQL_USER', 'root'),
                password=os.getenv('MYSQL_PASSWORD', ''),
                database=os.getenv('MYSQL_DATABASE', 'devdb'),
                charset='utf8mb4',
                collation='utf8mb4_unicode_ci'
            )
            return connection
        except mysql.connector.Error as e:
            error_msg = f"MySQL ì—°ê²° ì‹¤íŒ¨: {e}"
            return connection, error_msg
    
    def validate_functions_batch(self, unique_functions, logger, xml_file_path):
        """ë³€í™˜ëœ í•¨ìˆ˜ë“¤ì„ ì¼ê´„ ê²€ì¦"""
        if not unique_functions:
            return False, "ê²€ì¦í•  í•¨ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤", ""
        
        connection_result = self.get_mysql_connection()
        if isinstance(connection_result, tuple):
            connection, error_msg = connection_result
            logger.error(error_msg)
            return False, error_msg, ""
        
        connection = connection_result
        
        try:
            cursor = connection.cursor()
            
            # SELECT ì ˆ ìƒì„±
            select_sql = "SELECT " + ", ".join(unique_functions)
            
            logger.info(f"ìƒì„±ëœ SELECT ë¬¸: {select_sql}")
            
            if self.debug:
                print(f"\nğŸ” DEBUG - ìƒì„±ëœ SELECT ë¬¸:")
                print(f"{select_sql}")
                print()
            
            # SQL ìˆ˜í–‰ ì „ ë§ˆì§€ë§‰ ì •ë¦¬: AS 1 íŒ¨í„´ ì œê±° (ë¬¸ë²• ì˜¤ë¥˜ ë°©ì§€)
            select_sql = self.clean_sql_before_execution(select_sql)
            
            # ì‹¤í–‰
            cursor.execute(select_sql)
            result = cursor.fetchall()
            
            cursor.close()
            connection.close()
            
            success_msg = f"ì„±ê³µ: {len(unique_functions)}ê°œ í•¨ìˆ˜ ëª¨ë‘ ê²€ì¦ ì™„ë£Œ"
            logger.info(success_msg)
            
            # ì„±ê³µ ì‹œ ì‹¤íŒ¨ ëª©ë¡ì—ì„œ ì œê±°
            self.remove_from_failed_result(xml_file_path)
            
            return True, success_msg, select_sql
            
        except mysql.connector.Error as e:
            if connection:
                connection.close()
            error_msg = f"SQL ì˜¤ë¥˜: {e}"
            logger.error(error_msg)
            return False, error_msg, select_sql if 'select_sql' in locals() else ""
    
    def clean_sql_before_execution(self, sql):
        """SQL ìˆ˜í–‰ ì „ ë§ˆì§€ë§‰ ì •ë¦¬: ë‹¤ì–‘í•œ ë¬¸ë²• ì˜¤ë¥˜ íŒ¨í„´ ìˆ˜ì •"""
        original_sql = sql
        
        # 0. WITH ì ˆ ì™„ì „ ì œê±° (CTE ì œê±°) - ê°€ì¥ ë¨¼ì € ì²˜ë¦¬
        # WITH ... AS (...) íŒ¨í„´ì„ ëª¨ë‘ ì œê±°í•˜ì—¬ í•¨ìˆ˜ë§Œ ë‚¨ê¹€
        def remove_with_clause(sql_text):
            """WITH ì ˆê³¼ CTEë¥¼ ì™„ì „íˆ ì œê±°"""
            # WITHë¡œ ì‹œì‘í•˜ëŠ” ë¶€ë¶„ë¶€í„° ë©”ì¸ SELECTê¹Œì§€ ì°¾ê¸°
            with_pattern = r'\bWITH\s+.*?(?=\bSELECT\s+(?!.*\bFROM\s+\w+\s+AS\s*\())'
            
            # WITH ì ˆì´ ìˆëŠ”ì§€ í™•ì¸
            if re.search(r'\bWITH\s+', sql_text, re.IGNORECASE | re.DOTALL):
                # WITH ì ˆ ì „ì²´ë¥¼ ì œê±°í•˜ê³  ë§ˆì§€ë§‰ SELECTë§Œ ë‚¨ê¹€
                # ë³µì¡í•œ íŒ¨í„´ ë§¤ì¹­ ëŒ€ì‹  ë‹¨ìˆœí•˜ê²Œ ì²˜ë¦¬
                lines = sql_text.split('\n')
                in_with_section = False
                main_select_found = False
                result_lines = []
                
                for line in lines:
                    line_upper = line.strip().upper()
                    
                    # WITH ì ˆ ì‹œì‘ ê°ì§€
                    if line_upper.startswith('WITH ') or (in_with_section and ',' in line and 'AS (' in line.upper()):
                        in_with_section = True
                        continue
                    
                    # CTE ì •ì˜ ë¶€ë¶„ ìŠ¤í‚µ
                    if in_with_section and not line_upper.startswith('SELECT '):
                        continue
                    
                    # ë©”ì¸ SELECT ë°œê²¬
                    if in_with_section and line_upper.startswith('SELECT '):
                        in_with_section = False
                        main_select_found = True
                    
                    # WITH ì ˆì´ ì—†ê±°ë‚˜ ë©”ì¸ SELECT ì´í›„ì˜ ë¼ì¸ë“¤ ìœ ì§€
                    if not in_with_section:
                        result_lines.append(line)
                
                return '\n'.join(result_lines)
            
            return sql_text
        
        sql = remove_with_clause(sql)
        
        if self.debug:
            print(f"ğŸ”§ WITH ì ˆ ì œê±° í›„: {len(sql)} ë¬¸ì")
            print(f"ì²˜ë¦¬ëœ SQL ì‹œì‘: {sql[:200]}...")
            print()

        # 0-1. CAST í•¨ìˆ˜ AS ì ˆ ë³´í˜¸ (WITH ì ˆ ì œê±° í›„)
        sql = self.process_cast_functions_with_parser(sql)
        
        if self.debug and sql != original_sql:
            print(f"ğŸ”§ CAST í•¨ìˆ˜ AS ì ˆ ë³´í˜¸ ì™„ë£Œ")
            
            # WITH ì ˆì´ ìˆëŠ”ì§€ í™•ì¸
            if re.search(r'\bWITH\s+', sql_text, re.IGNORECASE | re.DOTALL):
                # WITH ì ˆ ì „ì²´ë¥¼ ì œê±°í•˜ê³  ë§ˆì§€ë§‰ SELECTë§Œ ë‚¨ê¹€
                # ë³µì¡í•œ íŒ¨í„´ ë§¤ì¹­ ëŒ€ì‹  ë‹¨ìˆœí•˜ê²Œ ì²˜ë¦¬
                lines = sql_text.split('\n')
                in_with_section = False
                main_select_found = False
                result_lines = []
                
                for line in lines:
                    line_upper = line.strip().upper()
                    
                    # WITH ì ˆ ì‹œì‘ ê°ì§€
                    if line_upper.startswith('WITH ') or (in_with_section and ',' in line and 'AS (' in line.upper()):
                        in_with_section = True
                        continue
                    
                    # CTE ì •ì˜ ë¶€ë¶„ ìŠ¤í‚µ
                    if in_with_section and not line_upper.startswith('SELECT '):
                        continue
                    
                    # ë©”ì¸ SELECT ë°œê²¬
                    if in_with_section and line_upper.startswith('SELECT '):
                        in_with_section = False
                        main_select_found = True
                    
                    # WITH ì ˆì´ ì—†ê±°ë‚˜ ë©”ì¸ SELECT ì´í›„ì˜ ë¼ì¸ë“¤ ìœ ì§€
                    if not in_with_section:
                        result_lines.append(line)
                
                return '\n'.join(result_lines)
            
            return sql_text
        
        sql = remove_with_clause(sql)
        
        if self.debug:
            print(f"ğŸ”§ WITH ì ˆ ì œê±° í›„: {len(sql)} ë¬¸ì")
            print(f"ì²˜ë¦¬ëœ SQL ì‹œì‘: {sql[:200]}...")
            print()

        # 0-1. ì •í™•í•œ ì„œë¸Œì¿¼ë¦¬ ì²˜ë¦¬ - ê´„í˜¸ ë§¤ì¹­ì„ ê³ ë ¤í•œ ì²˜ë¦¬
        
        # 0-1. íŒŒì„œ ê¸°ë°˜ ì„œë¸Œì¿¼ë¦¬ ì²˜ë¦¬ - ì¤‘ì²© ë ˆë²¨ 1ë‹¨ê³„ ì²˜ë¦¬
        
        def replace_subqueries_with_parser(sql_text):
            """íŒŒì„œë¥¼ ì´ìš©í•œ ì„œë¸Œì¿¼ë¦¬ ì¹˜í™˜ - 1ë ˆë²¨ ì¤‘ì²©ë§Œ ì²˜ë¦¬"""
            try:
                import sqlparse
                from sqlparse.sql import Parenthesis, Statement
                from sqlparse.tokens import Keyword, Name
                
                # SQL íŒŒì‹±
                parsed = sqlparse.parse(sql_text)
                if not parsed:
                    return sql_text
                
                def process_tokens_for_subquery(tokens):
                    """í† í° ë¦¬ìŠ¤íŠ¸ë¥¼ ì²˜ë¦¬í•˜ì—¬ ì„œë¸Œì¿¼ë¦¬ë¥¼ (SELECT 1)ë¡œ ë³€í™˜"""
                    result_tokens = []
                    
                    for token in tokens:
                        if isinstance(token, Parenthesis):
                            inner_text = str(token).strip()
                            # (SELECT ... FROM ... WHERE ...) íŒ¨í„´ ê°ì§€
                            if (inner_text.upper().startswith('(SELECT') or 
                                inner_text.upper().startswith('( SELECT')):
                                # FROMì´ í¬í•¨ëœ ì„œë¸Œì¿¼ë¦¬ë§Œ ë³€í™˜ (ë‹¨ìˆœ í•¨ìˆ˜ í˜¸ì¶œ ì œì™¸)
                                if ' FROM ' in inner_text.upper():
                                    # ìƒˆë¡œìš´ Parenthesis í† í° ìƒì„±
                                    new_token = sqlparse.sql.Parenthesis([
                                        sqlparse.sql.Token(sqlparse.tokens.Punctuation, '('),
                                        sqlparse.sql.Token(sqlparse.tokens.Keyword, 'SELECT'),
                                        sqlparse.sql.Token(sqlparse.tokens.Whitespace, ' '),
                                        sqlparse.sql.Token(sqlparse.tokens.Number.Integer, '1'),
                                        sqlparse.sql.Token(sqlparse.tokens.Punctuation, ')')
                                    ])
                                    result_tokens.append(new_token)
                                    continue
                        
                        # í•˜ìœ„ í† í°ì´ ìˆëŠ” ê²½ìš° ì¬ê·€ ì²˜ë¦¬
                        if hasattr(token, 'tokens') and token.tokens:
                            processed_subtokens = process_tokens_for_subquery(token.tokens)
                            # ì›ë³¸ í† í° íƒ€ì…ì„ ìœ ì§€í•˜ë©´ì„œ í•˜ìœ„ í† í°ë§Œ êµì²´
                            if hasattr(token, '__class__'):
                                new_token = token.__class__(processed_subtokens)
                                result_tokens.append(new_token)
                            else:
                                result_tokens.append(token)
                        else:
                            result_tokens.append(token)
                    
                    return result_tokens
                
                # ê° statement ì²˜ë¦¬
                result_statements = []
                for statement in parsed:
                    if hasattr(statement, 'tokens') and statement.tokens:
                        processed_tokens = process_tokens_for_subquery(statement.tokens)
                        # Statement ì¬êµ¬ì„±
                        new_statement = sqlparse.sql.Statement(processed_tokens)
                        result_statements.append(str(new_statement))
                    else:
                        result_statements.append(str(statement))
                
                return ' '.join(result_statements)
                
            except Exception as e:
                if self.debug:
                    print(f"ğŸ”§ íŒŒì„œ ê¸°ë°˜ ì„œë¸Œì¿¼ë¦¬ ì²˜ë¦¬ ì‹¤íŒ¨, ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©: {e}")
                # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ fallback
                result = sql_text
                changed = True
                iteration = 0
                
                while changed and iteration < 10:
                    changed = False
                    i = 0
                    while i < len(result):
                        # ( SELECT íŒ¨í„´ ì°¾ê¸°
                        if result[i:i+1] == '(' and result[i:i+8].upper().startswith('( SELECT'):
                            # ê´„í˜¸ ê· í˜• ì°¾ê¸°
                            paren_count = 0
                            start_pos = i
                            
                            for j in range(i, len(result)):
                                if result[j] == '(':
                                    paren_count += 1
                                elif result[j] == ')':
                                    paren_count -= 1
                                    if paren_count == 0:
                                        # ì™„ì „í•œ ì„œë¸Œì¿¼ë¦¬ ë°œê²¬
                                        subquery = result[start_pos:j+1]
                                        if 'SELECT' in subquery.upper():
                                            result = result[:start_pos] + '(SELECT 1)' + result[j+1:]
                                            changed = True
                                            break
                            if changed:
                                break
                        i += 1
                    iteration += 1
                
                return result
        
        sql = replace_subqueries_with_parser(sql)
        
        if self.debug:
            print(f"ğŸ”§ íŒŒì„œ ê¸°ë°˜ ì„œë¸Œì¿¼ë¦¬ ì²˜ë¦¬ ì™„ë£Œ")
            print()

        # 0. ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸
        string_literals = []
        def protect_string(match):
            string_literals.append(match.group(0))
            return f"__STRING_LITERAL_{len(string_literals)-1}__"
        
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ì„ ì„ì‹œ í† í°ìœ¼ë¡œ ì¹˜í™˜
        sql = re.sub(r"'[^']*'", protect_string, sql)
        
        if self.debug:
            print(f"ğŸ”§ ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸ í›„: {len(string_literals)}ê°œ ë³´í˜¸ë¨")
            for i, literal in enumerate(string_literals):
                print(f"  {i}: {literal}")
            print(f"ë³´í˜¸ëœ SQL: {sql[:200]}...")
            print()
        
        # MyBatis ë°”ì¸ë“œ ë³€ìˆ˜ ì¹˜í™˜
        sql = re.sub(r'#\{[^}]*\}', '1', sql)
        sql = re.sub(r'\$\{[^}]*\}', '1', sql)
        
        if self.debug:
            print(f"ğŸ”§ ë°”ì¸ë“œ ë³€ìˆ˜ ì¹˜í™˜ ì™„ë£Œ")
        
        
        # 0-2. TRIM í•¨ìˆ˜ ë³´í˜¸ (ë°”ì¸ë“œ ë³€ìˆ˜ ë° í…Œì´ë¸”.ì»¬ëŸ¼ëª… ì¹˜í™˜ í›„)
        # TRIM í•¨ìˆ˜ ë³´í˜¸ë¥¼ ì»¬ëŸ¼ ì¹˜í™˜ ì´í›„ë¡œ ì´ë™í•˜ì—¬ ë‚´ë¶€ ì»¬ëŸ¼ë„ ì¹˜í™˜ë˜ë„ë¡ í•¨
        trim_placeholders = {}
        
        if self.debug:
            print(f"ğŸ”§ TRIM í•¨ìˆ˜ ë³´í˜¸ë¥¼ ì»¬ëŸ¼ ì¹˜í™˜ ì´í›„ë¡œ ì—°ê¸°")
        
        # 0.5. AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´ ìˆ˜ì • (ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸ í›„)
        sql = self.fix_missing_and_operators(sql)
        
        # 0.6. ë³µì¡í•œ ì¤‘ì²© CASE ë¬¸ ë‹¨ìˆœí™”
        # íŠ¹ì • ë¬¸ì œ íŒ¨í„´ë“¤ì„ ì§ì ‘ ìˆ˜ì •
        sql = re.sub(r'THEN\s+IFNULL\s*\([^)]+\)\s+(\d+)\s+END', r'THEN 1 ELSE 1 END', sql, flags=re.IGNORECASE)
        
        # 3ì¤‘ ì´ìƒ ì¤‘ì²©ëœ CASE ë¬¸ì„ ë‹¨ìˆœí•œ IFNULL(1,0)ìœ¼ë¡œ ì¹˜í™˜
        if sql.count('CASE WHEN') >= 3:
            # ë³µì¡í•œ ì¤‘ì²© CASE ë¬¸ì„ ì°¾ì•„ì„œ ë‹¨ìˆœí™”
            complex_case_pattern = r'IFNULL\s*\(\s*\(\s*CASE\s+WHEN.*?END\s*\)\s*,\s*0\s*\)'
            if re.search(complex_case_pattern, sql, re.IGNORECASE | re.DOTALL):
                if self.debug:
                    print(f"ğŸ” ë³µì¡í•œ ì¤‘ì²© CASE ë¬¸ ë°œê²¬, ë‹¨ìˆœí™” ì²˜ë¦¬")
                sql = re.sub(complex_case_pattern, 'IFNULL(1,0)', sql, flags=re.IGNORECASE | re.DOTALL)
        
        # 1. AS 1, AS 2, AS 3 ë“±ì˜ íŒ¨í„´ì„ ì œê±° (ìˆ«ìë§Œ ìˆëŠ” ë³„ì¹­)
        sql = re.sub(r'(\w+)\s*AS\s+\d+(?=\s*[,)$])', r'\1', sql, flags=re.IGNORECASE)
        sql = re.sub(r'\s*AS\s*\d+(?=\s*[,)$])', '', sql, flags=re.IGNORECASE)
        sql = re.sub(r'AS\s*\d+(?=\s*[,)$])', '', sql, flags=re.IGNORECASE)
        # ë¬¸ì¥ ëì˜ AS ìˆ«ì íŒ¨í„´ë„ ì œê±°
        sql = re.sub(r'\s*AS\s+\d+\s*$', '', sql, flags=re.IGNORECASE)
        
        # 2. Window Function ë‚´ë¶€ì˜ PARTITION BY 1 ORDER BY 1 íŒ¨í„´ ìˆ˜ì •
        # ê´„í˜¸ ë§¤ì¹­ì„ ê³ ë ¤í•œ ì •í™•í•œ OVER ì ˆ ì²˜ë¦¬
        def replace_over_with_partition(sql_text):
            """OVER ì ˆì—ì„œ PARTITION BY 1ì´ í¬í•¨ëœ ë¶€ë¶„ì„ ì°¾ì•„ ë‹¨ìˆœí™”"""
            result = sql_text
            start_pos = 0
            
            while True:
                # OVER ( íŒ¨í„´ ì°¾ê¸°
                over_match = re.search(r'OVER\s*\(', result[start_pos:], re.IGNORECASE)
                if not over_match:
                    break
                
                over_start = start_pos + over_match.start()
                paren_start = start_pos + over_match.end() - 1  # '(' ìœ„ì¹˜
                
                # ê´„í˜¸ ë§¤ì¹­ìœ¼ë¡œ OVER ì ˆì˜ ë ì°¾ê¸°
                paren_count = 1
                pos = paren_start + 1
                while pos < len(result) and paren_count > 0:
                    if result[pos] == '(':
                        paren_count += 1
                    elif result[pos] == ')':
                        paren_count -= 1
                    pos += 1
                
                if paren_count == 0:
                    # OVER ì ˆ ì „ì²´ ì¶”ì¶œ
                    over_clause = result[over_start:pos]
                    
                    # PARTITION BY 1 ë˜ëŠ” ORDER BY 1ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ë‹¨ìˆœí™”
                    if re.search(r'(PARTITION\s+BY\s+1|ORDER\s+BY\s+1)', over_clause, re.IGNORECASE):
                        result = result[:over_start] + 'OVER ()' + result[pos:]
                        start_pos = over_start + len('OVER ()')
                    else:
                        start_pos = pos
                else:
                    break
            
            return result
        
        sql = replace_over_with_partition(sql)
        
        # 3. ìœˆë„ìš° í•¨ìˆ˜ ë‚´ë¶€ì˜ ORDER BY ì»¬ëŸ¼ëª… ì¹˜í™˜
        # MySQL ìœˆë„ìš° í•¨ìˆ˜ì—ì„œëŠ” ORDER BY ìœ„ì¹˜ ì§€ì •ì„ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ OVER()ë¡œ ë‹¨ìˆœí™”
        sql = re.sub(r'OVER\s*\(\s*ORDER\s+BY\s+[A-Za-z_][A-Za-z0-9_]*\s*\)', 'OVER ()', sql, flags=re.IGNORECASE)
        sql = re.sub(r'OVER\s*\(\s*PARTITION\s+BY\s+[^)]+\s+ORDER\s+BY\s+[A-Za-z_][A-Za-z0-9_]*\s*\)', 'OVER ()', sql, flags=re.IGNORECASE)
        
        # 4. ì¼ë°˜ì ì¸ ORDER BY ì²˜ë¦¬ (Window Function ë°–ì—ì„œ)
        # ë¬¸ì¥ ëì´ë‚˜ GROUP BY, HAVING, LIMIT ì•ì˜ ORDER BYë§Œ ì²˜ë¦¬
        sql = re.sub(r'\bORDER\s+BY\s+\d+(?:\s*,\s*\d+)*(?=\s*(?:$|GROUP\s+BY|HAVING|LIMIT|;))', 'ORDER BY (SELECT NULL)', sql, flags=re.IGNORECASE)
        sql = re.sub(r'\bORDER\s+BY\s+[A-Za-z_][A-Za-z0-9_]*(?:\s*,\s*[A-Za-z_][A-Za-z0-9_]*)*(?=\s*(?:$|GROUP\s+BY|HAVING|LIMIT|;))', 'ORDER BY (SELECT NULL)', sql, flags=re.IGNORECASE)
        
        # 4. ë¹ˆ THEN ì ˆ ì²˜ë¦¬ (MyBatis ì¡°ê±´ë¬¸ìœ¼ë¡œ ì¸í•œ ë¹ˆ THEN ì ˆ)
        # CASE WHEN ... THEN [ê³µë°±/íƒ­/ì¤„ë°”ê¿ˆë§Œ] ELSE ... END íŒ¨í„´ì„ ì°¾ì•„ì„œ ìˆ˜ì •
        # ë” ì •í™•í•œ íŒ¨í„´ìœ¼ë¡œ ìˆ˜ì •
        sql = re.sub(r'THEN\s*\n?\s*\t*\s*\n?\s*\t*\s*ELSE', 'THEN NULL ELSE', sql, flags=re.IGNORECASE | re.MULTILINE)
        
        # 5. CAST í•¨ìˆ˜ íŒ¨í„´ ìˆ˜ì • - ì´ë¯¸ 777ë¼ì¸ì—ì„œ ì²˜ë¦¬ë˜ì—ˆìœ¼ë¯€ë¡œ ì¤‘ë³µ ì²˜ë¦¬ ë¹„í™œì„±í™”
        # sql = self.process_cast_functions_with_parser(sql)
        
        # 5. í…Œì´ë¸”ë³„ì¹­.ê³µë°±ì»¬ëŸ¼ íŒ¨í„´ ìˆ˜ì • (ì˜ˆ: B. 1 â†’ B.column, A. 2 â†’ A.column)
        sql = re.sub(r'\b([A-Za-z_][A-Za-z0-9_]*)\.\s+(\d+)', r'\1.column\2', sql)
        
        # 6. ë¹ˆ IFNULL íŒŒë¼ë¯¸í„° ì²˜ë¦¬ (MyBatis ì¡°ê±´ë¬¸ìœ¼ë¡œ ì¸í•œ í•¨ìˆ˜ ë¶„í•  ì˜ˆì™¸ ì²˜ë¦¬)
        # IFNULL(,0) â†’ IFNULL(1,0), IFNULL( \n\t ,0) â†’ IFNULL(1,0)
        sql = re.sub(r'IFNULL\s*\(\s*,', 'IFNULL(1,', sql, flags=re.IGNORECASE)
        sql = re.sub(r'IFNULL\s*\(\s*\n\s*\t*\s*\n\s*\t*\s*,', 'IFNULL(1,', sql, flags=re.IGNORECASE | re.MULTILINE)
        
        # 7. XML ì£¼ì„ ì œê±° (<!-- ... -->)
        sql = re.sub(r'<!--.*?-->', '', sql, flags=re.DOTALL)
        
        # 8. SQL ì£¼ì„ ì œê±° (-- ì£¼ì„) - ì£¼ì„ ì œê±° í›„ ê³µë°± ì •ë¦¬
        sql = re.sub(r'--[^\r\n]*', ' ', sql)
        sql = re.sub(r'\s+', ' ', sql)  # ì—°ì†ëœ ê³µë°±ì„ í•˜ë‚˜ë¡œ ì •ë¦¬
        
        # 9. EXISTS 1 â†’ EXISTS (SELECT 1) íŒ¨í„´ ìˆ˜ì •
        sql = re.sub(r'\bEXISTS\s+(\d+)', r'EXISTS (SELECT \1)', sql, flags=re.IGNORECASE)
        
        # 10. SUBSTRING position from ë¬¸ë²•ì„ MySQL ë¬¸ë²•ìœ¼ë¡œ ë³€ê²½
        # SUBSTRING(str position from pos for len) â†’ SUBSTRING(str, pos, len)
        sql = re.sub(r'\bSUBSTRING\s*\(\s*([^)]+?)\s+position\s+from\s+([^)]+?)\s+([^)]+?)\s*\)', 
                    r'SUBSTRING(\1, \2, \3)', sql, flags=re.IGNORECASE)
        
        # 11. ì˜ëª»ëœ SUBSTRING íŒ¨í„´ ìˆ˜ì • (SUBSTRING (1 position from 0 1 1))
        sql = re.sub(r'\bSUBSTRING\s*\(\s*(\d+)\s+position\s+from\s+(\d+)\s+(\d+)\s+(\d+)\s*\)', 
                    r'SUBSTRING(\1, \2, \3)', sql, flags=re.IGNORECASE)
        
        # 12. ì†Œìˆ˜ì  íŒ¨í„´ ìˆ˜ì • (IFNULL(1. 1,0) â†’ IFNULL(1.1,0))
        sql = re.sub(r'(\d+)\.\s+(\d+)', r'\1.\2', sql)
        
        # 13. ì—°ì‚°ì ì£¼ë³€ ê³µë°± ì •ë¦¬
        sql = re.sub(r'\s*\.\s*', '.', sql)  # ì  ì—°ì‚°ì ì£¼ë³€ ê³µë°± ì œê±°
        
        # 14. ìŠ¤í‚¤ë§ˆ/í…Œì´ë¸”ë³„ì¹­ ì œê±° - ì£¼ì„ ì²˜ë¦¬ (ì„œë¸Œì¿¼ë¦¬ ë³´í˜¸ ì´í›„ì— ì²˜ë¦¬í•˜ë„ë¡ ë³€ê²½)
        # ì´ ë¡œì§ì€ ì„œë¸Œì¿¼ë¦¬ ë‚´ë¶€ì˜ SELECT ë¬¸ì„ ì†ìƒì‹œí‚¤ë¯€ë¡œ ë¹„í™œì„±í™”
        # ëŒ€ì‹  ë¼ì¸ 1270 ì´í›„ì˜ ê°œì„ ëœ ì»¬ëŸ¼ êµì²´ ë¡œì§ì„ ì‚¬ìš©
        
        # # GROUPING í•¨ìˆ˜ ë‚´ë¶€ë¥¼ ì„ì‹œë¡œ ë³´í˜¸
        # grouping_patterns = []
        # def protect_grouping(match):
        #     grouping_patterns.append(match.group(1))  # ê´„í˜¸ ì•ˆì˜ ë‚´ìš© ì €ì¥
        #     return f"GROUPING(__GROUPING_PARAM_{len(grouping_patterns)-1}__)"
        # 
        # sql = re.sub(r'GROUPING\s*\(([^)]+)\)', protect_grouping, sql, flags=re.IGNORECASE)
        # 
        # # ì¼ë°˜ì ì¸ ìŠ¤í‚¤ë§ˆ/í…Œì´ë¸”ë³„ì¹­ ì œê±°
        # sql = re.sub(r'\b[A-Za-z_][A-Za-z0-9_]*\.[A-Za-z_][A-Za-z0-9_]*', '1', sql)
        # sql = re.sub(r'\b[A-Za-z_][A-Za-z0-9_]*\.', '', sql)
        # 
        # # GROUPING í•¨ìˆ˜ ë³µì› (íŒŒë¼ë¯¸í„°ëŠ” NULLë¡œ ë³€ê²½)
        # for i, original_param in enumerate(grouping_patterns):
        #     sql = sql.replace(f"GROUPING(__GROUPING_PARAM_{i}__)", "GROUPING(NULL)")
        
        # 15. ë‹¨ìˆœ ì»¬ëŸ¼ëª… ì¹˜í™˜ - ì£¼ì„ ì²˜ë¦¬ (ì„œë¸Œì¿¼ë¦¬ ë³´í˜¸ ì´í›„ì— ì²˜ë¦¬í•˜ë„ë¡ ë³€ê²½)
        # ì´ ë¡œì§ë„ ì„œë¸Œì¿¼ë¦¬ ë‚´ë¶€ì˜ ì‹ë³„ìë¥¼ ì†ìƒì‹œí‚¤ë¯€ë¡œ ë¹„í™œì„±í™”
        
        # # í•¨ìˆ˜ ë‚´ë¶€ì˜ ì»¬ëŸ¼ëª…ì„ 1ë¡œ ì¹˜í™˜ (ì˜ˆ: SUM(SALE_DSCNT_AMT) â†’ SUM(1))
        # # ë‹¨, í•¨ìˆ˜ëª… ìì²´ëŠ” ë³´í˜¸
        # def replace_column_in_function(match):
        #     func_name = match.group(1)
        #     params = match.group(2)
        #     # íŒŒë¼ë¯¸í„° ë‚´ì˜ ì»¬ëŸ¼ëª…ì„ 1ë¡œ ì¹˜í™˜
        #     # ìˆ«ì, ë¬¸ìì—´ ë¦¬í„°ëŸ´, NULLì€ ë³´í˜¸
        #     params_replaced = re.sub(r'\b(?!NULL\b|__STRING_LITERAL_\d+__\b)\d*[A-Za-z_][A-Za-z0-9_]*\b(?!\s*\()', '1', params, flags=re.IGNORECASE)
        #     return f"{func_name}({params_replaced})"
        # 
        # # ëª¨ë“  í•¨ìˆ˜ ë‚´ë¶€ì˜ ì»¬ëŸ¼ëª… ì¹˜í™˜
        # for func in self.all_functions:
        #     pattern = rf'\b({func})\s*\(([^)]+)\)'
        #     sql = re.sub(pattern, replace_column_in_function, sql, flags=re.IGNORECASE)
        
        
        # 16. ì‹¬í”Œí•œ ì»¬ëŸ¼ êµì²´ - í•¨ìˆ˜ ë‚´ë¶€ ì»¬ëŸ¼ëª…ë„ ì²˜ë¦¬
        
        if self.debug:
            print(f"ğŸ”§ ì‹¬í”Œí•œ ì»¬ëŸ¼ êµì²´ ì‹œì‘")
        
        # 1ë‹¨ê³„: ì—°ì‚°ì ë³´í˜¸ (ì»¬ëŸ¼ êµì²´ ì „ì— ë¨¼ì € ë³´í˜¸)
        operator_protections = []
        
        # ë¹„êµ ì—°ì‚°ì ë³´í˜¸ (ê³µë°± í¬í•¨)
        comparison_operators = [r'>=', r'<=', r'<>', r'!=', r'>', r'<', r'=']
        for i, op in enumerate(comparison_operators):
            pattern = rf'(\s*{re.escape(op)}\s*)'
            matches = list(re.finditer(pattern, sql))
            for j, match in enumerate(reversed(matches)):
                placeholder = f'__COMP_OP_{i}_{len(matches)-1-j}__'
                operator_protections.append((placeholder, match.group()))
                sql = sql[:match.start()] + placeholder + sql[match.end():]
        
        # 2ë‹¨ê³„: í…Œì´ë¸”.ì»¬ëŸ¼ â†’ 1 (ê³µë°±ì´ ìˆëŠ” íŒ¨í„´ë„ ì²˜ë¦¬)
        # í…Œì´ë¸”ë³„ì¹­. ì»¬ëŸ¼ëª… íŒ¨í„´ (ê³µë°± í¬í•¨) ì²˜ë¦¬
        sql = re.sub(r'\b[A-Za-z][A-Za-z0-9_]*\.\s+[A-Za-z0-9_]+\b', '1', sql, flags=re.IGNORECASE)
        # ì¼ë°˜ì ì¸ í…Œì´ë¸”.ì»¬ëŸ¼ íŒ¨í„´
        sql = re.sub(r'\b[A-Za-z][A-Za-z0-9_]*\.[A-Za-z0-9_]+\b', '1', sql, flags=re.IGNORECASE)
        
        # 3ë‹¨ê³„: ë‹¨ë… ì»¬ëŸ¼ëª… â†’ 1 (ì˜ˆì•½ì–´, í•¨ìˆ˜ëª… ì œì™¸) - ê°œì„ ëœ ìˆœì°¨ ì²˜ë¦¬
        # ë™ì ìœ¼ë¡œ í™•ì¥ëœ í•¨ìˆ˜ëª…ê³¼ ì˜ˆì•½ì–´ë¥¼ ëª¨ë‘ ë³´í˜¸
        protected_words = set()
        protected_words.update(self.mysql_reserved_words)
        protected_words.update(self.all_functions)
        
        if self.debug:
            print(f"ğŸ” ì»¬ëŸ¼ êµì²´ ì „ SQL ìƒ˜í”Œ: {sql[-200:]}")
        
        # ì˜ˆì•½ì–´ê°€ ì•„ë‹Œ ì‹ë³„ìë¥¼ 1ë¡œ êµì²´ - ê°œì„ ëœ ë¡œì§
        # ì—¬ëŸ¬ ë²ˆ ë°˜ë³µí•˜ì—¬ ëª¨ë“  ì»¬ëŸ¼ëª…ì´ í™•ì‹¤íˆ ì¹˜í™˜ë˜ë„ë¡ í•¨
        max_iterations = 10  # ë°˜ë³µ íšŸìˆ˜ ì¦ê°€
        for iteration in range(max_iterations):
            original_sql = sql
            
            # ë” í¬ê´„ì ì¸ íŒ¨í„´ìœ¼ë¡œ ë‹¨ì–´ ì°¾ê¸° (ì–¸ë”ìŠ¤ì½”ì–´ë¡œ ì‹œì‘í•˜ëŠ” ê²ƒë„ í¬í•¨)
            words_found = re.findall(r'\b[A-Za-z_][A-Za-z0-9_]*\b', sql)
            replaced_count = 0
            
            if self.debug and iteration == 0:
                print(f"ğŸ” ë°œê²¬ëœ ëª¨ë“  ë‹¨ì–´: {sorted(set(words_found))}")
            
            for word in set(words_found):  # ì¤‘ë³µ ì œê±°
                word_upper = word.upper()
                
                # ì¹˜í™˜ ì¡°ê±´ í™•ì¸ - ë” ëª…í™•í•œ ë¡œì§
                should_replace = (
                    word_upper not in protected_words and 
                    not word.startswith('__STRING_LITERAL_') and 
                    not word.startswith('__COMP_OP_') and
                    word != '1' and  # ì´ë¯¸ ì¹˜í™˜ëœ ê²ƒì€ ì œì™¸
                    len(word) > 1  # í•œ ê¸€ì ë‹¨ì–´ëŠ” ì œì™¸
                )
                
                if should_replace:
                    # í•¨ìˆ˜ í˜¸ì¶œì´ ì•„ë‹Œ ê²½ìš°ë§Œ ì¹˜í™˜ (í•¨ìˆ˜ëª… ë³´í˜¸)
                    pattern = r'\b' + re.escape(word) + r'\b(?!\s*\()'
                    matches = re.findall(pattern, sql, re.IGNORECASE)
                    
                    if matches:
                        sql = re.sub(pattern, '1', sql, flags=re.IGNORECASE)
                        replaced_count += len(matches)
                        if self.debug:
                            print(f"ğŸ”„ ë°˜ë³µ {iteration+1}: '{word}' â†’ '1' ({len(matches)}ê°œ ì¹˜í™˜)")
            
            # ë³€í™”ê°€ ì—†ìœ¼ë©´ ì¢…ë£Œ
            if sql == original_sql:
                if self.debug:
                    print(f"âœ… ì»¬ëŸ¼ êµì²´ ì™„ë£Œ (ë°˜ë³µ {iteration+1}íšŒ)")
                break
        
        if self.debug:
            print(f"ğŸ” ì»¬ëŸ¼ êµì²´ í›„ SQL ìƒ˜í”Œ: {sql[-200:]}")
        
        # 4ë‹¨ê³„: ì—°ì‚°ì ë³µì›
        for placeholder, original in operator_protections:
            sql = sql.replace(placeholder, original)
        
        # 5ë‹¨ê³„: ì—°ì‚°ì ë³µì› í›„ ì¶”ê°€ ì»¬ëŸ¼ êµì²´ (ì—°ì‚°ì ë³µì›ìœ¼ë¡œ ë…¸ì¶œëœ ì»¬ëŸ¼ëª… ì²˜ë¦¬)
        if self.debug:
            print(f"ğŸ”§ ì—°ì‚°ì ë³µì› í›„ ì¶”ê°€ ì»¬ëŸ¼ êµì²´ ì‹œì‘")
        
        # ì—°ì‚°ì ë³µì› í›„ ë‹¤ì‹œ í•œ ë²ˆ ì»¬ëŸ¼ëª… ê²€ì‚¬ ë° ì¹˜í™˜
        words_found = re.findall(r'\b[A-Za-z][A-Za-z0-9_]*\b', sql)
        for word in set(words_found):
            if (word.upper() not in protected_words and 
                not word.startswith('__STRING_LITERAL_') and 
                word != '1'):
                pattern = r'\b' + re.escape(word) + r'\b'
                if re.search(pattern, sql, re.IGNORECASE):
                    sql = re.sub(pattern, '1', sql, flags=re.IGNORECASE)
                    if self.debug:
                        print(f"ğŸ”„ ì¶”ê°€ ì¹˜í™˜: '{word}' â†’ '1'")
        
        if self.debug:
            print(f"ğŸ”§ ì—°ì‚°ì ë³µì› í›„ ì¶”ê°€ ì»¬ëŸ¼ êµì²´ ì™„ë£Œ")
        
        if self.debug:
            print(f"ğŸ”§ ì‹¬í”Œí•œ ì»¬ëŸ¼ êµì²´ ì™„ë£Œ")
            print(f"ê²°ê³¼: {sql[:200]}...")
            print()
        
        # ì»¬ëŸ¼ ì¹˜í™˜ ì™„ë£Œ í›„ TRIM í•¨ìˆ˜ ë³´í˜¸
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ í”Œë ˆì´ìŠ¤í™€ë”ë¥¼ ê³ ë ¤í•œ íŒ¨í„´
        trim_pattern = r'TRIM\s*\(\s*(LEADING|TRAILING|BOTH)\s+(__STRING_LITERAL_\d+__)\s+FROM\s+([^)]+?)\s*\)'
        trim_matches = list(re.finditer(trim_pattern, sql, flags=re.IGNORECASE | re.DOTALL))
        for i, match in enumerate(trim_matches):
            placeholder = f'__TRIM_FUNCTION_{i}__'
            trim_placeholders[placeholder] = match.group(0)
            sql = sql.replace(match.group(0), placeholder, 1)
        
        if self.debug and trim_placeholders:
            print(f"ğŸ”§ TRIM í•¨ìˆ˜ ë³´í˜¸: {len(trim_placeholders)}ê°œ")
            for placeholder, original in trim_placeholders.items():
                print(f"  {placeholder}: {original[:100]}...")
        
        sql = re.sub(r'CAST\(([^)]+)\)\*(\d+)', r'(CAST(\1))*\2', sql, flags=re.IGNORECASE)
        
        # 15. ì˜ëª»ëœ ì—°ì‚°ì íŒ¨í„´ ìˆ˜ì •
        # 1. 1 â†’ 1.1 (ì†Œìˆ˜ì  í‘œê¸°)
        sql = re.sub(r'(\d+)\.\s+(\d+)', r'\1.\2', sql)
        
        # 16. ë¹ˆ ê´„í˜¸ë‚˜ ì˜ëª»ëœ ê´„í˜¸ íŒ¨í„´ ìˆ˜ì • (RANK() í•¨ìˆ˜ëŠ” ì œì™¸)
        # RANK(), ROW_NUMBER(), DENSE_RANK() ë“± ìœˆë„ìš° í•¨ìˆ˜ëŠ” ë³´í˜¸
        window_functions = ['RANK', 'ROW_NUMBER', 'DENSE_RANK', 'LEAD', 'LAG', 'FIRST_VALUE', 'LAST_VALUE']
        protected_patterns = []
        
        # ìœˆë„ìš° í•¨ìˆ˜ë“¤ì„ ì„ì‹œë¡œ ë³´í˜¸ (ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ì¸ë±ìŠ¤ ë³€ê²½ ë¬¸ì œ ë°©ì§€)
        for func in window_functions:
            pattern = rf'\b{func}\s*\(\s*\)'
            matches = list(re.finditer(pattern, sql, re.IGNORECASE))
            # ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ì¸ë±ìŠ¤ ë³€ê²½ ë¬¸ì œ ë°©ì§€
            for i, match in enumerate(reversed(matches)):
                placeholder = f'__WINDOW_FUNC_{func}_{len(matches)-1-i}__'
                protected_patterns.append((placeholder, match.group()))
                sql = sql[:match.start()] + placeholder + sql[match.end():]
        
        # í•¨ìˆ˜ëª…ì´ ì—†ëŠ” ë¹ˆ ê´„í˜¸ë§Œ ì²˜ë¦¬ (í•¨ìˆ˜ëª… ë’¤ì˜ ë¹ˆ ê´„í˜¸ëŠ” ë³´í˜¸)
        # ëª¨ë“  í•¨ìˆ˜ëª… ë’¤ì˜ ë¹ˆ ê´„í˜¸ë¥¼ ì„ì‹œë¡œ ë³´í˜¸
        function_empty_parens = []
        temp_sql = sql
        
        for func in self.all_functions:
            pattern = rf'\b{func}\s*\(\s*\)'
            matches = list(re.finditer(pattern, temp_sql, re.IGNORECASE))
            # ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ì¸ë±ìŠ¤ ë³€ê²½ ë¬¸ì œ ë°©ì§€
            for i, match in enumerate(reversed(matches)):
                placeholder = f'__FUNC_EMPTY_{func}_{len(matches)-1-i}__'
                function_empty_parens.append((placeholder, match.group()))
                temp_sql = temp_sql[:match.start()] + placeholder + temp_sql[match.end():]
        
        # ì´ì œ ë‚¨ì€ ë¹ˆ ê´„í˜¸ë§Œ ì²˜ë¦¬ (OVER() ë° OVER ( ) ì ˆì€ ì œì™¸)
        # OVER() ì ˆì€ MySQLì—ì„œ ìœ íš¨í•œ ë¬¸ë²•ì´ë¯€ë¡œ ë³€í™˜í•˜ì§€ ì•ŠìŒ
        # OVER ë’¤ì— ê³µë°±ì´ ìˆì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ ì´ë¥¼ ê³ ë ¤
        temp_sql = re.sub(r'(?<!OVER)(?<!\bOVER\s)\s*\(\s*\)', '(SELECT NULL)', temp_sql, flags=re.IGNORECASE)
        
        # í•¨ìˆ˜ëª… ë’¤ì˜ ë¹ˆ ê´„í˜¸ ë³µì›
        for placeholder, original in function_empty_parens:
            temp_sql = temp_sql.replace(placeholder, original)
        
        sql = temp_sql
        
        # ë³´í˜¸ëœ ìœˆë„ìš° í•¨ìˆ˜ë“¤ ë³µì›
        for placeholder, original in protected_patterns:
            sql = sql.replace(placeholder, original)
        
        # 17. SQL íŒ¨í„´ ìˆ˜ì • (ì‹¤í–‰ ì „ ë§ˆì§€ë§‰ ë‹¨ê³„)
        sql = self.fix_sql_patterns_before_execution(sql)
        
        # 18. ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³µì›
        for i, literal in enumerate(string_literals):
            sql = sql.replace(f"__STRING_LITERAL_{i}__", literal)
        
        # 18-1. TRIM í•¨ìˆ˜ ë³µì› (ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³µì› í›„)
        for placeholder, original in trim_placeholders.items():
            # TRIM í•¨ìˆ˜ ë‚´ì˜ ë¬¸ìì—´ ë¦¬í„°ëŸ´ë„ ë³µì›
            restored_trim = original
            for i, literal in enumerate(string_literals):
                restored_trim = restored_trim.replace(f"__STRING_LITERAL_{i}__", literal)
            sql = sql.replace(placeholder, restored_trim)
        
        if self.debug and trim_placeholders:
            print(f"ğŸ”§ TRIM í•¨ìˆ˜ ë³µì›: {len(trim_placeholders)}ê°œ")
        
        # CASE WHEN ì˜¤ë¥˜ ìˆ˜ì •: ELSE END â†’ ELSE 1 END íŒ¨í„´ êµì²´
        # ì¤‘ê°„ì— ë¹ˆì¹¸ì´ë‚˜ ì¤„ë°”ê¿ˆì´ ìˆì„ ìˆ˜ ìˆìŒì„ ê³ ë ¤
        else_end_pattern = r'ELSE\s*\n?\s*\t*\s*END'
        else_1_end_replacement = r'ELSE 1 END'
        
        if re.search(else_end_pattern, sql, re.IGNORECASE | re.MULTILINE):
            sql = re.sub(else_end_pattern, else_1_end_replacement, sql, flags=re.IGNORECASE | re.MULTILINE)
            if self.debug:
                print(f"ğŸ”§ CASE WHEN ì˜¤ë¥˜ ìˆ˜ì •: ELSE END â†’ ELSE 1 END íŒ¨í„´ êµì²´ ì™„ë£Œ")
        
        if self.debug and sql != original_sql:
            print(f"\nğŸ”§ SQL ì •ë¦¬ ì™„ë£Œ:")
            print(f"ì›ë³¸: ...{original_sql[-200:]}")
            print(f"ì •ë¦¬: ...{sql[-200:]}")
            print()
        
        # ë§ˆì§€ë§‰ ë‹¨ê³„: Window í•¨ìˆ˜ì˜ PARTITION BY/ORDER BY 1 â†’ (SELECT NULL) ì¹˜í™˜
        # MySQLì—ì„œ Window í•¨ìˆ˜ì˜ PARTITION BY 1, ORDER BY 1ì€ ì˜¤ë¥˜ ë°œìƒ
        
        # 1. ë¨¼ì € ë³µìˆ˜ ì»¬ëŸ¼ íŒ¨í„´ ì²˜ë¦¬ (ë” êµ¬ì²´ì ì¸ íŒ¨í„´ì„ ë¨¼ì €)
        sql = re.sub(r'\bORDER\s+BY\s+1\s*,\s*1\b', 'ORDER BY (SELECT NULL)', sql, flags=re.IGNORECASE)
        sql = re.sub(r'\bPARTITION\s+BY\s+1\s*,\s*1\b', 'PARTITION BY (SELECT NULL)', sql, flags=re.IGNORECASE)
        
        # 2. ë” ë³µì¡í•œ íŒ¨í„´ë“¤ ì²˜ë¦¬ (3ê°œ ì´ìƒì˜ 1)
        sql = re.sub(r'\bORDER\s+BY\s+1\s*(?:,\s*1\s*)+', 'ORDER BY (SELECT NULL)', sql, flags=re.IGNORECASE)
        sql = re.sub(r'\bPARTITION\s+BY\s+1\s*(?:,\s*1\s*)+', 'PARTITION BY (SELECT NULL)', sql, flags=re.IGNORECASE)
        
        # 3. ë§ˆì§€ë§‰ì— ë‹¨ì¼ ì»¬ëŸ¼ íŒ¨í„´ ì²˜ë¦¬
        sql = re.sub(r'\bPARTITION\s+BY\s+1\b', 'PARTITION BY (SELECT NULL)', sql, flags=re.IGNORECASE)
        sql = re.sub(r'\bORDER\s+BY\s+1\b', 'ORDER BY (SELECT NULL)', sql, flags=re.IGNORECASE)
        
        if self.debug and ('PARTITION BY (SELECT NULL)' in sql or 'ORDER BY (SELECT NULL)' in sql):
            print("ğŸ”§ Window í•¨ìˆ˜ PARTITION BY/ORDER BY 1 â†’ (SELECT NULL) ì¹˜í™˜ ì™„ë£Œ")
        
        return sql
    
    def fix_sql_patterns_before_execution(self, sql):
        """SQL ì‹¤í–‰ ì „ ë¬¸ì œê°€ ë˜ëŠ” íŒ¨í„´ë“¤ì„ ìˆ˜ì •"""
        
        if self.debug:
            print("ğŸ”§ SQL íŒ¨í„´ ìˆ˜ì • ì‹œì‘")
        
        original_sql = sql
        
        # 1. IN (SELECT 1) â†’ IN (SELECT NULL WHERE 1=0) íŒ¨í„´ ìˆ˜ì •
        # ë¹ˆ ê²°ê³¼ì…‹ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ê¸° ìœ„í•´ NULL ë°˜í™˜
        sql = re.sub(r'\bIN\s*\(\s*SELECT\s+1\s*\)', 'IN (SELECT NULL WHERE 1=0)', sql, flags=re.IGNORECASE)
        
        # 2. REGEXP 1 â†’ REGEXP 'pattern' íŒ¨í„´ ìˆ˜ì •
        # ìˆ«ì 1ì´ ì •ê·œì‹ íŒ¨í„´ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ê²½ìš° ìœ íš¨í•œ íŒ¨í„´ìœ¼ë¡œ êµì²´
        sql = re.sub(r'\bREGEXP\s+1\b', "REGEXP 'pattern'", sql, flags=re.IGNORECASE)
        
        # 3. 1 REGEXP 1 â†’ 1 REGEXP 'pattern' íŒ¨í„´ ìˆ˜ì •
        sql = re.sub(r'\b1\s+REGEXP\s+1\b', "1 REGEXP 'pattern'", sql, flags=re.IGNORECASE)
        
        # 4. ê¸°íƒ€ REGEXP íŒ¨í„´ì—ì„œ ìˆ«ìë¥¼ ë¬¸ìì—´ë¡œ êµì²´
        sql = re.sub(r'(\w+)\s+REGEXP\s+(\d+)', r"\1 REGEXP 'pattern'", sql, flags=re.IGNORECASE)
        
        # 5. EXISTS (SELECT 1) â†’ EXISTS (SELECT NULL WHERE 1=0) 
        # ë¹ˆ ê²°ê³¼ì…‹ìœ¼ë¡œ ë§Œë“¤ì–´ í•­ìƒ FALSE ë°˜í™˜
        sql = re.sub(r'\bEXISTS\s*\(\s*SELECT\s+1\s*\)', 'EXISTS (SELECT NULL WHERE 1=0)', sql, flags=re.IGNORECASE)
        
        # 6. í…Œì´ë¸”ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì„œë¸Œì¿¼ë¦¬ íŒ¨í„´ ìˆ˜ì •
        # FROM ì ˆì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í…Œì´ë¸”ì´ ìˆëŠ” ê²½ìš° ë”ë¯¸ í…Œì´ë¸”ë¡œ êµì²´
        problematic_tables = ['ITIN_DAT', 'CDSHARE_DAT', 'OALDAT1', 'G3_VIA_DAT', 'SEGDAT', 'OALDAT1']
        for table in problematic_tables:
            sql = re.sub(rf'\bFROM\s+{table}\b', 'FROM (SELECT NULL) AS dummy_table', sql, flags=re.IGNORECASE)
        
        # 7. GROUPING í•¨ìˆ˜ ë¬¸ì œ í•´ê²° - MySQLì—ì„œëŠ” GROUP BYì™€ í•¨ê»˜ ì‚¬ìš©í•´ì•¼ í•¨
        if 'GROUPING(' in sql.upper():
            # GROUPING í•¨ìˆ˜ê°€ ìˆìœ¼ë©´ ê°„ë‹¨í•œ ê°’ìœ¼ë¡œ êµì²´
            sql = re.sub(r'\bGROUPING\s*\([^)]+\)', '0', sql, flags=re.IGNORECASE)
        
        # 8. RATIO_TO_REPORT í•¨ìˆ˜ - MySQLì—ì„œ ì§€ì›í•˜ì§€ ì•ŠìŒ
        if 'RATIO_TO_REPORT(' in sql.upper():
            sql = re.sub(r'\bRATIO_TO_REPORT\s*\([^)]+\)\s*OVER\s*\([^)]*\)', '1', sql, flags=re.IGNORECASE)
        
        if self.debug and sql != original_sql:
            print("ğŸ”§ SQL íŒ¨í„´ ìˆ˜ì • ì™„ë£Œ")
            changes = []
            if 'IN (SELECT NULL WHERE 1=0)' in sql:
                changes.append("IN (SELECT 1) â†’ IN (SELECT NULL WHERE 1=0)")
            if "REGEXP 'pattern'" in sql:
                changes.append("REGEXP 1 â†’ REGEXP 'pattern'")
            if 'EXISTS (SELECT NULL WHERE 1=0)' in sql:
                changes.append("EXISTS (SELECT 1) â†’ EXISTS (SELECT NULL WHERE 1=0)")
            if 'dummy_table' in sql:
                changes.append("ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í…Œì´ë¸” â†’ dummy_table")
            if 'GROUPING(' not in sql.upper() and '0' in sql:
                changes.append("GROUPING í•¨ìˆ˜ â†’ 0")
            if changes:
                print("ìˆ˜ì •ëœ íŒ¨í„´ë“¤:")
                for change in changes:
                    print(f"  - {change}")
        
        return sql
    
    def save_result(self, result):
        """ê²°ê³¼ë¥¼ JSON íŒŒì¼ë¡œ ì €ì¥ (XMLFileNameì´ ê°™ì§€ ì•Šìœ¼ë©´ ì¶”ê°€)"""
        result_file = os.path.join(self.app_transform_folder, "sqlTestResult.json")
        
        # ê¸°ì¡´ ë°ì´í„° ë¡œë“œ
        existing_data = []
        if os.path.exists(result_file):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    content = f.read().strip()
                    if content:
                        existing_data = json.loads(content)
                        # ë‹¨ì¼ ê°ì²´ì¸ ê²½ìš° ë°°ì—´ë¡œ ë³€í™˜
                        if isinstance(existing_data, dict):
                            existing_data = [existing_data]
            except (json.JSONDecodeError, FileNotFoundError):
                existing_data = []
        
        # ìƒˆë¡œìš´ ê²°ê³¼ì˜ XMLFileName í™•ì¸ (file í•„ë“œì—ì„œ íŒŒì¼ëª… ì¶”ì¶œ)
        new_xml_filename = Path(result.get("file", "")).name
        
        # ê¸°ì¡´ ë°ì´í„°ì—ì„œ ê°™ì€ XMLFileNameì´ ìˆëŠ”ì§€ í™•ì¸
        found_index = -1
        for i, item in enumerate(existing_data):
            existing_xml_filename = Path(item.get("file", "")).name
            if existing_xml_filename == new_xml_filename:
                found_index = i
                break
        
        # ê°™ì€ XMLFileNameì´ ìˆìœ¼ë©´ êµì²´, ì—†ìœ¼ë©´ ì¶”ê°€
        if found_index >= 0:
            existing_data[found_index] = result
        else:
            existing_data.append(result)
        
        # íŒŒì¼ì— ì €ì¥
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(existing_data, f, ensure_ascii=False, indent=2)
    
    def remove_from_failed_result(self, xml_file_path):
        """ì„±ê³µí•œ ì¼€ì´ìŠ¤ë¥¼ ì‹¤íŒ¨ ëª©ë¡ì—ì„œ ì œê±°"""
        failed_result_file = os.path.join(self.app_transform_folder, "sqlTestResultFailed.json")
        
        if not os.path.exists(failed_result_file):
            return
        
        transform_xml_filename = Path(xml_file_path).name
        
        try:
            with open(failed_result_file, 'r', encoding='utf-8') as f:
                failed_data = json.load(f)
                if not isinstance(failed_data, list):
                    return
        except (json.JSONDecodeError, FileNotFoundError):
            return
        
        # í•´ë‹¹ íŒŒì¼ëª…ê³¼ ì¼ì¹˜í•˜ëŠ” í•­ëª©ë“¤ì„ ëª¨ë‘ ì œê±°
        original_count = len(failed_data)
        failed_data = [item for item in failed_data 
                      if item.get("TransformXMLFileName") != transform_xml_filename]
        
        removed_count = original_count - len(failed_data)
        
        if removed_count > 0:
            # ì—…ë°ì´íŠ¸ëœ ì‹¤íŒ¨ ëª©ë¡ ì €ì¥
            with open(failed_result_file, 'w', encoding='utf-8') as f:
                json.dump(failed_data, f, ensure_ascii=False, indent=2)
            
            if self.debug:
                print(f"ğŸ—‘ï¸ ì‹¤íŒ¨ ëª©ë¡ì—ì„œ {removed_count}ê°œ í•­ëª© ì œê±°: {transform_xml_filename}")

    def save_failed_result(self, xml_file_path, status, test_sql, error_message):
        """ì‹¤íŒ¨í•œ ì¼€ì´ìŠ¤ë¥¼ ë³„ë„ JSON íŒŒì¼ì— append ëª¨ë“œë¡œ ì €ì¥"""
        failed_result_file = os.path.join(self.app_transform_folder, "sqlTestResultFailed.json")
        
        if self.debug:
            print(f"ğŸ” save_failed_result í˜¸ì¶œë¨")
            print(f"ğŸ” ì…ë ¥ëœ xml_file_path: {xml_file_path}")
        
        # Transform XML íŒŒì¼ëª… ì¶”ì¶œ
        transform_xml_filename = Path(xml_file_path).name
        
        # Origin XML íŒŒì¼ ê²½ë¡œ ìƒì„±
        origin_xml_file = self.get_origin_xml_file(xml_file_path)
        
        if self.debug:
            print(f"ğŸ” ìƒì„±ëœ origin_xml_file: {origin_xml_file}")
        
        # ì‹¤íŒ¨ ê²°ê³¼ ë°ì´í„° êµ¬ì„±
        failed_result = {
            "TransformXMLFileName": transform_xml_filename,
            "Status": status,
            "TestSQL": test_sql,
            "SQLErrorMessage": error_message,
            "TransformXMLFile": xml_file_path,
            "OriginXMLFile": origin_xml_file,
            "timestamp": datetime.now().isoformat()
        }
        
        # ê¸°ì¡´ ì‹¤íŒ¨ ë°ì´í„° ë°°ì—´ ì½ê¸°
        try:
            if os.path.exists(failed_result_file):
                with open(failed_result_file, 'r', encoding='utf-8') as f:
                    failed_data = json.load(f)
                    if not isinstance(failed_data, list):
                        failed_data = []
            else:
                failed_data = []
        except (json.JSONDecodeError, FileNotFoundError):
            failed_data = []
        
        # ìƒˆ ì‹¤íŒ¨ ê²°ê³¼ ì¶”ê°€
        failed_data.append(failed_result)
        
        # ì „ì²´ ì‹¤íŒ¨ ë°°ì—´ì„ ë‹¤ì‹œ ì €ì¥
        with open(failed_result_file, 'w', encoding='utf-8') as f:
            json.dump(failed_data, f, ensure_ascii=False, indent=2)
    
    def get_origin_xml_file(self, xml_file_path):
        """ì›ë³¸ XML íŒŒì¼ ê²½ë¡œ ìƒì„± (transform->extract, tgt->src)"""
        path_str = str(xml_file_path)
        
        if self.debug:
            print(f"ğŸ” ì›ë³¸ Transform XML ê²½ë¡œ: {path_str}")
        
        # transform -> extract ë³€ê²½
        origin_path = path_str.replace('/transform/', '/extract/')
        
        # tgt -> src ë³€ê²½
        origin_path = origin_path.replace('_tgt-', '_src-')
        
        if self.debug:
            print(f"ğŸ” ë³€í™˜ëœ Extract XML ê²½ë¡œ: {origin_path}")
        
        return origin_path
    
    def setup_logger(self, xml_file_path):
        """ë¡œê±° ì„¤ì •"""
        # ë¡œê·¸ íŒŒì¼ëª… ìƒì„±
        xml_filename = Path(xml_file_path).stem  # .xml í™•ì¥ì ì œê±°
        log_filename = f"sqlTestResult_{xml_filename}.log"
        log_file_path = os.path.join(self.post_transform_log_dir, log_filename)
        
        # ë¡œê±° ì„¤ì •
        logger = logging.getLogger(f'sql_test_{xml_filename}')
        logger.setLevel(logging.INFO)
        
        # ê¸°ì¡´ í•¸ë“¤ëŸ¬ ì œê±°
        for handler in logger.handlers[:]:
            logger.removeHandler(handler)
        
        # íŒŒì¼ í•¸ë“¤ëŸ¬ ì¶”ê°€
        file_handler = logging.FileHandler(log_file_path, encoding='utf-8')
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        
        return logger, log_file_path
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        
        return logger, log_file_path
    
    def write_to_fixed_log(self, log_file_path, xml_file_path, status, message):
        """ê³ ì •ëœ ë¡œê·¸ íŒŒì¼ì— ê²°ê³¼ ê¸°ë¡"""
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            xml_filename = os.path.basename(xml_file_path)
            
            with open(log_file_path, 'a', encoding='utf-8') as log_file:
                log_file.write(f"[{timestamp}] {xml_filename}: {status} - {message}\n")
        except Exception as e:
            print(f"âš ï¸ ë¡œê·¸ íŒŒì¼ ê¸°ë¡ ì‹¤íŒ¨: {e}")
    
    def process_file(self, xml_file_path):
        """XML íŒŒì¼ ì²˜ë¦¬ ë©”ì¸ ë¡œì§"""
        # í†µí•© í…ŒìŠ¤íŠ¸ ë¡œê·¸ íŒŒì¼ ê²½ë¡œ
        FIXED_LOG_FILE = os.path.join(self.post_transform_log_dir, "sqlTestResult.log")
        
        try:
            # ë¡œê±° ì„¤ì •
            logger, log_file_path = self.setup_logger(xml_file_path)
            
            print("=" * 80)
            print("XML í•¨ìˆ˜ ê²€ì¦ (ì¼ê´„ í…ŒìŠ¤íŠ¸) - v1.6 ìœˆë„ìš° í•¨ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ê°œì„ ")
            print("=" * 80)
            print(f"ğŸ“ ì²˜ë¦¬ íŒŒì¼: {Path(xml_file_path).name}")
            print(f"ğŸ“ ë¡œê·¸ íŒŒì¼: {log_file_path}")
            
            # ì›ë³¸ XML íŒŒì¼ ê²½ë¡œ
            origin_xml_file = self.get_origin_xml_file(xml_file_path)
            logger.info(f"XML í•¨ìˆ˜ ê²€ì¦ ì‹œì‘: {xml_file_path}")
            logger.info(f"ì›ë³¸ XML íŒŒì¼: {origin_xml_file}")
            
            # 1. XML ë‚´ìš© ì¶”ì¶œ (íƒœê·¸ ì œê±° ì—†ì´)
            xml_content = self.extract_xml_content(xml_file_path)
            if xml_content.startswith("íŒŒì¼ ì½ê¸° ì˜¤ë¥˜"):
                error_message = xml_content
                logger.error(error_message)
                print(f"âŒ {error_message}")
                
                # ê³ ì • ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
                self.write_to_fixed_log(FIXED_LOG_FILE, xml_file_path, "ERROR", error_message)
                return
            
            # 2. ì›ë³¸ XMLì—ì„œ í•¨ìˆ˜ ë¦¬ìŠ¤íŠ¸ ì¶”ì¶œ (íƒœê·¸ ì œê±° ì „ì— ìˆ˜í–‰)
            original_functions = self.extract_functions_from_xml(xml_content)
            logger.info(f"ì¶”ì¶œëœ í•¨ìˆ˜ ê°œìˆ˜: {len(original_functions)}")
            print(f"ğŸ“Š ì¶”ì¶œëœ í•¨ìˆ˜ ê°œìˆ˜: {len(original_functions)}")
            
            # 3. íƒœê·¸ ì œê±°ëœ XML ë‚´ìš© ìƒì„± (SQL ìƒì„±ìš©)
            cleaned_xml_content = self.clean_xml_content(xml_content)
            
            if not original_functions:
                completed_message = "í•¨ìˆ˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
                logger.info(f"Completed: {completed_message}")
                print(f"âŒ {completed_message}")
                
                # ê³ ì • ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
                self.write_to_fixed_log(FIXED_LOG_FILE, xml_file_path, "NO_FUNCTIONS", completed_message)
                
                # ê²°ê³¼ ì €ì¥
                result = {
                    "file": xml_file_path,
                    "status": "completed",
                    "message": completed_message,
                    "functions_count": 0,
                    "unique_functions_count": 0,
                    "sql": "",
                    "timestamp": datetime.now().isoformat()
                }
                self.save_result(result)
                return
            
            # 3. í•¨ìˆ˜ ë³€í™˜ (íŒŒì„œ ê¸°ë°˜ ì²˜ë¦¬ ì‚¬ìš©)
            transformed_functions = [self.transform_function_for_testing_with_parser(func) for func in original_functions]
            
            # 4. ì¤‘ë³µ ì œê±° (None ê°’ í•„í„°ë§ í¬í•¨)
            unique_functions = []
            for func in transformed_functions:
                if func is not None and func not in unique_functions:
                    unique_functions.append(func)
            
            logger.info(f"ì¤‘ë³µ ì œê±° í›„ í•¨ìˆ˜ ê°œìˆ˜: {len(unique_functions)}")
            print(f"ğŸ“Š ì¤‘ë³µ ì œê±° í›„ í•¨ìˆ˜ ê°œìˆ˜: {len(unique_functions)}")
            print("ğŸ” MySQL í•¨ìˆ˜ ê²€ì¦ ì¤‘...")
            
            # 5. MySQL ì¼ê´„ ê²€ì¦
            success, message, sql = self.validate_functions_batch(unique_functions, logger, xml_file_path)
            
            if success:
                print(f"âœ… {message}")
                result_status = "success"
                # ê³ ì • ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
                self.write_to_fixed_log(FIXED_LOG_FILE, xml_file_path, "SUCCESS", 
                                      f"{len(original_functions)} functions, {len(unique_functions)} unique")
            else:
                print(f"âŒ {message}")
                result_status = "failed"
                # ê³ ì • ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
                self.write_to_fixed_log(FIXED_LOG_FILE, xml_file_path, "FAILED", message)
                
                # ì‹¤íŒ¨í•œ ì¼€ì´ìŠ¤ë¥¼ ë³„ë„ JSON íŒŒì¼ì— ì €ì¥
                self.save_failed_result(xml_file_path, result_status, sql, message)
            
            # 6. ê²°ê³¼ ì €ì¥
            result = {
                "file": xml_file_path,
                "status": result_status,
                "message": message,
                "functions_count": len(original_functions),
                "unique_functions_count": len(unique_functions),
                "sql": sql,
                "timestamp": datetime.now().isoformat()
            }
            
            self.save_result(result)
            logger.info(f"ê²°ê³¼ íŒŒì¼ ì €ì¥: {os.path.join(self.app_transform_folder, 'sqlTestResult.json')}")
            print(f"ğŸ’¾ ê²°ê³¼ íŒŒì¼: {os.path.join(self.app_transform_folder, 'sqlTestResult.json')}")
            
        except Exception as e:
            error_message = f"ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}"
            print(f"âŒ {error_message}")
            if 'logger' in locals():
                logger.error(error_message)
            
            # ê³ ì • ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
            self.write_to_fixed_log(FIXED_LOG_FILE, xml_file_path, "EXCEPTION", str(e))
            
            # ì˜ˆì™¸ ë°œìƒ ì¼€ì´ìŠ¤ë„ ì‹¤íŒ¨ JSONì— ì €ì¥
            self.save_failed_result(xml_file_path, "exception", "", error_message)
        
        print("\n" + "=" * 80)
        print("ê²€ì¦ ì™„ë£Œ!")
        print("=" * 80)

def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    import argparse
    
    parser = argparse.ArgumentParser(description='XML íŒŒì¼ì—ì„œ í•¨ìˆ˜ ì¶”ì¶œ ë° MySQL ê²€ì¦ v1.6')
    parser.add_argument('xml_file', help='ì²˜ë¦¬í•  XML íŒŒì¼ ê²½ë¡œ')
    parser.add_argument('--debug', action='store_true', help='ë””ë²„ê·¸ ëª¨ë“œ (ìƒì„±ëœ SQL ì¶œë ¥)')
    
    args = parser.parse_args()
    
    # XML íŒŒì¼ ê²½ë¡œë¥¼ ì ˆëŒ€ ê²½ë¡œë¡œ ë³€í™˜
    xml_file_path = os.path.abspath(args.xml_file)
    
    # XML íŒŒì¼ ì¡´ì¬ í™•ì¸
    if not os.path.exists(xml_file_path):
        print(f"âŒ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {xml_file_path}")
        sys.exit(1)
    
    # ê²€ì¦ê¸° ì‹¤í–‰
    validator = FunctionValidator(debug=args.debug)
    validator.process_file(xml_file_path)

if __name__ == "__main__":
    main()
