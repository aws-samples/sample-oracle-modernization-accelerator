#!/usr/bin/env python3
"""
XML íŒŒì¼ì—ì„œ í•¨ìˆ˜ ì¶”ì¶œ ë° ê²€ì¦ í”„ë¡œê·¸ë¨ v1.6
- 1630 ì˜¤ë¥˜ í•´ê²° (í•¨ìˆ˜ ê³µë°± ë¬¸ì œ)
- ìœˆë„ìš° í•¨ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ê°œì„ 

Version: 1.6
Author: Amazon Q Developer  
Date: 2025-07-19
Changelog:
- v1.6: 1630 ì˜¤ë¥˜ í•´ê²°, ìœˆë„ìš° í•¨ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ê°œì„ 
- v1.5: PARTITION BY ë³´í˜¸, MyBatis ${} ë³€ìˆ˜ ì²˜ë¦¬ ì¶”ê°€
- v1.4: CAST í•¨ìˆ˜ì™€ ìœˆë„ìš° í•¨ìˆ˜ íŠ¹ë³„ ì²˜ë¦¬ ì¶”ê°€
- v1.3: MyBatis íŒŒë¼ë¯¸í„° ì²˜ë¦¬ ì¶”ê°€
- v1.2: SQL íŒŒì„œ ê¸°ë°˜ìœ¼ë¡œ ì „ë©´ ê°œí¸
"""

import re
import sys
import os
import json
import logging
import mysql.connector
from pathlib import Path
from datetime import datetime

# ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì˜ ë””ë ‰í† ë¦¬ë¥¼ Python ê²½ë¡œì— ì¶”ê°€
script_dir = os.path.dirname(os.path.abspath(__file__))
if script_dir not in sys.path:
    sys.path.insert(0, script_dir)

# SQL íŒŒì„œ import
from sql_function_parser import SQLFunctionParser

class FunctionValidator:
    def __init__(self, debug=False):
        self.debug = True  # ì„ì‹œë¡œ ë””ë²„ê·¸ ëª¨ë“œ í™œì„±í™”
        self.target_dbms = os.getenv('TARGET_DBMS_TYPE', 'mysql').lower()
        
        # í™˜ê²½ë³€ìˆ˜ì—ì„œ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
        self.app_logs_folder = os.getenv('APP_LOGS_FOLDER', '/tmp')
        self.app_transform_folder = os.getenv('APP_TRANSFORM_FOLDER', '/tmp')
        
        # ë¡œê·¸ ë””ë ‰í† ë¦¬ ìƒì„±
        self.post_transform_log_dir = os.path.join(self.app_logs_folder, 'postTransform')
        os.makedirs(self.post_transform_log_dir, exist_ok=True)
        os.makedirs(self.app_transform_folder, exist_ok=True)
        
        # SQL íŒŒì„œ ì´ˆê¸°í™”
        self.parser = SQLFunctionParser()
        
        # ëª¨ë“  í•¨ìˆ˜ëª… í†µí•© (MySQL, Oracle, PostgreSQL)
        self.all_functions = {
            # ë¬¸ìì—´ í•¨ìˆ˜ë“¤
            'CONCAT', 'SUBSTRING', 'SUBSTR', 'UPPER', 'LOWER', 'TRIM', 'LTRIM', 'RTRIM',
            'REPLACE', 'LENGTH', 'CHAR_LENGTH', 'LEFT', 'RIGHT', 'REVERSE',
            'LOCATE', 'INSTR', 'POSITION', 'LPAD', 'RPAD', 'REPEAT', 'SPACE',
            'INITCAP', 'TRANSLATE', 'ASCII', 'CHR', 'SOUNDEX', 'REGEXP_REPLACE',
            'REGEXP_SUBSTR', 'REGEXP_INSTR', 'REGEXP_COUNT',
            'SPLIT_PART', 'STRING_AGG', 'ARRAY_TO_STRING', 'STRING_TO_ARRAY',
            'BTRIM', 'OVERLAY', 'STRPOS',
            
            # ìˆ«ì í•¨ìˆ˜ë“¤
            'SUM', 'COUNT', 'AVG', 'MAX', 'MIN', 'ROUND', 'CEIL', 'CEILING', 'FLOOR',
            'ABS', 'MOD', 'POWER', 'SQRT', 'SIGN', 'GREATEST', 'LEAST',
            'TRUNC', 'BITAND', 'EXP', 'LN', 'LOG', 'SIN', 'COS', 'TAN',
            'RANDOM', 'WIDTH_BUCKET', 'DEGREES', 'RADIANS',
            'ROW_NUMBER', 'RANK', 'DENSE_RANK', 'NTILE', 'PERCENT_RANK',
            'CUME_DIST', 'LEAD', 'LAG', 'FIRST_VALUE', 'LAST_VALUE',
            'RATIO_TO_REPORT', 'GROUPING',
            
            # ë‚ ì§œ/ì‹œê°„ í•¨ìˆ˜ë“¤
            'DATE_FORMAT', 'STR_TO_DATE', 'DATE_ADD', 'DATE_SUB', 'DATEDIFF',
            'YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'DAYOFWEEK',
            'UNIX_TIMESTAMP', 'FROM_UNIXTIME', 'TIME_FORMAT', 'NOW', 'CURDATE',
            'CURTIME', 'CURRENT_TIMESTAMP', 'CURRENT_DATE', 'CURRENT_TIME',
            'SYSDATE', 'SYSTIMESTAMP', 'TO_DATE', 'TO_CHAR', 'ADD_MONTHS',
            'MONTHS_BETWEEN', 'NEXT_DAY', 'LAST_DAY', 'EXTRACT',
            'DATE_TRUNC', 'AGE', 'JUSTIFY_DAYS', 'JUSTIFY_HOURS', 'JUSTIFY_INTERVAL',
            'CLOCK_TIMESTAMP', 'STATEMENT_TIMESTAMP', 'TRANSACTION_TIMESTAMP',
            
            # NULL ì²˜ë¦¬ í•¨ìˆ˜ë“¤
            'IFNULL', 'ISNULL', 'COALESCE', 'NULLIF', 'NVL', 'NVL2', 'LNNVL',
            
            # ë³€í™˜ í•¨ìˆ˜ë“¤
            'CAST', 'CONVERT', 'BINARY', 'CHAR', 'SIGNED', 'UNSIGNED',
            'TO_NUMBER', 'TO_TIMESTAMP'
        }
        
        # MySQL ì˜ˆì•½ì–´ ë³´í˜¸ ë¦¬ìŠ¤íŠ¸ (PARTITION, GROUPING, ë°ì´í„° íƒ€ì… ì¶”ê°€)
        self.mysql_reserved_words = {
            'INTERVAL', 'SELECT', 'FROM', 'WHERE', 'GROUP', 'ORDER', 'BY', 'HAVING',
            'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'DROP', 'ALTER', 'TABLE',
            'INDEX', 'VIEW', 'DATABASE', 'SCHEMA', 'UNION', 'JOIN', 'INNER', 'LEFT',
            'RIGHT', 'OUTER', 'ON', 'AS', 'AND', 'OR', 'NOT', 'IN', 'EXISTS',
            'BETWEEN', 'LIKE', 'REGEXP', 'IS', 'NULL', 'TRUE', 'FALSE', 'DISTINCT',
            'ALL', 'ANY', 'SOME', 'CASE', 'WHEN', 'THEN', 'ELSE', 'END',
            'IF', 'WHILE', 'FOR', 'LOOP', 'REPEAT', 'UNTIL', 'DECLARE',
            'SET', 'CALL', 'PROCEDURE', 'FUNCTION', 'TRIGGER', 'EVENT',
            'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MONTH', 'YEAR', 'WEEK',
            'PARTITION', 'GROUPING', 'OVER', 'SEPARATOR', 'TRAILING', 'LEADING', 'BOTH',
            'LIMIT', 'OFFSET',  # LIMITê³¼ OFFSET ì¶”ê°€
            # MySQL ë°ì´í„° íƒ€ì…ë“¤
            'CHAR', 'VARCHAR', 'TEXT', 'TINYTEXT', 'MEDIUMTEXT', 'LONGTEXT',
            'BINARY', 'VARBINARY', 'BLOB', 'TINYBLOB', 'MEDIUMBLOB', 'LONGBLOB',
            'INT', 'INTEGER', 'TINYINT', 'SMALLINT', 'MEDIUMINT', 'BIGINT',
            'DECIMAL', 'NUMERIC', 'FLOAT', 'DOUBLE', 'REAL', 'BIT',
            'DATE', 'TIME', 'DATETIME', 'TIMESTAMP', 'YEAR',
            'SIGNED', 'UNSIGNED'
        }
    
    def extract_xml_content(self, xml_file_path):
        """XML íŒŒì¼ì—ì„œ ì „ì²´ ë‚´ìš© ì¶”ì¶œ (íƒœê·¸ ì œê±° ì—†ì´)"""
        try:
            with open(xml_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            return content.strip()
            
        except Exception as e:
            return f"íŒŒì¼ ì½ê¸° ì˜¤ë¥˜: {e}"
    
    def clean_xml_content(self, xml_content):
        """XML ë‚´ìš©ì—ì„œ ë™ì  íƒœê·¸ë“¤ ì œê±° (í•¨ìˆ˜ ì¶”ì¶œ í›„ì— ì‚¬ìš©)"""
        # XML ì£¼ì„ ì œê±° (í•¨ìˆ˜ ì¶”ì¶œ ì „ì— ë¨¼ì € ì œê±°)
        content = re.sub(r'<!--.*?-->', '', xml_content, flags=re.DOTALL)
        
        # CDATA íƒœê·¸ ì œê±°
        content = re.sub(r'<!\[CDATA\[(.*?)\]\]>', r'\1', content, flags=re.DOTALL)
        
        # ë™ì  íƒœê·¸ë“¤ ì œê±°
        dynamic_tags = [
            r'<if[^>]*>.*?</if>', r'<choose[^>]*>.*?</choose>',
            r'<when[^>]*>.*?</when>', r'<otherwise[^>]*>.*?</otherwise>',
            r'<where[^>]*>.*?</where>', r'<set[^>]*>.*?</set>',
            r'<trim[^>]*>.*?</trim>', r'<foreach[^>]*>.*?</foreach>',
            r'<include[^>]*/>',
        ]
        
        for tag_pattern in dynamic_tags:
            content = re.sub(tag_pattern, '', content, flags=re.DOTALL | re.IGNORECASE)
        
        return content.strip()
    
    def extract_functions_from_xml(self, xml_content):
        """SQL íŒŒì„œë¥¼ ì‚¬ìš©í•´ì„œ XML ë‚´ìš©ì—ì„œ í•¨ìˆ˜ë“¤ì„ ì¶”ì¶œ"""
        
        # ë¨¼ì € XML íƒœê·¸ë¥¼ ì œê±°í•œ í›„ í•¨ìˆ˜ ì¶”ì¶œ
        cleaned_content = self.clean_xml_content_for_parsing(xml_content)
        
        # íŒŒì„œì— ì •ë¦¬ëœ í…ìŠ¤íŠ¸ ì„¤ì •
        self.parser.set_original_text(cleaned_content)
        
        # íŒŒì„œë¡œ í•¨ìˆ˜ ì¶”ì¶œ
        functions = self.parser.parse(cleaned_content)
        
        # ì¶”ì¶œëœ í•¨ìˆ˜ë“¤ì—ì„œ ì¶”ê°€ ì •ë¦¬ (í›„ì²˜ë¦¬)
        cleaned_functions = []
        for func in functions:
            cleaned_func = self.post_process_extracted_function(func)
            if cleaned_func and cleaned_func.strip():
                cleaned_functions.append(cleaned_func)
        
        return cleaned_functions
    
    def clean_xml_content_for_parsing(self, xml_content):
        """í•¨ìˆ˜ ì¶”ì¶œì„ ìœ„í•œ XML íƒœê·¸ ì œê±° (ê¸°ì¡´ clean_xml_contentì™€ ë™ì¼)"""
        # XML ì£¼ì„ ì œê±°
        content = re.sub(r'<!--.*?-->', '', xml_content, flags=re.DOTALL)
        
        # CDATA íƒœê·¸ ì œê±°
        content = re.sub(r'<!\[CDATA\[(.*?)\]\]>', r'\1', content, flags=re.DOTALL)
        
        # ë™ì  íƒœê·¸ë“¤ ì œê±°
        dynamic_tags = [
            r'<if[^>]*>.*?</if>', r'<choose[^>]*>.*?</choose>',
            r'<when[^>]*>.*?</when>', r'<otherwise[^>]*>.*?</otherwise>',
            r'<where[^>]*>.*?</where>', r'<set[^>]*>.*?</set>',
            r'<trim[^>]*>.*?</trim>', r'<foreach[^>]*>.*?</foreach>',
            r'<include[^>]*/>',
        ]
        
        for tag_pattern in dynamic_tags:
            content = re.sub(tag_pattern, '', content, flags=re.DOTALL | re.IGNORECASE)
        
        return content.strip()
    
    def post_process_extracted_function(self, function_text):
        """ì¶”ì¶œëœ í•¨ìˆ˜ì˜ í›„ì²˜ë¦¬ (ê¸°ì¡´ remove_xml_tags_from_function ë¡œì§ í™œìš©)"""
        if not function_text:
            return function_text
            
        result = function_text
        
        # SQL ì£¼ì„ ì œê±° (-- ì£¼ì„) - í•¨ìˆ˜ë³„ë¡œ ê°œë³„ ì²˜ë¦¬
        result = re.sub(r'--[^\r\n]*', ' ', result)
        
        # í˜¹ì‹œ ë‚¨ì€ XML íƒœê·¸ ì œê±°
        result = re.sub(r'<[^>]+>', '', result, flags=re.IGNORECASE)
        
        # AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´ ìˆ˜ì •
        result = self.fix_missing_and_operators(result)
        
        # ì—¬ëŸ¬ ê³µë°±ì„ í•˜ë‚˜ë¡œ ì •ë¦¬
        result = re.sub(r'\s+', ' ', result)
        
        return result.strip()
    
    def remove_xml_tags_from_function(self, function_text):
        """ê°œë³„ í•¨ìˆ˜ì—ì„œ XML íƒœê·¸ ì œê±° ë° AND ì—°ì‚°ì ëˆ„ë½ ìˆ˜ì •"""
        if not function_text:
            return function_text
            
        result = function_text
        
        # XML ì£¼ì„ ì œê±°
        result = re.sub(r'<!--.*?-->', '', result, flags=re.DOTALL)
        
        # SQL ì£¼ì„ ì œê±° (-- ì£¼ì„)
        result = re.sub(r'--[^\r\n]*', ' ', result)
        
        # CDATA íƒœê·¸ ì œê±°
        result = re.sub(r'<!\[CDATA\[(.*?)\]\]>', r'\1', result, flags=re.DOTALL)
        
        # ìƒí˜¸ ë°°íƒ€ì  ì¡°ê±´ë¬¸ íŒ¨í„´ ì²˜ë¦¬
        result = self.handle_mutually_exclusive_conditions(result)
        
        # ë‚˜ë¨¸ì§€ ë™ì  íƒœê·¸ë“¤ ì œê±° (íƒœê·¸ë§Œ ì œê±°í•˜ê³  ë‚´ìš©ì€ ìœ ì§€)
        result = re.sub(r'<if[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</if>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<choose[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</choose>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<when[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</when>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<otherwise[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</otherwise>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<where[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</where>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<set[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</set>', '', result, flags=re.IGNORECASE)
        # MyBatis <trim> íƒœê·¸ë§Œ ì œê±° (SQL TRIM í•¨ìˆ˜ëŠ” ë³´ì¡´)
        # MyBatis trim íƒœê·¸ëŠ” prefix, suffix, prefixOverrides, suffixOverrides ì†ì„±ì„ ê°€ì§
        result = re.sub(r'<trim\s+[^>]*(?:prefix|suffix|prefixOverrides|suffixOverrides)[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</trim>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<foreach[^>]*>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'</foreach>', '', result, flags=re.IGNORECASE)
        result = re.sub(r'<include[^>]*/?>', '', result, flags=re.IGNORECASE)
        
        # AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´ ìˆ˜ì •
        result = self.fix_missing_and_operators(result)
        
        # ì—¬ëŸ¬ ê³µë°±ì„ í•˜ë‚˜ë¡œ ì •ë¦¬
        result = re.sub(r'\s+', ' ', result)
        
        return result.strip()
    
    def fix_missing_and_operators(self, text):
        """AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´ ìˆ˜ì •"""
        result = text
        
        # íŒ¨í„´ 1: = 'Y' IFNULL(...) = '1' THEN â†’ = 'Y' AND IFNULL(...) = '1' THEN
        pattern1 = r"=\s*'Y'\s+(IFNULL\([^)]+\)[^=]*=\s*'[^']+'\s+THEN)"
        replacement1 = r"= 'Y' AND \1"
        
        if re.search(pattern1, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´1 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern1, replacement1, result, flags=re.IGNORECASE)
        
        # íŒ¨í„´ 2: = 'SELK138AX' 1 = 1 â†’ = 'SELK138AX' AND 1 = 1
        pattern2 = r"=\s*'([^']+)'\s+(\d+\s*=\s*\d+)"
        replacement2 = r"= '\1' AND \2"
        
        if re.search(pattern2, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´2 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern2, replacement2, result, flags=re.IGNORECASE)
        
        # íŒ¨í„´ 3: IFNULL( 1,0) 1 END â†’ IFNULL( 1,0) ELSE 1 END
        pattern3 = r"IFNULL\s*\(\s*[^,]+,\s*[^)]+\)\s+(\d+\s+END)"
        replacement3 = r"IFNULL( 1,0) ELSE \1"
        
        if re.search(pattern3, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´3 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern3, replacement3, result, flags=re.IGNORECASE)
        
        # íŒ¨í„´ 4: 1 <> 0 1 > 0 â†’ 1 <> 0 AND 1 > 0
        pattern4 = r"(\d+\s*<>\s*\d+)\s+(\d+\s*>\s*\d+)"
        replacement4 = r"\1 AND \2"
        
        if re.search(pattern4, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´4 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern4, replacement4, result, flags=re.IGNORECASE)
        
        # íŒ¨í„´ 5: THEN IFNULL( 1,0) 1 END â†’ THEN IFNULL( 1,0) AND 1 END
        pattern5 = r"THEN\s+IFNULL\s*\(\s*[^,]+,\s*[^)]+\)\s+(\d+\s+END)"
        replacement5 = r"THEN IFNULL( 1,0) AND \1"
        
        if re.search(pattern5, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´5 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern5, replacement5, result, flags=re.IGNORECASE)
        
        # íŒ¨í„´ 7: THEN IFNULL(...) 1 END â†’ THEN 1 ELSE 1 END (ë³µì¡í•œ CASE ë¬¸ ê°„ì†Œí™”)
        pattern7 = r"THEN\s+IFNULL\s*\([^)]+\)\s+(\d+)\s+END"
        replacement7 = r"THEN 1 ELSE 1 END"
        
        if re.search(pattern7, result, re.IGNORECASE):
            if self.debug:
                print(f"ğŸ” AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´7 ë°œê²¬ ë° ìˆ˜ì •")
            result = re.sub(pattern7, replacement7, result, flags=re.IGNORECASE)
        
        return result
    
    def handle_mutually_exclusive_conditions(self, text):
        """ìƒí˜¸ ë°°íƒ€ì  ì¡°ê±´ë¬¸ ì²˜ë¦¬ - ì²« ë²ˆì§¸ ì¡°ê±´ë§Œ ì„ íƒ"""
        
        # ìƒí˜¸ ë°°íƒ€ì  íŒ¨í„´ë“¤ ì •ì˜
        mutually_exclusive_patterns = [
            # íŒ¨í„´ 1: onefarebasis null ì²´í¬
            {
                'pattern': r'<if\s+test="[^"]*onefarebasis[^"]*!=\s*\'\'[^"]*"[^>]*>(.*?)</if>\s*<if\s+test="[^"]*onefarebasis[^"]*==\s*\'\'[^"]*"[^>]*>(.*?)</if>',
                'replacement': r'\1'  # ì²« ë²ˆì§¸ ì¡°ê±´ë§Œ ì„ íƒ
            },
            # íŒ¨í„´ 2: ì¼ë°˜ì ì¸ null/not null ì²´í¬
            {
                'pattern': r'<if\s+test="[^"]*!=\s*null[^"]*"[^>]*>(.*?)</if>\s*<if\s+test="[^"]*==\s*null[^"]*"[^>]*>(.*?)</if>',
                'replacement': r'\1'  # ì²« ë²ˆì§¸ ì¡°ê±´ë§Œ ì„ íƒ
            },
            # íŒ¨í„´ 3: empty/not empty ì²´í¬
            {
                'pattern': r'<if\s+test="[^"]*!=\s*\'\'[^"]*"[^>]*>(.*?)</if>\s*<if\s+test="[^"]*==\s*\'\'[^"]*"[^>]*>(.*?)</if>',
                'replacement': r'\1'  # ì²« ë²ˆì§¸ ì¡°ê±´ë§Œ ì„ íƒ
            }
        ]
        
        result = text
        
        for pattern_info in mutually_exclusive_patterns:
            pattern = pattern_info['pattern']
            replacement = pattern_info['replacement']
            
            # ìƒí˜¸ ë°°íƒ€ì  íŒ¨í„´ ì°¾ê¸° ë° ì²« ë²ˆì§¸ ì¡°ê±´ë§Œ ì„ íƒ
            matches = re.findall(pattern, result, flags=re.DOTALL | re.IGNORECASE)
            if matches:
                if self.debug:
                    print(f"ğŸ” ìƒí˜¸ ë°°íƒ€ì  ì¡°ê±´ë¬¸ ë°œê²¬: {len(matches)}ê°œ")
                    for i, match in enumerate(matches):
                        print(f"  ì¡°ê±´ {i+1}-1: {match[0][:100]}...")
                        if len(match) > 1:
                            print(f"  ì¡°ê±´ {i+1}-2: {match[1][:100]}...")
                
                result = re.sub(pattern, replacement, result, flags=re.DOTALL | re.IGNORECASE)
        
        return result
    
    def protect_string_literals(self, text):
        """ë¬¸ìì—´ ë¦¬í„°ëŸ´ì„ ì„ì‹œ í† í°ìœ¼ë¡œ ë³´í˜¸"""
        self.string_map = {}
        result = text
        
        # í°ë”°ì˜´í‘œ ë¬¸ìì—´ ë³´í˜¸ "text"
        string_count = 0
        while True:
            match = re.search(r'"[^"]*"', result)
            if not match:
                break
            token = f"__DSTRING_{string_count}__"
            original = match.group(0)
            self.string_map[token] = original
            result = result.replace(original, token, 1)
            string_count += 1
        
        # ì‘ì€ë”°ì˜´í‘œ ë¬¸ìì—´ ë³´í˜¸ 'text'
        while True:
            match = re.search(r"'[^']*'", result)
            if not match:
                break
            token = f"__SSTRING_{string_count}__"
            original = match.group(0)
            self.string_map[token] = original
            result = result.replace(original, token, 1)
            string_count += 1
        
        return result
    
    def restore_string_literals(self, text):
        """ë³´í˜¸ëœ ë¬¸ìì—´ ë¦¬í„°ëŸ´ì„ ë³µì›"""
        result = text
        for token, original in self.string_map.items():
            result = result.replace(token, original)
        return result
    
    def analyze_nested_functions(self, func_text):
        """sqlparseë¥¼ ì‚¬ìš©í•˜ì—¬ ì¤‘ì²© í•¨ìˆ˜ ë¶„ì„"""
        try:
            import sqlparse
            from sqlparse.sql import Function, Parenthesis
            
            parsed = sqlparse.parse(func_text)[0]
            
            def find_functions(token, depth=0):
                functions = []
                if isinstance(token, Function):
                    func_info = {
                        'name': token.get_name(),
                        'depth': depth,
                        'full_text': str(token).strip()
                    }
                    functions.append(func_info)
                    
                    # í•¨ìˆ˜ ë‚´ë¶€ì˜ ì¤‘ì²© í•¨ìˆ˜ ì°¾ê¸°
                    for sub_token in token.tokens:
                        functions.extend(find_functions(sub_token, depth + 1))
                
                elif hasattr(token, 'tokens'):
                    for sub_token in token.tokens:
                        functions.extend(find_functions(sub_token, depth))
                
                return functions
            
            nested_funcs = find_functions(parsed)
            
            if self.debug and nested_funcs:
                print(f"ğŸ” ì¤‘ì²© í•¨ìˆ˜ ë¶„ì„:")
                for func in nested_funcs:
                    indent = "  " * func['depth']
                    print(f"    {indent}â””â”€ {func['name']} (depth: {func['depth']})")
            
            return nested_funcs
            
        except Exception as e:
            if self.debug:
                print(f"ğŸ” ì¤‘ì²© í•¨ìˆ˜ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return []

    def process_cast_functions_with_parser(self, sql_text):
        """sqlparseë¥¼ ì‚¬ìš©í•˜ì—¬ CAST í•¨ìˆ˜ ì •í™•íˆ ì²˜ë¦¬"""
        try:
            import sqlparse
            from sqlparse.sql import Function, Token
            from sqlparse.tokens import Keyword, Name
            
            parsed = sqlparse.parse(sql_text)[0]
            
            def process_token(token):
                if isinstance(token, Function):
                    func_name = token.get_name()
                    if func_name and func_name.upper() == 'CAST':
                        return self._fix_cast_function(token)
                    else:
                        # ë‹¤ë¥¸ í•¨ìˆ˜ëŠ” ë‚´ë¶€ í† í°ë“¤ë§Œ ì²˜ë¦¬
                        processed_tokens = []
                        for sub_token in token.tokens:
                            processed_tokens.append(process_token(sub_token))
                        return ''.join(processed_tokens)
                
                elif hasattr(token, 'tokens'):
                    processed_tokens = []
                    for sub_token in token.tokens:
                        processed_tokens.append(process_token(sub_token))
                    return ''.join(processed_tokens)
                
                else:
                    return str(token)
            
            result = process_token(parsed)
            
            if self.debug:
                print(f"ğŸ” CAST í•¨ìˆ˜ íŒŒì„œ ì²˜ë¦¬ í›„: {result}")
            
            return result
            
        except Exception as e:
            if self.debug:
                print(f"ğŸ” CAST íŒŒì„œ ì²˜ë¦¬ ì˜¤ë¥˜: {e}, ì •ê·œì‹ ì‚¬ìš©")
            return sql_text
    
    def _fix_cast_function(self, cast_token):
        """ê°œë³„ CAST í•¨ìˆ˜ í† í° ìˆ˜ì •"""
        cast_str = str(cast_token)
        cast_upper = cast_str.upper()
        
        # CAST í•¨ìˆ˜ ë‚´ìš© ë¶„ì„
        if ' AS ' not in cast_upper:
            # AS ì ˆì´ ì—†ëŠ” ê²½ìš° - CAST(value) â†’ CAST(value AS CHAR)
            # ê´„í˜¸ ë§¤ì¹­ì„ í†µí•œ ë‚´ìš© ì¶”ì¶œ
            content = self._extract_cast_content(cast_str)
            if content:
                return f'CAST({content} AS CHAR)'
        
        elif 'AS DECIMAL' in cast_upper:
            # DECIMALì€ MySQLì—ì„œ ì™„ì „íˆ ì§€ì›í•˜ë¯€ë¡œ ê·¸ëŒ€ë¡œ ìœ ì§€ (precision, scale í¬í•¨)
            return cast_str
        
        elif 'AS SIGNED' in cast_upper or 'AS UNSIGNED' in cast_upper:
            # SIGNED/UNSIGNEDëŠ” MySQLì—ì„œ ì§€ì›í•˜ë¯€ë¡œ ê·¸ëŒ€ë¡œ ìœ ì§€
            return cast_str
        
        elif re.search(r'AS\s+\d+', cast_str, re.IGNORECASE):
            # AS ìˆ«ì â†’ AS CHAR
            return re.sub(r'AS\s+\d+', 'AS CHAR', cast_str, flags=re.IGNORECASE)
        
        return cast_str
    
    def _extract_cast_content(self, cast_str):
        """CAST í•¨ìˆ˜ì—ì„œ ê´„í˜¸ ë§¤ì¹­ì„ í†µí•´ ë‚´ìš© ì¶”ì¶œ"""
        import re
        match = re.search(r'CAST\s*\(', cast_str, re.IGNORECASE)
        if not match:
            return None
            
        start_pos = match.end() - 1  # '(' ìœ„ì¹˜
        paren_count = 0
        content_start = start_pos + 1
        
        for i, char in enumerate(cast_str[start_pos:], start_pos):
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count == 0:
                    # ë§¤ì¹­ë˜ëŠ” ')' ì°¾ìŒ
                    content = cast_str[content_start:i].strip()
                    return content
        
        return None
    
    def _find_cast_end(self, cast_str):
        """CAST í•¨ìˆ˜ì˜ ë ìœ„ì¹˜ë¥¼ ì°¾ìŒ"""
        if not cast_str.upper().startswith('CAST('):
            return -1
            
        paren_count = 0
        start_pos = 4  # 'CAST' ë‹¤ìŒë¶€í„°
        
        for i, char in enumerate(cast_str[start_pos:], start_pos):
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count == 0:
                    return i + 1  # ')' ë‹¤ìŒ ìœ„ì¹˜
        
        return len(cast_str)  # ë§¤ì¹­ë˜ëŠ” ')' ì—†ìœ¼ë©´ ì „ì²´ ê¸¸ì´
    
    def remove_as_aliases_with_parser(self, sql_text):
        """sqlparseë¥¼ ì‚¬ìš©í•˜ì—¬ AS ë³„ì¹­ì„ ì•ˆì „í•˜ê²Œ ì œê±°"""
        try:
            # ë¨¼ì € CAST í•¨ìˆ˜ë“¤ì„ ë³´í˜¸
            protected_casts = []
            temp_sql = sql_text
            
            # CAST í•¨ìˆ˜ë¥¼ ì°¾ì•„ì„œ ë³´í˜¸
            cast_pattern = r'CAST\s*\('
            pos = 0
            while True:
                match = re.search(cast_pattern, temp_sql[pos:], re.IGNORECASE)
                if not match:
                    break
                
                actual_pos = pos + match.start()
                cast_content = self._extract_cast_with_position(temp_sql, actual_pos)
                if cast_content:
                    full_cast, end_pos = cast_content
                    placeholder = f'__PROTECTED_CAST_{len(protected_casts)}__'
                    protected_casts.append((placeholder, full_cast))
                    temp_sql = temp_sql[:actual_pos] + placeholder + temp_sql[actual_pos + end_pos:]
                    pos = actual_pos + len(placeholder)
                else:
                    pos = actual_pos + 1
            
            # ì´ì œ ì¼ë°˜ AS ë³„ì¹­ ì œê±° (CASTëŠ” ë³´í˜¸ë¨)
            # í•˜ì§€ë§Œ í•¨ìˆ˜ì˜ íŒŒë¼ë¯¸í„° ë‚´ë¶€ëŠ” ë³´í˜¸í•´ì•¼ í•¨
            # ), 0) AS alias íŒ¨í„´ì—ì„œ ), 0) ë¶€ë¶„ì„ ë³´í˜¸
            temp_sql = re.sub(r'\)\s*,\s*([^)]+)\)\s+AS\s+[A-Za-z_][A-Za-z0-9_]*\b', r'), \1)', temp_sql, flags=re.IGNORECASE)
            
            # ì¼ë°˜ì ì¸ AS ë³„ì¹­ ì œê±°
            temp_sql = re.sub(r'\)\s+AS\s+[A-Za-z_][A-Za-z0-9_]*\b(?!\s*\))', ')', temp_sql, flags=re.IGNORECASE)
            temp_sql = re.sub(r'END\s+AS\s+[A-Za-z_][A-Za-z0-9_]*\b', 'END', temp_sql, flags=re.IGNORECASE)
            
            # ë³´í˜¸ëœ CAST í•¨ìˆ˜ë“¤ ë³µì›
            for placeholder, original in protected_casts:
                temp_sql = temp_sql.replace(placeholder, original)
            
            if self.debug:
                print(f"ğŸ” sqlparse ê¸°ë°˜ AS ë³„ì¹­ ì œê±° í›„: {temp_sql}")
            
            return temp_sql
            
        except Exception as e:
            if self.debug:
                print(f"ğŸ” sqlparse AS ë³„ì¹­ ì œê±° ì˜¤ë¥˜: {e}, ì •ê·œì‹ ì‚¬ìš©")
            # ê¸°ì¡´ ì •ê·œì‹ ë°©ì‹ìœ¼ë¡œ fallback
            result = re.sub(r'\)\s+AS\s+[A-Za-z_][A-Za-z0-9_]*\b(?!\s*\))', ')', sql_text, flags=re.IGNORECASE)
            result = re.sub(r'END\s+AS\s+[A-Za-z_][A-Za-z0-9_]*\b', 'END', result, flags=re.IGNORECASE)
            return result
    
    def _extract_cast_with_position(self, sql_text, start_pos):
        """ì§€ì •ëœ ìœ„ì¹˜ì—ì„œ CAST í•¨ìˆ˜ ì „ì²´ë¥¼ ì¶”ì¶œ"""
        if not sql_text[start_pos:].upper().startswith('CAST'):
            return None
            
        # CAST( ì°¾ê¸°
        match = re.search(r'CAST\s*\(', sql_text[start_pos:], re.IGNORECASE)
        if not match:
            return None
            
        paren_start = start_pos + match.end() - 1  # '(' ìœ„ì¹˜
        paren_count = 0
        
        for i, char in enumerate(sql_text[paren_start:], paren_start):
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count == 0:
                    # ë§¤ì¹­ë˜ëŠ” ')' ì°¾ìŒ
                    full_cast = sql_text[start_pos:i+1]
                    return full_cast, i + 1 - start_pos
        
        return None

    def _find_cast_end(self, cast_str):
        """CAST í•¨ìˆ˜ì˜ ë ìœ„ì¹˜ë¥¼ ì°¾ìŒ"""
        import re
        match = re.search(r'CAST\s*\(', cast_str, re.IGNORECASE)
        if not match:
            return -1
            
        start_pos = match.end() - 1  # '(' ìœ„ì¹˜
        paren_count = 0
        
        for i, char in enumerate(cast_str[start_pos:], start_pos):
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count == 0:
                    # ë§¤ì¹­ë˜ëŠ” ')' ì°¾ìŒ
                    return i + 1
        
        return -1
        """CAST í•¨ìˆ˜ì—ì„œ ê´„í˜¸ ë§¤ì¹­ì„ í†µí•´ ë‚´ìš© ì¶”ì¶œ"""
        import re
        match = re.search(r'CAST\s*\(', cast_str, re.IGNORECASE)
        if not match:
            return None
            
        start_pos = match.end() - 1  # '(' ìœ„ì¹˜
        paren_count = 0
        content_start = start_pos + 1
        
        for i, char in enumerate(cast_str[start_pos:], start_pos):
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count == 0:
                    # ë§¤ì¹­ë˜ëŠ” ')' ì°¾ìŒ
                    content = cast_str[content_start:i].strip()
                    return content
        
        return None

    def transform_function(self, func):
        """í•¨ìˆ˜ë¥¼ ê²€ì¦ ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜ (v1.6 ìœˆë„ìš° í•¨ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ê°œì„ )"""
        result = func
        
        if self.debug:
            print(f"ğŸ” ì›ë³¸ í•¨ìˆ˜: {func}")
        
        # 0-0. ì¤‘ì²© í•¨ìˆ˜ ë¶„ì„ (ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ)
        if self.debug:
            self.analyze_nested_functions(func)
        
        # 0-1. ìˆ«ì AS CHAR(255) íŒ¨í„´ì„ ìˆ«ìë§Œ ë‚¨ê¸°ë„ë¡ ì „ì²˜ë¦¬
        result = re.sub(r"(\d+)\s+AS\s+CHAR\(\d+\)", r"\1", result, flags=re.IGNORECASE)
        result = re.sub(r"'(\d+)'\s+AS\s+CHAR\(\d+\)", r"'\1'", result, flags=re.IGNORECASE)
        
        # 0-2. ì„œë¸Œì¿¼ë¦¬ ë‹¨ìˆœí™” (Window í•¨ìˆ˜ê°€ ì•„ë‹ ë•Œë§Œ) - sqlparse ì‚¬ìš©
        # OVERë‚˜ PARTITION í‚¤ì›Œë“œê°€ ì—†ëŠ” ê²½ìš°ì—ë§Œ ì„œë¸Œì¿¼ë¦¬ë¥¼ ë‹¨ìˆœí™”
        if 'OVER' not in result.upper() and 'PARTITION' not in result.upper():
            try:
                import sqlparse
                from sqlparse.sql import Statement, Parenthesis, IdentifierList
                from sqlparse.tokens import Keyword, Name
                
                def replace_subqueries_with_parser(sql_text):
                    """sqlparseë¥¼ ì‚¬ìš©í•˜ì—¬ ì„œë¸Œì¿¼ë¦¬ë¥¼ ì •í™•í•˜ê²Œ ì¹˜í™˜"""
                    try:
                        parsed = sqlparse.parse(sql_text)[0]
                        
                        def process_token(token):
                            if isinstance(token, Parenthesis):
                                # ê´„í˜¸ ì•ˆì˜ ë‚´ìš© í™•ì¸
                                inner_text = str(token).strip()
                                if inner_text.upper().startswith('(SELECT') or inner_text.upper().startswith('( SELECT'):
                                    # ì„œë¸Œì¿¼ë¦¬ì¸ ê²½ìš°
                                    # IN ì ˆì˜ ì„œë¸Œì¿¼ë¦¬ì¸ì§€ í™•ì¸í•˜ê¸° ìœ„í•´ ì´ì „ í† í°ë“¤ì„ í™•ì¸í•´ì•¼ í•˜ì§€ë§Œ
                                    # ê°„ë‹¨í•˜ê²Œ ëª¨ë“  ì„œë¸Œì¿¼ë¦¬ë¥¼ (1)ë¡œ ì¹˜í™˜
                                    return '(1)'
                                else:
                                    # ì„œë¸Œì¿¼ë¦¬ê°€ ì•„ë‹Œ ì¼ë°˜ ê´„í˜¸ëŠ” ë‚´ë¶€ í† í°ë“¤ì„ ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬
                                    processed_tokens = []
                                    for sub_token in token.tokens:
                                        processed_tokens.append(process_token(sub_token))
                                    return '(' + ''.join(processed_tokens) + ')'
                            else:
                                return str(token)
                        
                        # ëª¨ë“  í† í°ì„ ì²˜ë¦¬
                        processed_tokens = []
                        for token in parsed.tokens:
                            processed_tokens.append(process_token(token))
                        
                        return ''.join(processed_tokens)
                    except Exception as e:
                        if self.debug:
                            print(f"ğŸ” sqlparse ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}, ì •ê·œì‹ ì‚¬ìš©")
                        return sql_text
                
                result = replace_subqueries_with_parser(result)
                
            except ImportError:
                if self.debug:
                    print("ğŸ” sqlparse ì—†ìŒ, ì •ê·œì‹ ì‚¬ìš©")
                # sqlparseê°€ ì—†ëŠ” ê²½ìš° ê¸°ì¡´ ì •ê·œì‹ ì‚¬ìš©
                result = re.sub(r'IN\s*\(\s*SELECT\s+.*?\)', 'IN (1)', result, flags=re.IGNORECASE | re.DOTALL)
                result = re.sub(r'\(\s*SELECT\s+.*?\)', '1', result, flags=re.IGNORECASE | re.DOTALL)
        
        if self.debug:
            print(f"ğŸ” ì„œë¸Œì¿¼ë¦¬ ë‹¨ìˆœí™” í›„: {result}")
        
        # ë³µì¡í•œ í•¨ìˆ˜ í•„í„°ë§ ë¡œì§ ì‚­ì œ - ëª¨ë“  í•¨ìˆ˜ë¥¼ í…ŒìŠ¤íŠ¸ ëŒ€ìƒìœ¼ë¡œ í¬í•¨
        
        # 0. CAST í•¨ìˆ˜ ì²˜ë¦¬ (ê°€ì¥ ë¨¼ì €) - sqlparse ê¸°ë°˜ìœ¼ë¡œ ì •í™•í•œ êµ¬ì¡° íŒŒì•…
        result = self.process_cast_functions_with_parser(result)
        
        if self.debug:
            print(f"ğŸ” CAST í•¨ìˆ˜ ì²˜ë¦¬ í›„: {result}")
        
        # 1. AS ë³„ì¹­ ì œê±° - sqlparse ê¸°ë°˜ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
        result = self.remove_as_aliases_with_parser(result)
        
        # 2. ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸
        result = self.protect_string_literals(result)
        
        # 3. MyBatis íŒŒë¼ë¯¸í„° ì²˜ë¦¬ #{...} â†’ 1, ${...} â†’ 1
        result = re.sub(r'#\{[^}]*\}', '1', result)
        result = re.sub(r'\$\{[^}]*\}', '1', result)
        
    def transform_function_for_testing_with_parser(self, func):
        """íŒŒì„œ ê¸°ë°˜ìœ¼ë¡œ í•¨ìˆ˜ë¥¼ ì™„ì „íˆ ì²˜ë¦¬"""
        try:
            import sqlparse
            from sqlparse.sql import Statement, Function, Parenthesis, IdentifierList, Identifier
            from sqlparse.tokens import Keyword, Name, String, Number
            
            if self.debug:
                print(f"ğŸ” ì›ë³¸ í•¨ìˆ˜: {func}")
            
            # 1. íŒŒì„œë¡œ êµ¬ì¡° íŒŒì•…
            parsed = sqlparse.parse(func)[0]
            
            # 2. ì¤‘ì²© í•¨ìˆ˜ ë¶„ì„
            nested_funcs = self.analyze_nested_functions(func)
            if nested_funcs and self.debug:
                func_info = [f"{f['name']}(depth:{f['depth']})" for f in nested_funcs]
                print(f"ğŸ” íŒŒì„œ ê¸°ë°˜ ì²˜ë¦¬ ìˆœì„œ: {func_info}")
            
            def process_token_recursively(token):
                """í† í°ì„ ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬ (ì•ˆìª½ë¶€í„°)"""
                
                # ì„œë¸Œì¿¼ë¦¬ ì²˜ë¦¬: (SELECT ... FROM ...) â†’ (SELECT 1)
                if isinstance(token, Parenthesis):
                    inner_text = str(token).strip()
                    if inner_text.upper().startswith('(SELECT') or inner_text.upper().startswith('( SELECT'):
                        # FROM ì´í›„ ì œê±°í•˜ê³  SELECT 1ë¡œ ë³€ê²½
                        return '(SELECT 1)'
                
                # í•¨ìˆ˜ ì²˜ë¦¬ - í•¨ìˆ˜ëª…ì€ ë³´í˜¸, ë‚´ë¶€ íŒŒë¼ë¯¸í„°ë§Œ ì¬ê·€ ì²˜ë¦¬
                elif isinstance(token, Function):
                    func_name = str(token.get_name()).upper()
                    if func_name in self.mysql_reserved_words or func_name in self.all_functions:
                        # í•¨ìˆ˜ëª…ì€ ë³´í˜¸, ë‚´ë¶€ íŒŒë¼ë¯¸í„°ë§Œ ì²˜ë¦¬
                        processed_params = []
                        for sub_token in token.tokens:
                            processed_params.append(process_token_recursively(sub_token))
                        return ''.join(processed_params)
                
                # ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸
                elif token.ttype is String.Single or token.ttype is String.Symbol:
                    return str(token)  # ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸
                
                # ìˆ«ì ë¦¬í„°ëŸ´ ë³´í˜¸  
                elif token.ttype is Number.Integer or token.ttype is Number.Float:
                    return str(token)  # ìˆ«ì ë¦¬í„°ëŸ´ ë³´í˜¸
                
                # ì˜ˆì•½ì–´ ë³´í˜¸ (CASE, WHEN, THEN, ELSE, END í¬í•¨)
                elif token.ttype is Keyword:
                    keyword = str(token).upper()
                    if keyword in self.mysql_reserved_words:
                        return str(token)  # ì˜ˆì•½ì–´ ë³´í˜¸
                
                # ì‹ë³„ì (ì»¬ëŸ¼ëª…, í…Œì´ë¸”ëª…) â†’ 1ë¡œ ì¹˜í™˜ (ì•ˆìª½ë¶€í„°)
                elif isinstance(token, Identifier) or token.ttype is Name:
                    name = str(token).upper()
                    # CASE ë¬¸ í‚¤ì›Œë“œëŠ” ë³´í˜¸
                    if name in ['CASE', 'WHEN', 'THEN', 'ELSE', 'END']:
                        return str(token)
                    elif name not in self.mysql_reserved_words and name not in self.all_functions:
                        return '1'  # ì»¬ëŸ¼ëª…/í…Œì´ë¸”ëª… ì¹˜í™˜
                
                # í•˜ìœ„ í† í°ì´ ìˆëŠ” ê²½ìš° ì¬ê·€ ì²˜ë¦¬ (ì•ˆìª½ë¶€í„°)
                elif hasattr(token, 'tokens'):
                    # CASE ë¬¸ì¸ì§€ í™•ì¸
                    token_str = str(token).upper().strip()
                    if token_str.startswith('CASE'):
                        # CASE ë¬¸ì€ ë‚´ë¶€ êµ¬ì¡°ë¥¼ ë³´ì¡´í•˜ë©´ì„œ ì²˜ë¦¬
                        processed_tokens = []
                        for sub_token in token.tokens:
                            processed_tokens.append(process_token_recursively(sub_token))
                        return ''.join(processed_tokens)
                    else:
                        # ì¼ë°˜ì ì¸ ê²½ìš°
                        processed_tokens = []
                        for sub_token in token.tokens:
                            processed_tokens.append(process_token_recursively(sub_token))
                        return ''.join(processed_tokens)
                
                # ê¸°ë³¸: í† í° ê·¸ëŒ€ë¡œ ë°˜í™˜
                return str(token)
            
            # 3. íŒŒì„œë¡œ ì „ì²´ ì²˜ë¦¬
            result = process_token_recursively(parsed)
            
            if self.debug:
                print(f"ğŸ” íŒŒì„œ ì²˜ë¦¬ ê²°ê³¼: {result}")
            
            return result
            
        except Exception as e:
            if self.debug:
                print(f"ğŸ” íŒŒì„œ ì²˜ë¦¬ ì˜¤ë¥˜: {e}, ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©")
            return self.transform_function_for_testing(func)
        
        # 5. IN 1 â†’ IN (1, 2, 3)
        result = re.sub(r'IN\s+1\b', 'IN (1, 2, 3)', result, flags=re.IGNORECASE)
        
        # 6. í…Œì´ë¸”.ì»¬ëŸ¼ â†’ 1 (ëŒ€ë¬¸ì/ì†Œë¬¸ì ì»¬ëŸ¼ëª… ëª¨ë‘ í¬í•¨)
        result = re.sub(r'\b[A-Z][A-Z0-9_]*\.[a-z_][a-z0-9_]*\b', '1', result)
        result = re.sub(r'\b[A-Z][A-Z0-9_]*\.[A-Z_][A-Z0-9_]*\b', '1', result)
        result = re.sub(r'\b[a-z_][a-z0-9_]*\.[a-z_][a-z0-9_]*\b', '1', result)
        result = re.sub(r'\b[a-z_][a-z0-9_]*\.[A-Z_][A-Z0-9_]*\b', '1', result)
        # í˜¼í•© ì¼€ì´ìŠ¤ ì»¬ëŸ¼ëª… ì²˜ë¦¬ (ì˜ˆ: rsv_SALE_AMT)
        result = re.sub(r'\b[a-z_][a-z0-9_]*\.[a-z_][a-zA-Z0-9_]*\b', '1', result)
        
        # 7. ëŒ€ë¬¸ì ì»¬ëŸ¼ëª… â†’ 1 (í•¨ìˆ˜ëª…ê³¼ ì˜ˆì•½ì–´ ì œì™¸) - ì˜ˆì•½ì–´ ë³´í˜¸ ê°•í™”
        for word in re.findall(r'\b[A-Z][A-Z0-9_]+\b', result):
            if word not in self.all_functions and word.upper() not in self.mysql_reserved_words:
                if not re.search(rf'\b{word}\s*\(', result):
                    # ì˜ˆì•½ì–´ê°€ ì•„ë‹Œ ê²½ìš°ë§Œ ì¹˜í™˜
                    result = re.sub(rf'\b{word}\b(?!\s*\()', '1', result)
        
        # 8. ì»¬ëŸ¼ëª… â†’ 1 (í•¨ìˆ˜ëª…ê³¼ ì˜ˆì•½ì–´ ì œì™¸, ëŒ€ì†Œë¬¸ì ëª¨ë‘ í¬í•¨)
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸
        string_literals = []
        def protect_string(match):
            string_literals.append(match.group(0))
            return f"__STRING_LITERAL_{len(string_literals)-1}__"
        
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ì„ ì„ì‹œ í† í°ìœ¼ë¡œ ì¹˜í™˜ (ë¹ˆ ë¬¸ìì—´ í¬í•¨)
        result = re.sub(r"'[^']*'", protect_string, result)
        
        if self.debug and string_literals:
            print(f"ğŸ”§ ê°œë³„ í•¨ìˆ˜ ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸: {len(string_literals)}ê°œ")
            for i, literal in enumerate(string_literals):
                print(f"  {i}: {literal}")
            print(f"ë³´í˜¸ í›„: {result}")
        elif self.debug:
            print(f"ğŸ”§ ê°œë³„ í•¨ìˆ˜ ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸: 0ê°œ (ì›ë³¸: {result[:100]}...)")
        
        words = re.findall(r'\b[A-Za-z_][A-Za-z0-9_]*\b', result)
        for word in words:
            if word.upper() not in self.all_functions and word.upper() not in self.mysql_reserved_words:
                if not re.search(rf'\b{word}\s*\(', result):
                    # ì„ì‹œ í† í°ì´ ì•„ë‹Œ ê²½ìš°ë§Œ ì¹˜í™˜ (__STRING_LITERAL_, __SSTRING_ í† í° ë³´í˜¸)
                    if (not word.startswith('__STRING_LITERAL_') and 
                        not word.startswith('__SSTRING_')):
                        # ì˜ˆì•½ì–´ ë³´í˜¸ë¥¼ ê³ ë ¤í•œ ì•ˆì „í•œ ì»¬ëŸ¼ëª… ì¹˜í™˜
                        pattern = rf'\b{re.escape(word)}\b(?!\s*\()'
                        def replace_with_space_preservation(match):
                            return '1'
                        result = re.sub(pattern, replace_with_space_preservation, result)
        
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³µì›
        for i, literal in enumerate(string_literals):
            result = result.replace(f"__STRING_LITERAL_{i}__", literal)
        
        if self.debug:
            print(f"ğŸ” ì»¬ëŸ¼ëª… ì¹˜í™˜ í›„: {result}")
        
        # 9. íŠ¹ë³„ í•¨ìˆ˜ ì²˜ë¦¬ (CAST, ìœˆë„ìš° í•¨ìˆ˜, Oracle í•¨ìˆ˜) - ì„ì‹œ ë¹„í™œì„±í™”
        # result = self.parser.fix_special_functions(result)
        
        # CAST í•¨ìˆ˜ ì²˜ë¦¬ëŠ” ì´ë¯¸ ì•ì—ì„œ ì™„ë£Œë¨
        
        if self.debug:
            print(f"ğŸ” íŠ¹ë³„ í•¨ìˆ˜ ì²˜ë¦¬ í›„: {result}")
        
        # 8.5. ìœˆë„ìš° í•¨ìˆ˜ ìœ„ì¹˜ í‘œì‹œ ë¬¸ì œ í•´ê²° (3592 ì˜¤ë¥˜ ë°©ì§€)
        # PARTITION BY (SELECT NULL), 1 â†’ PARTITION BY (SELECT NULL), (SELECT NULL)
        # ORDER BY (SELECT NULL), 1 â†’ ORDER BY (SELECT NULL), (SELECT NULL)
        result = re.sub(r'(PARTITION\s+BY\s+\([^)]+\)),\s*1\b', r'\1, (SELECT NULL)', result, flags=re.IGNORECASE)
        result = re.sub(r'(ORDER\s+BY\s+\([^)]+\)),\s*1\b', r'\1, (SELECT NULL)', result, flags=re.IGNORECASE)
        
        # 9. ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³µì› (ê°€ì¥ ë‚˜ì¤‘)
        result = self.restore_string_literals(result)
        
        if self.debug:
            print(f"ğŸ” ìµœì¢… ê²°ê³¼: {result}")
            print()
        
        return result.strip()
    
    def get_mysql_connection(self):
        """MySQL ì—°ê²° ìƒì„±"""
        try:
            connection = mysql.connector.connect(
                host=os.getenv('MYSQL_HOST', 'localhost'),
                port=int(os.getenv('MYSQL_PORT', '3306')),
                user=os.getenv('MYSQL_USER', 'root'),
                password=os.getenv('MYSQL_PASSWORD', ''),
                database=os.getenv('MYSQL_DATABASE', 'devdb'),
                charset='utf8mb4',
                collation='utf8mb4_unicode_ci'
            )
            return connection
        except mysql.connector.Error as e:
            error_msg = f"MySQL ì—°ê²° ì‹¤íŒ¨: {e}"
            return connection, error_msg
    
    def validate_functions_batch(self, unique_functions, logger):
        """ë³€í™˜ëœ í•¨ìˆ˜ë“¤ì„ ì¼ê´„ ê²€ì¦"""
        if not unique_functions:
            return False, "ê²€ì¦í•  í•¨ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤", ""
        
        connection_result = self.get_mysql_connection()
        if isinstance(connection_result, tuple):
            connection, error_msg = connection_result
            logger.error(error_msg)
            return False, error_msg, ""
        
        connection = connection_result
        
        try:
            cursor = connection.cursor()
            
            # SELECT ì ˆ ìƒì„±
            select_sql = "SELECT " + ", ".join(unique_functions)
            
            logger.info(f"ìƒì„±ëœ SELECT ë¬¸: {select_sql}")
            
            if self.debug:
                print(f"\nğŸ” DEBUG - ìƒì„±ëœ SELECT ë¬¸:")
                print(f"{select_sql}")
                print()
            
            # SQL ìˆ˜í–‰ ì „ ë§ˆì§€ë§‰ ì •ë¦¬: AS 1 íŒ¨í„´ ì œê±° (ë¬¸ë²• ì˜¤ë¥˜ ë°©ì§€)
            select_sql = self.clean_sql_before_execution(select_sql)
            
            # ì‹¤í–‰
            cursor.execute(select_sql)
            result = cursor.fetchall()
            
            cursor.close()
            connection.close()
            
            success_msg = f"ì„±ê³µ: {len(unique_functions)}ê°œ í•¨ìˆ˜ ëª¨ë‘ ê²€ì¦ ì™„ë£Œ"
            logger.info(success_msg)
            
            return True, success_msg, select_sql
            
        except mysql.connector.Error as e:
            if connection:
                connection.close()
            error_msg = f"SQL ì˜¤ë¥˜: {e}"
            logger.error(error_msg)
            return False, error_msg, select_sql if 'select_sql' in locals() else ""
    
    def clean_sql_before_execution(self, sql):
        """SQL ìˆ˜í–‰ ì „ ë§ˆì§€ë§‰ ì •ë¦¬: ë‹¤ì–‘í•œ ë¬¸ë²• ì˜¤ë¥˜ íŒ¨í„´ ìˆ˜ì •"""
        original_sql = sql
        
        # 0. WITH ì ˆ ì™„ì „ ì œê±° (CTE ì œê±°)
        # WITH ... AS (...) íŒ¨í„´ì„ ëª¨ë‘ ì œê±°í•˜ì—¬ í•¨ìˆ˜ë§Œ ë‚¨ê¹€
        def remove_with_clause(sql_text):
            """WITH ì ˆê³¼ CTEë¥¼ ì™„ì „íˆ ì œê±°"""
            # WITHë¡œ ì‹œì‘í•˜ëŠ” ë¶€ë¶„ë¶€í„° ë©”ì¸ SELECTê¹Œì§€ ì°¾ê¸°
            with_pattern = r'\bWITH\s+.*?(?=\bSELECT\s+(?!.*\bFROM\s+\w+\s+AS\s*\())'
            
            # WITH ì ˆì´ ìˆëŠ”ì§€ í™•ì¸
            if re.search(r'\bWITH\s+', sql_text, re.IGNORECASE | re.DOTALL):
                # WITH ì ˆ ì „ì²´ë¥¼ ì œê±°í•˜ê³  ë§ˆì§€ë§‰ SELECTë§Œ ë‚¨ê¹€
                # ë³µì¡í•œ íŒ¨í„´ ë§¤ì¹­ ëŒ€ì‹  ë‹¨ìˆœí•˜ê²Œ ì²˜ë¦¬
                lines = sql_text.split('\n')
                in_with_section = False
                main_select_found = False
                result_lines = []
                
                for line in lines:
                    line_upper = line.strip().upper()
                    
                    # WITH ì ˆ ì‹œì‘ ê°ì§€
                    if line_upper.startswith('WITH ') or (in_with_section and ',' in line and 'AS (' in line.upper()):
                        in_with_section = True
                        continue
                    
                    # CTE ì •ì˜ ë¶€ë¶„ ìŠ¤í‚µ
                    if in_with_section and not line_upper.startswith('SELECT '):
                        continue
                    
                    # ë©”ì¸ SELECT ë°œê²¬
                    if in_with_section and line_upper.startswith('SELECT '):
                        in_with_section = False
                        main_select_found = True
                    
                    # WITH ì ˆì´ ì—†ê±°ë‚˜ ë©”ì¸ SELECT ì´í›„ì˜ ë¼ì¸ë“¤ ìœ ì§€
                    if not in_with_section:
                        result_lines.append(line)
                
                return '\n'.join(result_lines)
            
            return sql_text
        
        sql = remove_with_clause(sql)
        
        if self.debug:
            print(f"ğŸ”§ WITH ì ˆ ì œê±° í›„: {len(sql)} ë¬¸ì")
            print(f"ì²˜ë¦¬ëœ SQL ì‹œì‘: {sql[:200]}...")
            print()

        # 0. ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸
        string_literals = []
        def protect_string(match):
            string_literals.append(match.group(0))
            return f"__STRING_LITERAL_{len(string_literals)-1}__"
        
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ì„ ì„ì‹œ í† í°ìœ¼ë¡œ ì¹˜í™˜
        sql = re.sub(r"'[^']*'", protect_string, sql)
        
        if self.debug:
            print(f"ğŸ”§ ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸ í›„: {len(string_literals)}ê°œ ë³´í˜¸ë¨")
            for i, literal in enumerate(string_literals):
                print(f"  {i}: {literal}")
            print(f"ë³´í˜¸ëœ SQL: {sql[:200]}...")
            print()
        
        # 0.5. AND ì—°ì‚°ì ëˆ„ë½ íŒ¨í„´ ìˆ˜ì • (ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³´í˜¸ í›„)
        sql = self.fix_missing_and_operators(sql)
        
        # 0.6. ë³µì¡í•œ ì¤‘ì²© CASE ë¬¸ ë‹¨ìˆœí™”
        # íŠ¹ì • ë¬¸ì œ íŒ¨í„´ë“¤ì„ ì§ì ‘ ìˆ˜ì •
        sql = re.sub(r'THEN\s+IFNULL\s*\([^)]+\)\s+(\d+)\s+END', r'THEN 1 ELSE 1 END', sql, flags=re.IGNORECASE)
        
        # 3ì¤‘ ì´ìƒ ì¤‘ì²©ëœ CASE ë¬¸ì„ ë‹¨ìˆœí•œ IFNULL(1,0)ìœ¼ë¡œ ì¹˜í™˜
        if sql.count('CASE WHEN') >= 3:
            # ë³µì¡í•œ ì¤‘ì²© CASE ë¬¸ì„ ì°¾ì•„ì„œ ë‹¨ìˆœí™”
            complex_case_pattern = r'IFNULL\s*\(\s*\(\s*CASE\s+WHEN.*?END\s*\)\s*,\s*0\s*\)'
            if re.search(complex_case_pattern, sql, re.IGNORECASE | re.DOTALL):
                if self.debug:
                    print(f"ğŸ” ë³µì¡í•œ ì¤‘ì²© CASE ë¬¸ ë°œê²¬, ë‹¨ìˆœí™” ì²˜ë¦¬")
                sql = re.sub(complex_case_pattern, 'IFNULL(1,0)', sql, flags=re.IGNORECASE | re.DOTALL)
        
        # 1. AS 1, AS 2, AS 3 ë“±ì˜ íŒ¨í„´ì„ ì œê±° (ìˆ«ìë§Œ ìˆëŠ” ë³„ì¹­)
        sql = re.sub(r'(\w+)\s*AS\s+\d+(?=\s*[,)$])', r'\1', sql, flags=re.IGNORECASE)
        sql = re.sub(r'\s*AS\s*\d+(?=\s*[,)$])', '', sql, flags=re.IGNORECASE)
        sql = re.sub(r'AS\s*\d+(?=\s*[,)$])', '', sql, flags=re.IGNORECASE)
        # ë¬¸ì¥ ëì˜ AS ìˆ«ì íŒ¨í„´ë„ ì œê±°
        sql = re.sub(r'\s*AS\s+\d+\s*$', '', sql, flags=re.IGNORECASE)
        
        # 2. Window Function ë‚´ë¶€ì˜ PARTITION BY 1 ORDER BY 1 íŒ¨í„´ ìˆ˜ì •
        # ê´„í˜¸ ë§¤ì¹­ì„ ê³ ë ¤í•œ ì •í™•í•œ OVER ì ˆ ì²˜ë¦¬
        def replace_over_with_partition(sql_text):
            """OVER ì ˆì—ì„œ PARTITION BY 1ì´ í¬í•¨ëœ ë¶€ë¶„ì„ ì°¾ì•„ ë‹¨ìˆœí™”"""
            result = sql_text
            start_pos = 0
            
            while True:
                # OVER ( íŒ¨í„´ ì°¾ê¸°
                over_match = re.search(r'OVER\s*\(', result[start_pos:], re.IGNORECASE)
                if not over_match:
                    break
                
                over_start = start_pos + over_match.start()
                paren_start = start_pos + over_match.end() - 1  # '(' ìœ„ì¹˜
                
                # ê´„í˜¸ ë§¤ì¹­ìœ¼ë¡œ OVER ì ˆì˜ ë ì°¾ê¸°
                paren_count = 1
                pos = paren_start + 1
                while pos < len(result) and paren_count > 0:
                    if result[pos] == '(':
                        paren_count += 1
                    elif result[pos] == ')':
                        paren_count -= 1
                    pos += 1
                
                if paren_count == 0:
                    # OVER ì ˆ ì „ì²´ ì¶”ì¶œ
                    over_clause = result[over_start:pos]
                    
                    # PARTITION BY 1 ë˜ëŠ” ORDER BY 1ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ë‹¨ìˆœí™”
                    if re.search(r'(PARTITION\s+BY\s+1|ORDER\s+BY\s+1)', over_clause, re.IGNORECASE):
                        result = result[:over_start] + 'OVER ()' + result[pos:]
                        start_pos = over_start + len('OVER ()')
                    else:
                        start_pos = pos
                else:
                    break
            
            return result
        
        sql = replace_over_with_partition(sql)
        
        # 3. ìœˆë„ìš° í•¨ìˆ˜ ë‚´ë¶€ì˜ ORDER BY ì»¬ëŸ¼ëª… ì¹˜í™˜
        # MySQL ìœˆë„ìš° í•¨ìˆ˜ì—ì„œëŠ” ORDER BY ìœ„ì¹˜ ì§€ì •ì„ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ OVER()ë¡œ ë‹¨ìˆœí™”
        sql = re.sub(r'OVER\s*\(\s*ORDER\s+BY\s+[A-Za-z_][A-Za-z0-9_]*\s*\)', 'OVER ()', sql, flags=re.IGNORECASE)
        sql = re.sub(r'OVER\s*\(\s*PARTITION\s+BY\s+[^)]+\s+ORDER\s+BY\s+[A-Za-z_][A-Za-z0-9_]*\s*\)', 'OVER ()', sql, flags=re.IGNORECASE)
        
        # 4. ì¼ë°˜ì ì¸ ORDER BY ì²˜ë¦¬ (Window Function ë°–ì—ì„œ)
        # ë¬¸ì¥ ëì´ë‚˜ GROUP BY, HAVING, LIMIT ì•ì˜ ORDER BYë§Œ ì²˜ë¦¬
        sql = re.sub(r'\bORDER\s+BY\s+\d+(?:\s*,\s*\d+)*(?=\s*(?:$|GROUP\s+BY|HAVING|LIMIT|;))', 'ORDER BY (SELECT NULL)', sql, flags=re.IGNORECASE)
        sql = re.sub(r'\bORDER\s+BY\s+[A-Za-z_][A-Za-z0-9_]*(?:\s*,\s*[A-Za-z_][A-Za-z0-9_]*)*(?=\s*(?:$|GROUP\s+BY|HAVING|LIMIT|;))', 'ORDER BY (SELECT NULL)', sql, flags=re.IGNORECASE)
        
        # 4. ë¹ˆ THEN ì ˆ ì²˜ë¦¬ (MyBatis ì¡°ê±´ë¬¸ìœ¼ë¡œ ì¸í•œ ë¹ˆ THEN ì ˆ)
        # CASE WHEN ... THEN [ê³µë°±/íƒ­/ì¤„ë°”ê¿ˆë§Œ] ELSE ... END íŒ¨í„´ì„ ì°¾ì•„ì„œ ìˆ˜ì •
        # ë” ì •í™•í•œ íŒ¨í„´ìœ¼ë¡œ ìˆ˜ì •
        sql = re.sub(r'THEN\s*\n?\s*\t*\s*\n?\s*\t*\s*ELSE', 'THEN NULL ELSE', sql, flags=re.IGNORECASE | re.MULTILINE)
        
        # 5. CAST í•¨ìˆ˜ íŒ¨í„´ ìˆ˜ì • - sqlparse ê¸°ë°˜ìœ¼ë¡œ ì²˜ë¦¬
        sql = self.process_cast_functions_with_parser(sql)
        
        # 5. í…Œì´ë¸”ë³„ì¹­.ê³µë°±ì»¬ëŸ¼ íŒ¨í„´ ìˆ˜ì • (ì˜ˆ: B. 1 â†’ B.column, A. 2 â†’ A.column)
        sql = re.sub(r'\b([A-Za-z_][A-Za-z0-9_]*)\.\s+(\d+)', r'\1.column\2', sql)
        
        # 6. ë¹ˆ IFNULL íŒŒë¼ë¯¸í„° ì²˜ë¦¬ (MyBatis ì¡°ê±´ë¬¸ìœ¼ë¡œ ì¸í•œ í•¨ìˆ˜ ë¶„í•  ì˜ˆì™¸ ì²˜ë¦¬)
        # IFNULL(,0) â†’ IFNULL(1,0), IFNULL( \n\t ,0) â†’ IFNULL(1,0)
        sql = re.sub(r'IFNULL\s*\(\s*,', 'IFNULL(1,', sql, flags=re.IGNORECASE)
        sql = re.sub(r'IFNULL\s*\(\s*\n\s*\t*\s*\n\s*\t*\s*,', 'IFNULL(1,', sql, flags=re.IGNORECASE | re.MULTILINE)
        
        # 7. XML ì£¼ì„ ì œê±° (<!-- ... -->)
        sql = re.sub(r'<!--.*?-->', '', sql, flags=re.DOTALL)
        
        # 8. SQL ì£¼ì„ ì œê±° (-- ì£¼ì„) - ì£¼ì„ ì œê±° í›„ ê³µë°± ì •ë¦¬
        sql = re.sub(r'--[^\r\n]*', ' ', sql)
        sql = re.sub(r'\s+', ' ', sql)  # ì—°ì†ëœ ê³µë°±ì„ í•˜ë‚˜ë¡œ ì •ë¦¬
        
        # 9. EXISTS 1 â†’ EXISTS (SELECT 1) íŒ¨í„´ ìˆ˜ì •
        sql = re.sub(r'\bEXISTS\s+(\d+)', r'EXISTS (SELECT \1)', sql, flags=re.IGNORECASE)
        
        # 10. SUBSTRING position from ë¬¸ë²•ì„ MySQL ë¬¸ë²•ìœ¼ë¡œ ë³€ê²½
        # SUBSTRING(str position from pos for len) â†’ SUBSTRING(str, pos, len)
        sql = re.sub(r'\bSUBSTRING\s*\(\s*([^)]+?)\s+position\s+from\s+([^)]+?)\s+([^)]+?)\s*\)', 
                    r'SUBSTRING(\1, \2, \3)', sql, flags=re.IGNORECASE)
        
        # 11. ì˜ëª»ëœ SUBSTRING íŒ¨í„´ ìˆ˜ì • (SUBSTRING (1 position from 0 1 1))
        sql = re.sub(r'\bSUBSTRING\s*\(\s*(\d+)\s+position\s+from\s+(\d+)\s+(\d+)\s+(\d+)\s*\)', 
                    r'SUBSTRING(\1, \2, \3)', sql, flags=re.IGNORECASE)
        
        # 12. ì†Œìˆ˜ì  íŒ¨í„´ ìˆ˜ì • (IFNULL(1. 1,0) â†’ IFNULL(1.1,0))
        sql = re.sub(r'(\d+)\.\s+(\d+)', r'\1.\2', sql)
        
        # 13. ì—°ì‚°ì ì£¼ë³€ ê³µë°± ì •ë¦¬
        sql = re.sub(r'\s*\.\s*', '.', sql)  # ì  ì—°ì‚°ì ì£¼ë³€ ê³µë°± ì œê±°
        
        # 14. ìŠ¤í‚¤ë§ˆ/í…Œì´ë¸”ë³„ì¹­ ì œê±° (ì˜ì–´.ìˆ«ì ë˜ëŠ” ì˜ì–´.ì˜ì–´ íŒ¨í„´)
        # ì˜ˆ: B.column1 â†’ 1, schema.table â†’ 1
        # ë‹¨, GROUPING í•¨ìˆ˜ ë‚´ë¶€ëŠ” íŠ¹ë³„ ì²˜ë¦¬
        
        # GROUPING í•¨ìˆ˜ ë‚´ë¶€ë¥¼ ì„ì‹œë¡œ ë³´í˜¸
        grouping_patterns = []
        def protect_grouping(match):
            grouping_patterns.append(match.group(1))  # ê´„í˜¸ ì•ˆì˜ ë‚´ìš© ì €ì¥
            return f"GROUPING(__GROUPING_PARAM_{len(grouping_patterns)-1}__)"
        
        sql = re.sub(r'GROUPING\s*\(([^)]+)\)', protect_grouping, sql, flags=re.IGNORECASE)
        
        # ì¼ë°˜ì ì¸ ìŠ¤í‚¤ë§ˆ/í…Œì´ë¸”ë³„ì¹­ ì œê±°
        sql = re.sub(r'\b[A-Za-z_][A-Za-z0-9_]*\.[A-Za-z_][A-Za-z0-9_]*', '1', sql)
        sql = re.sub(r'\b[A-Za-z_][A-Za-z0-9_]*\.', '', sql)
        
        # GROUPING í•¨ìˆ˜ ë³µì› (íŒŒë¼ë¯¸í„°ëŠ” NULLë¡œ ë³€ê²½)
        for i, original_param in enumerate(grouping_patterns):
            sql = sql.replace(f"GROUPING(__GROUPING_PARAM_{i}__)", "GROUPING(NULL)")
        
        # 15. ë‹¨ìˆœ ì»¬ëŸ¼ëª…ë„ 1ë¡œ ì¹˜í™˜ (í•¨ìˆ˜ëª…ì´ ì•„ë‹Œ ê²½ìš°)
        # í•¨ìˆ˜ ë‚´ë¶€ì˜ ì»¬ëŸ¼ëª…ì„ 1ë¡œ ì¹˜í™˜ (ì˜ˆ: SUM(SALE_DSCNT_AMT) â†’ SUM(1))
        # ë‹¨, í•¨ìˆ˜ëª… ìì²´ëŠ” ë³´í˜¸
        def replace_column_in_function(match):
            func_name = match.group(1)
            params = match.group(2)
            # íŒŒë¼ë¯¸í„° ë‚´ì˜ ì»¬ëŸ¼ëª…ì„ 1ë¡œ ì¹˜í™˜
            # ìˆ«ì, ë¬¸ìì—´ ë¦¬í„°ëŸ´, NULLì€ ë³´í˜¸
            params_replaced = re.sub(r'\b(?!NULL\b|__STRING_LITERAL_\d+__\b)\d*[A-Za-z_][A-Za-z0-9_]*\b(?!\s*\()', '1', params, flags=re.IGNORECASE)
            return f"{func_name}({params_replaced})"
        
        # ëª¨ë“  í•¨ìˆ˜ ë‚´ë¶€ì˜ ì»¬ëŸ¼ëª… ì¹˜í™˜
        for func in self.all_functions:
            pattern = rf'\b({func})\s*\(([^)]+)\)'
            sql = re.sub(pattern, replace_column_in_function, sql, flags=re.IGNORECASE)
        
        
        # 16. ì„œë¸Œì¿¼ë¦¬ ë‚´ì˜ FROM ì ˆ ì™„ì „ ì œê±°
        # (SELECT ... FROM table_name ...) â†’ (SELECT 1)
        # ì„œë¸Œì¿¼ë¦¬ë¥¼ ë‹¨ìˆœí™”í•˜ì—¬ í…Œì´ë¸” ì˜ì¡´ì„± ì œê±°
        def simplify_subquery(match):
            subquery = match.group(0)
            # SELECTì™€ FROM ì‚¬ì´ì˜ ëª¨ë“  ë‚´ìš©ì„ 1ë¡œ êµì²´
            simplified = re.sub(r'\(\s*SELECT\s+.*?\s+FROM\s+[^)]+\)', '(SELECT 1)', subquery, flags=re.IGNORECASE | re.DOTALL)
            return simplified
        
        # ëª¨ë“  ì„œë¸Œì¿¼ë¦¬ë¥¼ (SELECT 1)ë¡œ ë‹¨ìˆœí™” (ì¤‘ì²© ì„œë¸Œì¿¼ë¦¬ë„ ì²˜ë¦¬)
        # ì—¬ëŸ¬ ë²ˆ ë°˜ë³µí•˜ì—¬ ì¤‘ì²©ëœ ì„œë¸Œì¿¼ë¦¬ê¹Œì§€ ëª¨ë‘ ì²˜ë¦¬
        for _ in range(5):  # ìµœëŒ€ 5ë‹¨ê³„ ì¤‘ì²©ê¹Œì§€ ì²˜ë¦¬
            old_sql = sql
            sql = re.sub(r'\(\s*SELECT\s+[^)]+\)', simplify_subquery, sql, flags=re.IGNORECASE | re.DOTALL)
            if sql == old_sql:  # ë” ì´ìƒ ë³€ê²½ì´ ì—†ìœ¼ë©´ ì¤‘ë‹¨
                break
        
        if self.debug:
            print(f"ğŸ”§ ì„œë¸Œì¿¼ë¦¬ ë‹¨ìˆœí™” ì™„ë£Œ")
            print(f"ë‹¨ìˆœí™”ëœ SQL: {sql[:300]}...")
            print()
        
        # 16-1. ì—­ë°œìƒ ë°©ì‹ìœ¼ë¡œ ì»¬ëŸ¼ êµì²´: ë³´í˜¸ ëŒ€ìƒì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ë¥¼ ëª¨ë‘ ì»¬ëŸ¼ìœ¼ë¡œ ì²˜ë¦¬
        
        if self.debug:
            print(f"ğŸ”§ ì»¬ëŸ¼ êµì²´ ì‹œì‘")
            print(f"ì›ë³¸ SQL (ì¼ë¶€): {sql[:200]}...")
        
        # 1ë‹¨ê³„: í•¨ìˆ˜ íŒ¨í„´ ë³´í˜¸ (ì‹ë³„ì ë’¤ì— ê´„í˜¸ê°€ ì˜¤ëŠ” ê²½ìš°)
        function_pattern = r'\b[A-Za-z][A-Za-z0-9_]*\s*\('
        functions = re.findall(function_pattern, sql, flags=re.IGNORECASE)
        function_placeholders = {}
        for i, func in enumerate(functions):
            placeholder = f'__FUNCTION_PLACEHOLDER_{i}__'
            function_placeholders[placeholder] = func
            sql = sql.replace(func, placeholder, 1)
        
        if self.debug:
            print(f"1ë‹¨ê³„ - í•¨ìˆ˜ ë³´í˜¸: {len(functions)}ê°œ í•¨ìˆ˜ ë°œê²¬")
            if functions:
                print(f"  í•¨ìˆ˜ë“¤: {functions[:5]}...")  # ì²˜ìŒ 5ê°œë§Œ ì¶œë ¥
        
        # 2ë‹¨ê³„: ì˜ˆì•½ì–´ ë° ì—°ì‚°ì ë³´í˜¸
        sql_keywords = [
            'SELECT', 'FROM', 'WHERE', 'AND', 'OR', 'NOT', 'IN', 'EXISTS', 'BETWEEN',
            'CASE', 'WHEN', 'THEN', 'ELSE', 'END', 'AS', 'IS', 'NULL', 'TRUE', 'FALSE',
            'UNION', 'ALL', 'DISTINCT', 'ORDER', 'BY', 'GROUP', 'HAVING', 'LIMIT',
            'JOIN', 'LEFT', 'RIGHT', 'INNER', 'OUTER', 'ON', 'USING',
            'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'DROP', 'ALTER', 'TABLE',
            'REGEXP', 'LIKE', 'RLIKE'  # ì—°ì‚°ì ì¶”ê°€
        ]
        
        keyword_placeholders = {}
        keyword_count = 0
        for i, keyword in enumerate(sql_keywords):
            pattern = r'\b' + keyword + r'\b'
            matches = re.findall(pattern, sql, flags=re.IGNORECASE)
            for j, match in enumerate(matches):
                placeholder = f'__KEYWORD_{i}_{j}__'
                keyword_placeholders[placeholder] = match
                sql = re.sub(pattern, placeholder, sql, count=1, flags=re.IGNORECASE)
                keyword_count += 1
        
        if self.debug:
            print(f"2ë‹¨ê³„ - ì˜ˆì•½ì–´ ë³´í˜¸: {keyword_count}ê°œ ì˜ˆì•½ì–´ ë³´í˜¸")
        
        # 3ë‹¨ê³„: ì„œë¸Œì¿¼ë¦¬ íŒ¨í„´ ë³´í˜¸ (ì´ë¯¸ ë‹¨ìˆœí™”ëœ (SELECT 1) í˜•íƒœ)
        subquery_pattern = r'\(\s*SELECT\s+[^)]*\)'
        subqueries = re.findall(subquery_pattern, sql, flags=re.IGNORECASE | re.DOTALL)
        subquery_placeholders = {}
        for i, subq in enumerate(subqueries):
            placeholder = f'__SUBQUERY_PLACEHOLDER_{i}__'
            subquery_placeholders[placeholder] = subq
            sql = sql.replace(subq, placeholder, 1)
        
        if self.debug:
            print(f"3ë‹¨ê³„ - ì„œë¸Œì¿¼ë¦¬ ë³´í˜¸: {len(subqueries)}ê°œ ì„œë¸Œì¿¼ë¦¬ ë³´í˜¸")
        
        # 4ë‹¨ê³„: ë‚˜ë¨¸ì§€ ëª¨ë“  ì‹ë³„ìë¥¼ ì»¬ëŸ¼ìœ¼ë¡œ ê°„ì£¼í•˜ì—¬ 1ë¡œ êµì²´
        # í…Œì´ë¸”ëª….ì»¬ëŸ¼ëª… íŒ¨í„´
        table_column_matches = re.findall(r'\b[A-Za-z][A-Za-z0-9_]*\.[A-Za-z][A-Za-z0-9_]*\b', sql, flags=re.IGNORECASE)
        sql = re.sub(r'\b[A-Za-z][A-Za-z0-9_]*\.[A-Za-z][A-Za-z0-9_]*\b', '1', sql, flags=re.IGNORECASE)
        
        # ë‹¨ë… ì‹ë³„ì (ì´ë¯¸ ë³´í˜¸ëœ ê²ƒë“¤ ì œì™¸)
        standalone_matches = re.findall(r'\b[A-Za-z][A-Za-z0-9_]+\b', sql, flags=re.IGNORECASE)
        sql = re.sub(r'\b[A-Za-z][A-Za-z0-9_]+\b', '1', sql, flags=re.IGNORECASE)
        
        if self.debug:
            print(f"4ë‹¨ê³„ - ì»¬ëŸ¼ êµì²´:")
            print(f"  í…Œì´ë¸”.ì»¬ëŸ¼ íŒ¨í„´: {len(table_column_matches)}ê°œ")
            print(f"  ë‹¨ë… ì‹ë³„ì: {len(standalone_matches)}ê°œ")
            if table_column_matches:
                print(f"  í…Œì´ë¸”.ì»¬ëŸ¼ ì˜ˆì‹œ: {table_column_matches[:3]}")
            if standalone_matches:
                print(f"  ë‹¨ë… ì‹ë³„ì ì˜ˆì‹œ: {standalone_matches[:5]}")
        
        # 5ë‹¨ê³„: ë³´í˜¸ëœ ìš”ì†Œë“¤ ë³µì›
        # ì„œë¸Œì¿¼ë¦¬ ë³µì›
        for placeholder, original in subquery_placeholders.items():
            sql = sql.replace(placeholder, original)
        
        # ì˜ˆì•½ì–´ ë³µì›
        for placeholder, original in keyword_placeholders.items():
            sql = sql.replace(placeholder, original)
        
        # í•¨ìˆ˜ ë³µì›
        for placeholder, original in function_placeholders.items():
            sql = sql.replace(placeholder, original)
        
        if self.debug:
            print(f"5ë‹¨ê³„ - ë³µì› ì™„ë£Œ")
            print(f"ìµœì¢… SQL (ì¼ë¶€): {sql[:200]}...")
            print()
        
        if self.debug:
            print(f"ğŸ”§ ì„œë¸Œì¿¼ë¦¬ ë‹¨ìˆœí™” ì™„ë£Œ")
            print(f"ë‹¨ìˆœí™”ëœ SQL: {sql[:300]}...")
            print()
        
        # 17. ë‚¨ì€ í…Œì´ë¸”ëª… íŒ¨í„´ ì œê±°
        # FROM table_name alias â†’ FROM (SELECT 1) AS t
        sql = re.sub(r'\bFROM\s+[A-Za-z_][A-Za-z0-9_]*(?:\s+[A-Za-z_][A-Za-z0-9_]*)?', 'FROM (SELECT 1) AS t', sql, flags=re.IGNORECASE)
        
        # 18. JOIN ì ˆì˜ í…Œì´ë¸”ëª…ë„ ì œê±°
        sql = re.sub(r'\b(?:LEFT\s+|RIGHT\s+|INNER\s+|OUTER\s+)?JOIN\s+[A-Za-z_][A-Za-z0-9_]*(?:\s+[A-Za-z_][A-Za-z0-9_]*)?', 'JOIN (SELECT 1) AS t', sql, flags=re.IGNORECASE)
        
        # 14. MySQL ì„œë¸Œì¿¼ë¦¬ì—ì„œ FROM ì ˆ ì—†ì´ WHEREë§Œ ìˆëŠ” ê²½ìš° ì²˜ë¦¬
        # WHERE 0 = 0 AND 1 = 1 â†’ (SELECT 1)
        sql = re.sub(r'WHERE\s+0\s*=\s*0\s+AND\s+1\s*=\s*1', '(SELECT 1)', sql, flags=re.IGNORECASE)
        sql = re.sub(r'WHERE\s+\d+\s*=\s*\d+', '(SELECT 1)', sql, flags=re.IGNORECASE)
        
        # 14. ë³µì¡í•œ ìˆ˜ì‹ì—ì„œ ê´„í˜¸ ë§¤ì¹­ ë¬¸ì œ í•´ê²°
        # CAST(...)*ìˆ«ì íŒ¨í„´ì—ì„œ ê´„í˜¸ê°€ ë§ì§€ ì•ŠëŠ” ê²½ìš°
        sql = re.sub(r'CAST\(([^)]+)\)\*(\d+)', r'(CAST(\1))*\2', sql, flags=re.IGNORECASE)
        
        # 15. ì˜ëª»ëœ ì—°ì‚°ì íŒ¨í„´ ìˆ˜ì •
        # 1. 1 â†’ 1.1 (ì†Œìˆ˜ì  í‘œê¸°)
        sql = re.sub(r'(\d+)\.\s+(\d+)', r'\1.\2', sql)
        
        # 16. ë¹ˆ ê´„í˜¸ë‚˜ ì˜ëª»ëœ ê´„í˜¸ íŒ¨í„´ ìˆ˜ì • (RANK() í•¨ìˆ˜ëŠ” ì œì™¸)
        # RANK(), ROW_NUMBER(), DENSE_RANK() ë“± ìœˆë„ìš° í•¨ìˆ˜ëŠ” ë³´í˜¸
        window_functions = ['RANK', 'ROW_NUMBER', 'DENSE_RANK', 'LEAD', 'LAG', 'FIRST_VALUE', 'LAST_VALUE']
        protected_patterns = []
        
        # ìœˆë„ìš° í•¨ìˆ˜ë“¤ì„ ì„ì‹œë¡œ ë³´í˜¸ (ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ì¸ë±ìŠ¤ ë³€ê²½ ë¬¸ì œ ë°©ì§€)
        for func in window_functions:
            pattern = rf'\b{func}\s*\(\s*\)'
            matches = list(re.finditer(pattern, sql, re.IGNORECASE))
            # ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ì¸ë±ìŠ¤ ë³€ê²½ ë¬¸ì œ ë°©ì§€
            for i, match in enumerate(reversed(matches)):
                placeholder = f'__WINDOW_FUNC_{func}_{len(matches)-1-i}__'
                protected_patterns.append((placeholder, match.group()))
                sql = sql[:match.start()] + placeholder + sql[match.end():]
        
        # í•¨ìˆ˜ëª…ì´ ì—†ëŠ” ë¹ˆ ê´„í˜¸ë§Œ ì²˜ë¦¬ (í•¨ìˆ˜ëª… ë’¤ì˜ ë¹ˆ ê´„í˜¸ëŠ” ë³´í˜¸)
        # ëª¨ë“  í•¨ìˆ˜ëª… ë’¤ì˜ ë¹ˆ ê´„í˜¸ë¥¼ ì„ì‹œë¡œ ë³´í˜¸
        function_empty_parens = []
        temp_sql = sql
        
        for func in self.all_functions:
            pattern = rf'\b{func}\s*\(\s*\)'
            matches = list(re.finditer(pattern, temp_sql, re.IGNORECASE))
            # ì—­ìˆœìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ ì¸ë±ìŠ¤ ë³€ê²½ ë¬¸ì œ ë°©ì§€
            for i, match in enumerate(reversed(matches)):
                placeholder = f'__FUNC_EMPTY_{func}_{len(matches)-1-i}__'
                function_empty_parens.append((placeholder, match.group()))
                temp_sql = temp_sql[:match.start()] + placeholder + temp_sql[match.end():]
        
        # ì´ì œ ë‚¨ì€ ë¹ˆ ê´„í˜¸ë§Œ ì²˜ë¦¬ (OVER() ë° OVER ( ) ì ˆì€ ì œì™¸)
        # OVER() ì ˆì€ MySQLì—ì„œ ìœ íš¨í•œ ë¬¸ë²•ì´ë¯€ë¡œ ë³€í™˜í•˜ì§€ ì•ŠìŒ
        # OVER ë’¤ì— ê³µë°±ì´ ìˆì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ ì´ë¥¼ ê³ ë ¤
        temp_sql = re.sub(r'(?<!OVER)(?<!\bOVER\s)\s*\(\s*\)', '(SELECT NULL)', temp_sql, flags=re.IGNORECASE)
        
        # í•¨ìˆ˜ëª… ë’¤ì˜ ë¹ˆ ê´„í˜¸ ë³µì›
        for placeholder, original in function_empty_parens:
            temp_sql = temp_sql.replace(placeholder, original)
        
        sql = temp_sql
        
        # ë³´í˜¸ëœ ìœˆë„ìš° í•¨ìˆ˜ë“¤ ë³µì›
        for placeholder, original in protected_patterns:
            sql = sql.replace(placeholder, original)
        
        # ë¬¸ìì—´ ë¦¬í„°ëŸ´ ë³µì›
        for i, literal in enumerate(string_literals):
            sql = sql.replace(f"__STRING_LITERAL_{i}__", literal)
        
        if self.debug and sql != original_sql:
            print(f"\nğŸ”§ SQL ì •ë¦¬ ì™„ë£Œ:")
            print(f"ì›ë³¸: ...{original_sql[-200:]}")
            print(f"ì •ë¦¬: ...{sql[-200:]}")
            print()
        
        return sql
    
    def save_result(self, result):
        """ê²°ê³¼ë¥¼ JSON íŒŒì¼ë¡œ ì €ì¥ (XMLFileNameì´ ê°™ì§€ ì•Šìœ¼ë©´ ì¶”ê°€)"""
        result_file = os.path.join(self.app_transform_folder, "sqlTestResult.json")
        
        # ê¸°ì¡´ ë°ì´í„° ë¡œë“œ
        existing_data = []
        if os.path.exists(result_file):
            try:
                with open(result_file, 'r', encoding='utf-8') as f:
                    content = f.read().strip()
                    if content:
                        existing_data = json.loads(content)
                        # ë‹¨ì¼ ê°ì²´ì¸ ê²½ìš° ë°°ì—´ë¡œ ë³€í™˜
                        if isinstance(existing_data, dict):
                            existing_data = [existing_data]
            except (json.JSONDecodeError, FileNotFoundError):
                existing_data = []
        
        # ìƒˆë¡œìš´ ê²°ê³¼ì˜ XMLFileName í™•ì¸ (file í•„ë“œì—ì„œ íŒŒì¼ëª… ì¶”ì¶œ)
        new_xml_filename = Path(result.get("file", "")).name
        
        # ê¸°ì¡´ ë°ì´í„°ì—ì„œ ê°™ì€ XMLFileNameì´ ìˆëŠ”ì§€ í™•ì¸
        found_index = -1
        for i, item in enumerate(existing_data):
            existing_xml_filename = Path(item.get("file", "")).name
            if existing_xml_filename == new_xml_filename:
                found_index = i
                break
        
        # ê°™ì€ XMLFileNameì´ ìˆìœ¼ë©´ êµì²´, ì—†ìœ¼ë©´ ì¶”ê°€
        if found_index >= 0:
            existing_data[found_index] = result
        else:
            existing_data.append(result)
        
        # íŒŒì¼ì— ì €ì¥
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(existing_data, f, ensure_ascii=False, indent=2)
    
    def save_failed_result(self, xml_file_path, status, test_sql, error_message):
        """ì‹¤íŒ¨í•œ ì¼€ì´ìŠ¤ë¥¼ ë³„ë„ JSON íŒŒì¼ì— append ëª¨ë“œë¡œ ì €ì¥"""
        failed_result_file = os.path.join(self.app_transform_folder, "sqlTestResultFailed.json")
        
        # Transform XML íŒŒì¼ëª… ì¶”ì¶œ
        transform_xml_filename = Path(xml_file_path).name
        
        # Origin XML íŒŒì¼ ê²½ë¡œ ìƒì„±
        origin_xml_file = self.get_origin_xml_file(xml_file_path)
        
        # ì‹¤íŒ¨ ê²°ê³¼ ë°ì´í„° êµ¬ì„±
        failed_result = {
            "TransformXMLFileName": transform_xml_filename,
            "Status": status,
            "TestSQL": test_sql,
            "SQLErrorMessage": error_message,
            "TransformXMLFile": xml_file_path,
            "OriginXMLFile": origin_xml_file,
            "timestamp": datetime.now().isoformat()
        }
        
        # ê¸°ì¡´ ì‹¤íŒ¨ ë°ì´í„° ë°°ì—´ ì½ê¸°
        try:
            if os.path.exists(failed_result_file):
                with open(failed_result_file, 'r', encoding='utf-8') as f:
                    failed_data = json.load(f)
                    if not isinstance(failed_data, list):
                        failed_data = []
            else:
                failed_data = []
        except (json.JSONDecodeError, FileNotFoundError):
            failed_data = []
        
        # ìƒˆ ì‹¤íŒ¨ ê²°ê³¼ ì¶”ê°€
        failed_data.append(failed_result)
        
        # ì „ì²´ ì‹¤íŒ¨ ë°°ì—´ì„ ë‹¤ì‹œ ì €ì¥
        with open(failed_result_file, 'w', encoding='utf-8') as f:
            json.dump(failed_data, f, ensure_ascii=False, indent=2)
    
    def get_origin_xml_file(self, xml_file_path):
        """ì›ë³¸ XML íŒŒì¼ ê²½ë¡œ ìƒì„± (transform->extract, tgt->src)"""
        path_str = str(xml_file_path)
        
        # transform -> extract ë³€ê²½
        origin_path = path_str.replace('/transform/', '/extract/')
        
        # tgt -> src ë³€ê²½
        origin_path = origin_path.replace('_tgt-', '_src-')
        
        return origin_path
    
    def setup_logger(self, xml_file_path):
        """ë¡œê±° ì„¤ì •"""
        # ë¡œê·¸ íŒŒì¼ëª… ìƒì„±
        xml_filename = Path(xml_file_path).stem  # .xml í™•ì¥ì ì œê±°
        log_filename = f"sqlTestResult_{xml_filename}.log"
        log_file_path = os.path.join(self.post_transform_log_dir, log_filename)
        
        # ë¡œê±° ì„¤ì •
        logger = logging.getLogger(f'sql_test_{xml_filename}')
        logger.setLevel(logging.INFO)
        
        # ê¸°ì¡´ í•¸ë“¤ëŸ¬ ì œê±°
        for handler in logger.handlers[:]:
            logger.removeHandler(handler)
        
        # íŒŒì¼ í•¸ë“¤ëŸ¬ ì¶”ê°€
        file_handler = logging.FileHandler(log_file_path, encoding='utf-8')
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        
        return logger, log_file_path
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        
        return logger, log_file_path
    
    def write_to_fixed_log(self, log_file_path, xml_file_path, status, message):
        """ê³ ì •ëœ ë¡œê·¸ íŒŒì¼ì— ê²°ê³¼ ê¸°ë¡"""
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            xml_filename = os.path.basename(xml_file_path)
            
            with open(log_file_path, 'a', encoding='utf-8') as log_file:
                log_file.write(f"[{timestamp}] {xml_filename}: {status} - {message}\n")
        except Exception as e:
            print(f"âš ï¸ ë¡œê·¸ íŒŒì¼ ê¸°ë¡ ì‹¤íŒ¨: {e}")
    
    def process_file(self, xml_file_path):
        """XML íŒŒì¼ ì²˜ë¦¬ ë©”ì¸ ë¡œì§"""
        # í†µí•© í…ŒìŠ¤íŠ¸ ë¡œê·¸ íŒŒì¼ ê²½ë¡œ
        FIXED_LOG_FILE = os.path.join(self.post_transform_log_dir, "sqlTestResult.log")
        
        try:
            # ë¡œê±° ì„¤ì •
            logger, log_file_path = self.setup_logger(xml_file_path)
            
            print("=" * 80)
            print("XML í•¨ìˆ˜ ê²€ì¦ (ì¼ê´„ í…ŒìŠ¤íŠ¸) - v1.6 ìœˆë„ìš° í•¨ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ê°œì„ ")
            print("=" * 80)
            print(f"ğŸ“ ì²˜ë¦¬ íŒŒì¼: {Path(xml_file_path).name}")
            print(f"ğŸ“ ë¡œê·¸ íŒŒì¼: {log_file_path}")
            
            # ì›ë³¸ XML íŒŒì¼ ê²½ë¡œ
            origin_xml_file = self.get_origin_xml_file(xml_file_path)
            logger.info(f"XML í•¨ìˆ˜ ê²€ì¦ ì‹œì‘: {xml_file_path}")
            logger.info(f"ì›ë³¸ XML íŒŒì¼: {origin_xml_file}")
            
            # 1. XML ë‚´ìš© ì¶”ì¶œ (íƒœê·¸ ì œê±° ì—†ì´)
            xml_content = self.extract_xml_content(xml_file_path)
            if xml_content.startswith("íŒŒì¼ ì½ê¸° ì˜¤ë¥˜"):
                error_message = xml_content
                logger.error(error_message)
                print(f"âŒ {error_message}")
                
                # ê³ ì • ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
                self.write_to_fixed_log(FIXED_LOG_FILE, xml_file_path, "ERROR", error_message)
                return
            
            # 2. ì›ë³¸ XMLì—ì„œ í•¨ìˆ˜ ë¦¬ìŠ¤íŠ¸ ì¶”ì¶œ (íƒœê·¸ ì œê±° ì „ì— ìˆ˜í–‰)
            original_functions = self.extract_functions_from_xml(xml_content)
            logger.info(f"ì¶”ì¶œëœ í•¨ìˆ˜ ê°œìˆ˜: {len(original_functions)}")
            print(f"ğŸ“Š ì¶”ì¶œëœ í•¨ìˆ˜ ê°œìˆ˜: {len(original_functions)}")
            
            # 3. íƒœê·¸ ì œê±°ëœ XML ë‚´ìš© ìƒì„± (SQL ìƒì„±ìš©)
            cleaned_xml_content = self.clean_xml_content(xml_content)
            
            if not original_functions:
                completed_message = "í•¨ìˆ˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
                logger.info(f"Completed: {completed_message}")
                print(f"âŒ {completed_message}")
                
                # ê³ ì • ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
                self.write_to_fixed_log(FIXED_LOG_FILE, xml_file_path, "NO_FUNCTIONS", completed_message)
                
                # ê²°ê³¼ ì €ì¥
                result = {
                    "file": xml_file_path,
                    "status": "completed",
                    "message": completed_message,
                    "functions_count": 0,
                    "unique_functions_count": 0,
                    "sql": "",
                    "timestamp": datetime.now().isoformat()
                }
                self.save_result(result)
                return
            
            # 3. í•¨ìˆ˜ ë³€í™˜ (íŒŒì„œ ê¸°ë°˜ ì²˜ë¦¬ ì‚¬ìš©)
            transformed_functions = [self.transform_function_for_testing_with_parser(func) for func in original_functions]
            
            # 4. ì¤‘ë³µ ì œê±° (None ê°’ í•„í„°ë§ í¬í•¨)
            unique_functions = []
            for func in transformed_functions:
                if func is not None and func not in unique_functions:
                    unique_functions.append(func)
            
            logger.info(f"ì¤‘ë³µ ì œê±° í›„ í•¨ìˆ˜ ê°œìˆ˜: {len(unique_functions)}")
            print(f"ğŸ“Š ì¤‘ë³µ ì œê±° í›„ í•¨ìˆ˜ ê°œìˆ˜: {len(unique_functions)}")
            print("ğŸ” MySQL í•¨ìˆ˜ ê²€ì¦ ì¤‘...")
            
            # 5. MySQL ì¼ê´„ ê²€ì¦
            success, message, sql = self.validate_functions_batch(unique_functions, logger)
            
            if success:
                print(f"âœ… {message}")
                result_status = "success"
                # ê³ ì • ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
                self.write_to_fixed_log(FIXED_LOG_FILE, xml_file_path, "SUCCESS", 
                                      f"{len(original_functions)} functions, {len(unique_functions)} unique")
            else:
                print(f"âŒ {message}")
                result_status = "failed"
                # ê³ ì • ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
                self.write_to_fixed_log(FIXED_LOG_FILE, xml_file_path, "FAILED", message)
                
                # ì‹¤íŒ¨í•œ ì¼€ì´ìŠ¤ë¥¼ ë³„ë„ JSON íŒŒì¼ì— ì €ì¥
                self.save_failed_result(xml_file_path, result_status, sql, message)
            
            # 6. ê²°ê³¼ ì €ì¥
            result = {
                "file": xml_file_path,
                "status": result_status,
                "message": message,
                "functions_count": len(original_functions),
                "unique_functions_count": len(unique_functions),
                "sql": sql,
                "timestamp": datetime.now().isoformat()
            }
            
            self.save_result(result)
            logger.info(f"ê²°ê³¼ íŒŒì¼ ì €ì¥: {os.path.join(self.app_transform_folder, 'sqlTestResult.json')}")
            print(f"ğŸ’¾ ê²°ê³¼ íŒŒì¼: {os.path.join(self.app_transform_folder, 'sqlTestResult.json')}")
            
        except Exception as e:
            error_message = f"ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}"
            print(f"âŒ {error_message}")
            if 'logger' in locals():
                logger.error(error_message)
            
            # ê³ ì • ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡
            self.write_to_fixed_log(FIXED_LOG_FILE, xml_file_path, "EXCEPTION", str(e))
            
            # ì˜ˆì™¸ ë°œìƒ ì¼€ì´ìŠ¤ë„ ì‹¤íŒ¨ JSONì— ì €ì¥
            self.save_failed_result(xml_file_path, "exception", "", error_message)
        
        print("\n" + "=" * 80)
        print("ê²€ì¦ ì™„ë£Œ!")
        print("=" * 80)

def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    import argparse
    
    parser = argparse.ArgumentParser(description='XML íŒŒì¼ì—ì„œ í•¨ìˆ˜ ì¶”ì¶œ ë° MySQL ê²€ì¦ v1.6')
    parser.add_argument('xml_file', help='ì²˜ë¦¬í•  XML íŒŒì¼ ê²½ë¡œ')
    parser.add_argument('--debug', action='store_true', help='ë””ë²„ê·¸ ëª¨ë“œ (ìƒì„±ëœ SQL ì¶œë ¥)')
    
    args = parser.parse_args()
    
    # XML íŒŒì¼ ê²½ë¡œë¥¼ ì ˆëŒ€ ê²½ë¡œë¡œ ë³€í™˜
    xml_file_path = os.path.abspath(args.xml_file)
    
    # XML íŒŒì¼ ì¡´ì¬ í™•ì¸
    if not os.path.exists(xml_file_path):
        print(f"âŒ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {xml_file_path}")
        sys.exit(1)
    
    # ê²€ì¦ê¸° ì‹¤í–‰
    validator = FunctionValidator(debug=args.debug)
    validator.process_file(xml_file_path)

if __name__ == "__main__":
    main()
