DB03.XMLToSQL.py 프로그램을 작성해주세요. 이 프로그램은 MyBatis/iBatis XML 매퍼 파일에서 SQL 구문을 추출하여 개별 SQL 파일로 저장하는 통합 프로그램입니다.

요구사항:
1. XML 파일 또는 XML 파일 목록(리스트 파일)에서 SQL 구문을 추출합니다.
2. 다음 SQL 태그를 처리합니다:
   - select
   - insert
   - update
   - delete
   - sql (재사용 가능한 SQL 조각)
3. CDATA 섹션과 include 참조를 처리합니다.
4. 추출된 SQL을 개별 파일로 저장합니다:
   - 파일명 형식: 어플리케이션이름.모듈명.sqlid.sql
   - 어플리케이션 이름은 $OMA_TRANSFORM 환경 변수를 사용하여 추출
5. XML 파일 이름에 따라 출력 디렉토리를 자동으로 결정합니다:
   - 'orcl'이 포함된 경우: orcl_sql_extract
   - 'pg'이 포함된 경우: pg_sql_extract
6. 배치 처리 기능을 구현하여 대량의 XML 파일을 효율적으로 처리합니다.
7. 파일명 분석 및 정리 기능을 포함합니다:
   - _orcl_sql.sql 또는 _pg_sql.sql로 끝나는 파일 분석
   - 중복 파일 확인 및 충돌 감지
   - 안전한 파일명 변경 수행
   - 원본 파일 백업

주요 기능:
1. XML 파싱 및 SQL 추출:
   - XML 파일에서 SQL 태그 식별
   - CDATA 섹션 처리
   - include 참조 해결
   - SQL 구문 정리 및 포맷팅
2. 파일명 분석 및 정리:
   - 파일명 패턴 분석
   - 어플리케이션 이름 추출
   - 중복 파일 처리
3. 배치 처리:
   - 메모리 효율적인 처리를 위한 배치 크기 설정
   - 병렬 처리 지원

XML 파싱 및 SQL 추출 함수:
```python
def extract_sql_from_xml(xml_file_path):
    """
    XML 파일에서 SQL 구문을 추출합니다.
    
    Args:
        xml_file_path (str): XML 파일 경로
        
    Returns:
        dict: SQL ID를 키로, SQL 내용을 값으로 하는 딕셔너리
    """
    try:
        # XML 파일 읽기
        with open(xml_file_path, 'r', encoding='utf-8') as f:
            xml_content = f.read()
            
        # 네임스페이스 처리
        xml_content = re.sub(r'xmlns="[^"]*"', '', xml_content)
        
        # XML 파싱
        root = ET.fromstring(xml_content)
        
        # SQL 태그 찾기
        sql_tags = {
            'select': './select',
            'insert': './insert',
            'update': './update',
            'delete': './delete',
            'sql': './sql'
        }
        
        extracted_sql = {}
        
        for tag_type, xpath in sql_tags.items():
            for element in root.findall(xpath):
                sql_id = element.get('id')
                if not sql_id:
                    continue
                    
                # SQL 내용 추출
                sql_content = ''
                
                # CDATA 섹션 처리
                if element.text:
                    sql_content = element.text.strip()
                
                # 자식 요소 처리 (include 등)
                for child in element:
                    if child.tag == 'include':
                        sql_content += f"<include refid=\"{child.get('refid')}\"/>"
                    elif child.tail:
                        sql_content += child.tail
                
                extracted_sql[sql_id] = {
                    'type': tag_type,
                    'content': sql_content
                }
        
        return extracted_sql
    except ET.ParseError as e:
        print(f"XML 파싱 오류 ({xml_file_path}): {e}")
        return {}
    except Exception as e:
        print(f"파일 처리 오류 ({xml_file_path}): {e}")
        return {}
```

include 참조 해결 방법:
1. 첫 번째 패스에서 모든 XML 파일을 스캔하여 <sql id="..."> 태그를 찾고 ID와 내용을 매핑합니다.
2. 두 번째 패스에서 <include refid="..."/> 태그를 발견하면 매핑된 내용으로 대체합니다.
3. 중첩된 include도 처리할 수 있도록 재귀적 해결 알고리즘을 구현합니다:
   ```python
   def resolve_includes(sql_text, sql_fragments, depth=0):
       """
       SQL 텍스트에서 include 참조를 해결합니다.
       
       Args:
           sql_text (str): SQL 텍스트
           sql_fragments (dict): SQL ID와 내용 매핑
           depth (int): 재귀 깊이
           
       Returns:
           str: include가 해결된 SQL 텍스트
       """
       if depth > 10:  # 무한 재귀 방지
           print(f"경고: include 재귀 깊이 제한 초과 (최대 10)")
           return sql_text
       
       # include 태그 찾기
       pattern = r'<include\s+refid=[\'"]([^\'"]+)[\'"]\s*/>'
       matches = list(re.finditer(pattern, sql_text))
       
       # 매치가 없으면 원본 반환
       if not matches:
           return sql_text
       
       # 각 include 태그를 해당 SQL 조각으로 대체
       result = sql_text
       for match in reversed(matches):  # 역순으로 처리하여 위치 변화 방지
           include_id = match.group(1)
           if include_id in sql_fragments:
               # 재귀적으로 중첩된 include 해결
               fragment = resolve_includes(sql_fragments[include_id], sql_fragments, depth + 1)
               result = result[:match.start()] + fragment + result[match.end():]
           else:
               print(f"경고: include ID '{include_id}'를 찾을 수 없습니다")
       
       return result
   ```

4. SQL 조각 수집 함수:
   ```python
   def collect_sql_fragments(xml_files):
       """
       모든 XML 파일에서 SQL 조각을 수집합니다.
       
       Args:
           xml_files (list): XML 파일 경로 목록
           
       Returns:
           dict: SQL ID를 키로, SQL 내용을 값으로 하는 딕셔너리
       """
       sql_fragments = {}
       
       for xml_file in xml_files:
           try:
               # XML 파일 읽기
               with open(xml_file, 'r', encoding='utf-8') as f:
                   xml_content = f.read()
               
               # 네임스페이스 처리
               xml_content = re.sub(r'xmlns="[^"]*"', '', xml_content)
               
               # XML 파싱
               root = ET.fromstring(xml_content)
               
               # SQL 조각 찾기
               for sql_element in root.findall('./sql'):
                   sql_id = sql_element.get('id')
                   if not sql_id:
                       continue
                   
                   # SQL 내용 추출
                   sql_content = ET.tostring(sql_element, encoding='unicode')
                   # 태그 제거
                   sql_content = re.sub(r'<sql[^>]*>(.*)</sql>', r'\1', sql_content, flags=re.DOTALL)
                   sql_content = sql_content.strip()
                   
                   sql_fragments[sql_id] = sql_content
           except Exception as e:
               print(f"SQL 조각 수집 오류 ({xml_file}): {e}")
       
       return sql_fragments
   ```

병렬 처리 구현:
1. ThreadPoolExecutor를 사용하여 XML 파일을 병렬로 처리합니다:
   ```python
   def process_files_in_parallel(file_list, sql_fragments, batch_size=100, max_workers=None):
       """
       XML 파일을 병렬로 처리합니다.
       
       Args:
           file_list (list): XML 파일 경로 목록
           sql_fragments (dict): SQL ID와 내용 매핑
           batch_size (int): 배치 크기
           max_workers (int): 최대 작업자 수
           
       Returns:
           list: 처리 결과 목록
       """
       results = []
       
       # 최대 작업자 수 설정 (기본값: CPU 코어 수)
       if max_workers is None:
           max_workers = os.cpu_count() or 4
       
       with ThreadPoolExecutor(max_workers=max_workers) as executor:
           # 파일 목록을 배치로 나누기
           batches = [file_list[i:i+batch_size] for i in range(0, len(file_list), batch_size)]
           
           # 각 배치를 병렬로 처리
           futures = {executor.submit(process_batch, batch, sql_fragments): i 
                     for i, batch in enumerate(batches)}
           
           # 진행 상황 표시
           total_batches = len(batches)
           completed = 0
           
           # 결과 수집
           for future in as_completed(futures):
               batch_index = futures[future]
               try:
                   batch_results = future.result()
                   results.extend(batch_results)
               except Exception as e:
                   print(f"배치 처리 오류 (배치 {batch_index+1}/{total_batches}): {e}")
               
               # 진행 상황 업데이트
               completed += 1
               print(f"처리 중: {completed}/{total_batches} 배치 완료 ({completed/total_batches*100:.1f}%)")
       
       return results
   ```

2. 공유 리소스에 대한 락 메커니즘 구현:
   ```python
   # 파일 쓰기 작업을 위한 락
   file_lock = threading.Lock()
   
   def write_sql_to_file(sql_content, output_path):
       """
       SQL 내용을 파일에 안전하게 저장합니다.
       
       Args:
           sql_content (str): SQL 내용
           output_path (str): 출력 파일 경로
       """
       with file_lock:
           # 출력 디렉토리 생성
           os.makedirs(os.path.dirname(output_path), exist_ok=True)
           
           # 파일 쓰기
           with open(output_path, 'w', encoding='utf-8') as f:
               f.write(sql_content)
   ```

파일명 분석 및 정리:
```python
def analyze_and_rename_files(directory, backup=True):
    """
    SQL 파일명을 분석하고 정리합니다.
    
    Args:
        directory (str): SQL 파일 디렉토리
        backup (bool): 원본 파일 백업 여부
        
    Returns:
        dict: 처리 결과 통계
    """
    # 패턴: app_name.module_name.query_name_orcl_sql.sql
    pattern = re.compile(r'(.+?)\.(.+?)\.(.+?)_(orcl|pg)_sql\.sql$')
    
    # 결과 통계
    stats = {
        'total': 0,
        'renamed': 0,
        'skipped': 0,
        'errors': 0
    }
    
    # 디렉토리 내 모든 SQL 파일 처리
    for file_name in os.listdir(directory):
        if not file_name.endswith('.sql'):
            continue
            
        stats['total'] += 1
        file_path = os.path.join(directory, file_name)
        
        # 파일명 패턴 매칭
        match = pattern.match(file_name)
        if not match:
            print(f"패턴 불일치: {file_name}")
            stats['skipped'] += 1
            continue
            
        # 파일명 구성요소 추출
        app_name, module_name, query_name, db_type = match.groups()
        
        # 새 파일명 생성
        new_name = f"{app_name}.{module_name}.{query_name}.sql"
        new_path = os.path.join(directory, new_name)
        
        # 파일명 충돌 확인
        if os.path.exists(new_path) and file_path != new_path:
            print(f"파일명 충돌: {new_name} (기존 파일 존재)")
            stats['skipped'] += 1
            continue
            
        try:
            # 원본 파일 백업
            if backup:
                backup_dir = os.path.join(directory, 'backup')
                os.makedirs(backup_dir, exist_ok=True)
                backup_path = os.path.join(backup_dir, file_name)
                shutil.copy2(file_path, backup_path)
            
            # 파일 이름 변경
            os.rename(file_path, new_path)
            stats['renamed'] += 1
            print(f"이름 변경: {file_name} → {new_name}")
        except Exception as e:
            print(f"이름 변경 오류 ({file_name}): {e}")
            stats['errors'] += 1
    
    return stats
```

오류 처리:
1. XML 파싱 오류 처리:
   ```python
   def safe_parse_xml(xml_file_path):
       """
       XML 파일을 안전하게 파싱합니다.
       
       Args:
           xml_file_path (str): XML 파일 경로
           
       Returns:
           ElementTree.Element: XML 루트 요소 또는 None
       """
       try:
           # XML 파일 읽기
           with open(xml_file_path, 'r', encoding='utf-8') as f:
               xml_content = f.read()
           
           # 네임스페이스 처리
           xml_content = re.sub(r'xmlns="[^"]*"', '', xml_content)
           
           # XML 파싱
           return ET.fromstring(xml_content)
       except ET.ParseError as e:
           line_num, column = e.position
           print(f"XML 파싱 오류 ({xml_file_path}:{line_num}): {e}")
           
           # 부분적으로 손상된 XML 복구 시도
           try:
               parser = ET.XMLParser(recover=True)
               with open(xml_file_path, 'r', encoding='utf-8') as f:
                   return ET.parse(f, parser).getroot()
           except Exception:
               print(f"XML 복구 실패: {xml_file_path}")
               return None
       except UnicodeDecodeError:
           # 다른 인코딩 시도
           try:
               with open(xml_file_path, 'r', encoding='cp949') as f:
                   xml_content = f.read()
               xml_content = re.sub(r'xmlns="[^"]*"', '', xml_content)
               return ET.fromstring(xml_content)
           except Exception as e:
               print(f"인코딩 오류 ({xml_file_path}): {e}")
               return None
       except Exception as e:
           print(f"파일 처리 오류 ({xml_file_path}): {e}")
           return None
   ```

2. 파일 시스템 오류 처리:
   ```python
   def safe_write_file(content, file_path):
       """
       파일을 안전하게 저장합니다.
       
       Args:
           content (str): 파일 내용
           file_path (str): 파일 경로
           
       Returns:
           bool: 성공 여부
       """
       try:
           # 디렉토리 생성
           os.makedirs(os.path.dirname(file_path), exist_ok=True)
           
           # 디스크 공간 확인
           disk_usage = shutil.disk_usage(os.path.dirname(file_path))
           if disk_usage.free < len(content) * 2:  # 2배 여유 공간 필요
               print(f"디스크 공간 부족: {disk_usage.free} bytes 남음")
               return False
           
           # 파일 쓰기
           with open(file_path, 'w', encoding='utf-8') as f:
               f.write(content)
           
           return True
       except PermissionError:
           print(f"권한 오류: {file_path} 쓰기 권한 없음")
           return False
       except OSError as e:
           print(f"파일 시스템 오류: {e}")
           return False
       except Exception as e:
           print(f"파일 쓰기 오류: {e}")
           return False
   ```

3. 로깅 시스템 구현:
   ```python
   import logging
   
   def setup_logging(verbose=False):
       """
       로깅 시스템을 설정합니다.
       
       Args:
           verbose (bool): 상세 로깅 여부
       """
       log_level = logging.DEBUG if verbose else logging.INFO
       
       # 로그 포맷 설정
       log_format = '%(asctime)s - %(levelname)s - %(message)s'
       date_format = '%Y-%m-%d %H:%M:%S'
       
       # 로거 설정
       logger = logging.getLogger('XMLToSQL')
       logger.setLevel(log_level)
       
       # 콘솔 핸들러
       console_handler = logging.StreamHandler()
       console_handler.setLevel(log_level)
       console_handler.setFormatter(logging.Formatter(log_format, date_format))
       
       # 파일 핸들러
       file_handler = logging.FileHandler('xmltosql.log')
       file_handler.setLevel(logging.DEBUG)  # 파일에는 항상 상세 로그
       file_handler.setFormatter(logging.Formatter(log_format, date_format))
       
       # 핸들러 추가
       logger.addHandler(console_handler)
       logger.addHandler(file_handler)
       
       return logger
   ```

사용 예시:
```
# 기본 사용법 (orcl_xml.lst와 pg_xml.lst 자동 처리)
python3 DB03.XMLToSQL.py

# 특정 XML 목록 파일 처리
python3 DB03.XMLToSQL.py orcl_xml.lst

# 단일 XML 파일 처리
python3 DB03.XMLToSQL.py /path/to/mapper.xml

# 배치 크기 조정
python3 DB03.XMLToSQL.py --batch-size 200

# 병렬 처리 스레드 수 지정
python3 DB03.XMLToSQL.py --threads 8

# 파일명 분석만 수행 (이름 변경 없음)
python3 DB03.XMLToSQL.py --analyze-only --no-rename

# 파일명 분석 및 이름 변경만 수행
python3 DB03.XMLToSQL.py --analyze-only

# XML 처리만 수행 (파일명 분석 없음)
python3 DB03.XMLToSQL.py --no-analyze

# 상세 로깅 활성화
python3 DB03.XMLToSQL.py --verbose

# 출력 디렉토리 지정
python3 DB03.XMLToSQL.py --orcl-output custom_orcl_dir --pg-output custom_pg_dir

# 백업 비활성화
python3 DB03.XMLToSQL.py --no-backup
```

프로그램은 처리 진행 상황을 표시하고, 완료 후에는 처리된 파일 수와 추출된 SQL 수를 요약하여 보여줍니다.
