[Oracle, PostgreSQL Expert Mode Activated]
As an expert in both Oracle and PostgreSQL database systems, as well as MyBatis framework:

1. Apply deep knowledge of Oracle and PostgreSQL syntax differences.
2. Utilize advanced understanding of MyBatis XML mapper file structures.
3. Implement best practices for SQL optimization in both Oracle and PostgreSQL contexts.
4. Consider edge cases and complex scenarios in SQL conversion.
5. Provide detailed explanations for non-trivial conversions when necessary.
6. Maintain a high level of precision in syntax and semantic translations.
7. Be aware of version-specific features and their compatibility.
8. Adhere strictly to the conversion rules and guidelines provided.
9. Anticipate and address potential issues that may arise from the conversion process.
10. Ensure that the converted queries maintain equivalent functionality and performance characteristics.

Task: Convert MyBatis-based Oracle SQL Mapper files to PostgreSQL-compatible SQL Mapper files
A. Environment Setup:
  1. Environment Configuration:
      1.1 Directories:
          - Working Directory: {L1FolderName}
          - Source Files: {MAPPER_ORCLL1_DIR}
          - Target Files: {MAPPER_PGL1_DIR}
          - Logs: {L1FolderName}

  2. Execution Status Management:
      2.1 Status File:
          - Location: {L1FolderName}/status.txt
          - Format:
              Step 1: [Status]
              Step 2: [Status]
              Step 3: [Status]
              Step 4: [Status]

      2.2 Status Values:
          - Not Started
          - In Progress
          - Completed

      2.3 Status Check Logic:
          A. If status.txt exists:
              - Check each Step status
              - If all Steps Completed → terminate
              - Else → continue from first incomplete Step

          B. If status.txt doesn't exist:
              - Create new status.txt
              - Initialize all Steps to "Not Started"

  3. Processing Rules:
      3.1 Log Directory:
          - Preserve all contents
          - Never delete existing logs

      3.2 Status Updates:
          - Update to "In Progress" when Step begins
          - Update to "Completed" when Step ends

B. Task Progression Steps:
  Step 1. Generate list of mapper files to be converted

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 1: In Progress"

    2. File List Generation:
        2.1 Command Execution:
            - Command: ls *{ORIGIN_SUFFIX}* | sort
        
        2.2 Output:
            - List of files with {ORIGIN_SUFFIX} extension
            - Sorted in alphabetical order

    3. Completion:
        3.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 1: Completed"

  Step 2. Analyze SQL for all {MAPPER_ORCLL1_DIR}/*{ORIGIN_SUFFIX}*.xml files

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 2: In Progress"

    2. Analysis Scope:
        2.1 Primary Focus:
            - Oracle to PostgreSQL conversion feasibility
            - PL/SQL block identification and analysis

    3. SQL Statement Validation:
        3.1 Keyword Verification:
            - SELECT
            - INSERT
            - UPDATE
            - DELETE
            - MERGE
            - WITH
            - DECLARE
            - BEGIN
            - CREATE
            - ALTER

        3.2 Structure Analysis:
            A. Basic SQL Validation:
                - Statement structure verification
                - Syntax completeness check

            B. CDATA Section Analysis:
                - Internal SQL structure verification
                - Nested query validation

    4. Non-SQL Pattern Detection:
        4.1 Content Types:
            - HTML/JavaScript code
            - Plain text/descriptive content
            - Whitespace/special characters only
            - XML tags/configuration only

    5. Analysis Documentation:
        5.1 Output File:
            - Location: {L1FolderName}/sql_analysis.txt
            
        5.2 Format:
            SQL Analysis Results:
            1. [Query ID]:
              - Type: [query type]
              - Contains: [key features]
              - Oracle-specific features: [list if any]
              - Conversion needed: [Yes/No]

        5.3 Example:
            SQL Analysis Results:
            1. checkDrawStatus:
              - Type: SELECT query
              - Contains: COUNT function with BETWEEN and dynamic IN clause
              - Oracle-specific features: None
              - Conversion needed: No

    6. Completion:
        6.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 2: Completed"

  Step 3. Perform Oracle to PostgreSQL conversion for all {MAPPER_ORCLL1_DIR}/*{ORIGIN_SUFFIX}*.xml files
    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 3: In Progress"

    2. Global Processing Rules:
        - Convert SQL within dynamic query tags
        - Preserve CDATA sections
        - Maintain comment processing and indentation
        - Check parameterType attribute
        - Protect dynamic variable substitution parts    
        - Convert Oracle SQL to PostgreSQL SQL as needed
        - Validate converted SQL

              
    3. Basic Conversion Rules:
        3.1 Pattern Evaluation:
            A. All Source Files Must Be Processed:
                - Every file in source directory requires conversion attempt
                - DO NOT skip files even if they appear to have no SQL
                - Log all file processing attempts

        3.2 Naming Conventions:
            - Never modify anything within #{...} brackets. Treat #{...} patterns as sacred, unchangeable tokens
            - Preserve case sensitivity for all table names, column names, sequence names and aliases exactly as in the original query
            - For sequences:
                * Convert sequence names to lowercase
                * Always add single quotes around sequence names in nextval() calls
                * Example: SEQ_USER.NEXTVAL → nextval('seq_user')

    4. XML Tag Processing:
        4.1 Target Tags for SQL Conversion:
            A. Basic SQL Tags:
                - <sql>
                - <select>
                - <insert>
                - <update>
                - <delete>

            B. Subquery and Key Tags:
                - <include>
                - <selectKey>

            C. Result Mapping Tags:
                - <resultMap>
                    * <id>
                    * <result>
                    * <constructor>
                    * <collection>
                    * <association>
                    * <discriminator>

            D. Parameter Mapping Tags:
                - <parameterMap>
                - <parameter>

            E. Cache Tags:
                - <cache>
                - <cache-ref>

        4.2 Protected Dynamic Tags:
            - Flow control: <if>, <choose>, <when>, <otherwise>
            - Iteration: <foreach>
            - Variable binding: <bind>
            - Parameters: #{variable_name}, ${variable_name}

        4.3 CDATA Processing Example:
            Original:
            <select id="getEmployee">
                <![CDATA[
                    SELECT * FROM emp
                    WHERE rownum <= 10  /* Requires conversion */
                ]]>
            </select>

            Convert to:
            <select id="getEmployee">
                <![CDATA[
                    SELECT * FROM emp
                    LIMIT 10
                ]]>
            </select>

    5. ResultMap Processing:
        5.1 Java Type Conversions:
            - javaType="java.math.BigDecimal" → javaType="INTEGER" or "NUMERIC"
            - javaType="oracle.sql.TIMESTAMP" → javaType="java.sql.Timestamp"
            - javaType="CLOB" → javaType="String"
            - javaType="BLOB" → javaType="byte[]"

        5.2 JDBC Type Conversions:
            - jdbcType="NUMBER" → jdbcType="NUMERIC"
            - jdbcType="VARCHAR2" → jdbcType="VARCHAR"
            - jdbcType="CLOB" → jdbcType="TEXT"
            - jdbcType="BLOB" → jdbcType="BYTEA"
            - jdbcType="DATE" → jdbcType="TIMESTAMP"

        5.3 Column Mapping Verification:
            - Check column names match PostgreSQL case sensitivity
            - Verify column data types are compatible
            - Ensure property names in resultMap match Java entity fields

        5.4 Implementation Example:
            Original:
            <resultMap id="empMap" type="Employee">
                <result property="salary" column="SALARY" javaType="java.math.BigDecimal" jdbcType="NUMBER"/>
            </resultMap>

            Convert to:
            <resultMap id="empMap" type="Employee">
                <result property="salary" column="SALARY" javaType="NUMERIC" jdbcType="NUMERIC"/>
            </resultMap>

    6. Key Conversion Points:
        6.1 Sequence Handling:
            A. Basic sequence conversion:
                Oracle:    SELECT #{sequence_name}.NEXTVAL FROM DUAL
                PostgreSQL: SELECT nextval('#{sequence_name}')   /* 따옴표 필요 */

            B. SelectKey pattern:
                Original:
                <selectKey keyProperty="id" resultType="long" order="BEFORE">
                    SELECT #{sequence_name}.NEXTVAL FROM DUAL
                </selectKey>

                Convert to:
                <selectKey keyProperty="id" resultType="long" order="BEFORE">
                    SELECT nextval('#{sequence_name}')   /* 따옴표 필요 */
                </selectKey>

            C. Sequence naming rules:
                - Convert sequence names to lowercase
                - Always use single quotes
                - Examples:
                    SEQ_EFIPM_ID.NEXTVAL → nextval('seq_efipm_id')
                    MY_SEQ.NEXTVAL → nextval('my_seq')
                        
        6.2 Pagination Handling:
            A. ROWNUM based pagination:
                Original:
                <select id="getList">
                    SELECT * FROM (
                        SELECT ROWNUM AS rnum, a.* FROM (
                            ${originalQuery}
                        ) a WHERE ROWNUM <= #{end}
                    ) WHERE rnum >= #{start}
                </select>

                Convert to:
                <select id="getList">
                    ${originalQuery}
                    LIMIT #{pageSize} OFFSET #{start}
                </select>

            B. Additional patterns:
                - ROW_NUMBER() OVER() → LIMIT/OFFSET
                - ROWNUM based subqueries → LIMIT/OFFSET

        6.3 Common Oracle to PostgreSQL conversions:
            - NVL() → COALESCE()
            - DECODE() → CASE WHEN
            - SYSDATE → CURRENT_TIMESTAMP
            - FROM DUAL → Remove DUAL    
            - SUBSTR → SUBSTRING
            - TO_CHAR/TO_DATE format conversion
            - ROWNUM → ROW_NUMBER() OVER()
            - (+) → Explicit OUTER JOIN syntax
            - v$session → pg_stat_activity
            - LISTAGG → STRING_AGG
            - CONNECT BY → WITH RECURSIVE
            - ADD_MONTHS → + INTERVAL
            - MONTHS_BETWEEN → AGE/EXTRACT
            - LAST_DAY → DATE_TRUNC('MONTH') + INTERVAL '1 MONTH - 1 day'
            - SEQNAME.NEXTVAL → nextval('seqname')   // Maintain original case, do not add quotes
            - SEQNAME.CURRVAL → currval('seqname')   // Maintain original case, do not add quotes
            - CHR(ASCII('A')+n) → CHR((ASCII('A')::integer)+n) 
            - NULL handling:
                * NVL2(exp1, exp2, exp3) → CASE WHEN exp1 IS NOT NULL THEN exp2 ELSE exp3 END
                * NULLIF(exp1, exp2) → NULLIF(exp1, exp2)
            - TO_DATE conversion:
                * Date only: Keep TO_DATE
                * Date with time: Convert to TO_TIMESTAMP
                Example:
                * TO_DATE('20250424', 'YYYYMMDD') → Keep as is
                * TO_DATE('2025-04-24 13:45:00', 'YYYY-MM-DD HH24:MI:SS') → TO_TIMESTAMP('2025-04-24 13:45:00', 'YYYY-MM-DD HH24:MI:SS')
            - Date format patterns (maintain as is):
                * MI, HH24, DD, MM, YYYY, YYYYMMDD, YYYY-MM-DD HH24:MI:SS
            - Explicit type casting for string and date comparisons: 
                SUBSTRING(date_column,1,8)::date = TO_DATE('20250424', 'YYYYMMDD')
            - Use INTERVAL for date calculations: 
                TO_DATE(date, 'YYYYMMDD') + INTERVAL '3 days'
            - Preserve &lt; and &gt; in original SQL
            - Remove ORDER BY for aggregate functions without GROUP BY
                Example: SELECT COUNT(empno) FROM emp ORDER BY reg_dttm → SELECT COUNT(empno) FROM emp
            - Maintain inequality signs as they are


    7. PL/SQL DECLARE Section Processing:

        7.1 Identification and Preprocessing:
            A. Scan for DECLARE sections:

        7.2 Critical Requirements:
            A. ALL %TYPE references MUST be maintained
            B. NO initializations in DECLARE section
            C. Proper handling of bind variables is ESSENTIAL
            D. Never modify anything within #{...} brackets. Treat #{...} patterns as sacred, unchangeable tokens
            E. NEVER modify variable case

        7.3 Basic DECLARE Statement Structure:
            A. Opening Declaration:
                - Oracle 'DECLARE' → PostgreSQL 'DO $$\nDECLARE'
            B. Closing Statement:
                - Add '$$ LANGUAGE plpgsql;' at the end of the block

        7.4 Variable Declaration Rules:
            A. %TYPE References (MANDATORY):
                - Convert to lowercase: table_name.column_name%TYPE
                - NEVER convert to general data types
                Example:
                    Correct:
                        DECLARE
                            v_emp_id    employees.employee_id%TYPE;
                        BEGIN
                            v_emp_id := 100;
                    
                    PROHIBITED:
                        DECLARE
                            v_emp_id    INTEGER;  /* WRONG! */

            B. Data Type Mapping:
                - VARCHAR2(n) → VARCHAR
                - CHAR(n) → VARCHAR
                - NUMBER → NUMERIC
                - NUMBER(p) → INTEGER  (p <= 10)
                - NUMBER(p,s) → NUMERIC(p,s)
                - DATE → TIMESTAMP
                - CLOB → TEXT
                - BLOB → BYTEA
                - BOOLEAN → BOOLEAN
                - RAW → BYTEA
                - LONG RAW → BYTEA
                - TIMESTAMP → TIMESTAMP
                - TIMESTAMP WITH TIME ZONE → TIMESTAMP WITH TIME ZONE

            C. Special Cases:
                - Remove VARCHAR length specifications
                - Detailed NUMBER handling:
                    * Plain NUMBER → NUMERIC
                    * NUMBER(p) → INTEGER (p ≤ 10)
                    * NUMBER(p,s) → NUMERIC(p,s)

        7.5 Variable Management:
            A. Initialization Rules:
                - NO initializations in DECLARE section
                - ALL initializations MUST move to BEGIN section
            
            B. Bind Variable Handling:
                - Maintain MyBatis bind variable syntax: #{variable_name}
                - Move all bind variable assignments to BEGIN section
                - For %TYPE variables, do not add type casts to bind variables
                - For explicitly typed variables, add appropriate type casts

        7.6 Additional Considerations:
            A. CDATA sections:
                - Must be preserved

            B. Error Handling:
                - EXCEPTION WHEN → EXCEPTION WHEN
                - NO_DATA_FOUND → NO_DATA_FOUND
                - TOO_MANY_ROWS → TOO_MANY_ROWS
                - OTHERS → OTHERS
        7.7 Implementation Example:
            Original Oracle Code:
                DECLARE
                    V_EMP_ID    EMPLOYEES.EMPLOYEE_ID%TYPE := #{EMPID};
                    V_NAME      VARCHAR2(100) := #{EMPNAME};
                    V_SALARY    NUMBER(10,2) := #{EMPSALARY};
                    V_DEPTNAME  DEPT.DEPTNAME%TYPE   := NVL(#{DEPTNAME}      ,'');
                BEGIN
                    -- logic
                END;

            Correct PostgreSQL Conversion:
                DECLARE
                    V_EMP_ID    employees.employee_id%TYPE;
                    V_NAME      VARCHAR;
                    V_SALARY    NUMERIC(10,2);
                    V_DEPTNAME  DEPT.DEPTNAME%TYPE;
                BEGIN
                    V_EMP_ID := #{EMPID};
                    V_NAME   := #{EMPNAME};
                    V_SALARY := #{EMPSALARY};
                    V_DEPTNAME   := COALESCE(#{DEPTNAME} ,'');
                    -- logic
                END;

    8. Processing SQL within CDATA Sections:
        8.1 CDATA Handling:
            - Preserve <![CDATA[ and ]]> markers
            - Maintain original formatting and indentation

        8.2 SQL Conversion:
            - Convert Oracle SQL to PostgreSQL SQL
            - Protect #{...} and ${...} patterns
            - Preserve dynamic query elements

        8.3 Validation:
            - Verify CDATA structure integrity
            - Check converted SQL syntax
              
    9. Comment Requirements:
        9.1 Comment Location:
            - Inside <mapper> tag
            - Above SQL definition tags

        9.2 Comment Format:
            <!-- YYYY-MM-DD Amazon Q Developer : description -->
            Example:
            <mapper namespace="AuthListDAO">
                <!-- 2025-04-27 Amazon Q Developer : Converted date formatting -->
                <sql id="selectAuthListQuery">

    10. Final Error Checks:
        10.1 Structure Checks:
            - XML tag structure damage
            - CDATA section integrity

        10.2 Functional Checks:
            - Dynamic query tags operation
            - Variable binding syntax accuracy

    11. For Each Source File:
        11.1 Apply Conversion Rules (Steps 2-10)
        11.2 Save Converted File:
            - Target Directory: {MAPPER_PGL1_DIR}
            - Filename Replace: {ORIGIN_SUFFIX} → {TRANSFORM_SUFFIX}

    12. Final Step:
        12.1 Update Final Status:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 3: Completed"
     
  Step 4. Perform xmllint validation on all {MAPPER_PGL1_DIR}/*{TRANSFORM_SUFFIX}*.xml files

    1. Initial Setup:
        1.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 4: In Progress"

    2. Target File Verification:
        2.1 Command Execution:
            - Command: ls {MAPPER_PGL1_DIR}/*{TRANSFORM_SUFFIX}*.xml | sort
            - Purpose: Confirm list of files for validation

    3. XML Validation Process:
        3.1 Validation Command:
            - Tool: xmllint
            - Format: xmllint --noout [filepath] 2>&1
            Example:
            xmllint --noout {MAPPER_PGL1_DIR}/AuthDAO{TRANSFORM_SUFFIX}-01-select-createAuthNo.xml 2>&1

        3.2 Error Handling:
            - Special Case: "StartTag: invalid element name"
                * If related to inequality signs
                * Can be ignored in MyBatis environment
                * No action required

        3.3 Logging:
            - Do not create separate validation log file
            - Display results in console only

    4. Completion:
        4.1 Status Update:
            - Location: {L1FolderName}/status.txt
            - Content: "Step 4: Completed"

